<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅谈Netty]]></title>
    <url>%2F2019%2F08%2F25%2F%E6%B5%85%E8%B0%88Netty%2F</url>
    <content type="text"><![CDATA[一、Netty简介1.1 概念​ Netty是由JBOSS提供的一个java开源框架。Netty提供异步的、时间驱动网络应用程序框架和工具，用以快速开发高性能、高可靠的网络服务和客户端程序。 ​ 也就是说，Netty是一个基于NIO的客户、服务器端编程框架，使用Netty可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户，服务端应用。Netty相当简化和流线化了网络应用的编程开发过程，例如，TCP和UDP的socket服务开发。 1.2 线程模型1.2.1 单线程模型​ 在ServerBootstrap调用方法group的时候，传递的参数是同一个线程组，且在构造线程组的时候，构造参数为1，这种开发方式，就是一个单线程模型。 ​ 使用场景：个人机开发测试使用。不推荐。 1.2.2 多线程模型​ 在ServerBootstrap调用方法group的时候，传递的参数是两个不同的线程组。负责监听的acceptor线程组，线程数为1，也就是构造参数为1。负责处理客户任务的线程组，线程数大于1，也就是构造参数大于1。这种开发方式，就是多线程模型。 ​ 使用场景：长连接，且客户端数量较少，连接持续时间较长情况下使用。如：企业内部交流应用。 1.2.3 主从多线程模型​ 在ServerBootstrap调用方法group的时候，传递的参数是两个不同的线程组。负责监听的acceptor线程组，线程数大于1，也就是构造参数大于1。负责处理客户端任务的线程组，线程数大于 1，也就是构造参数大于 1。这种开发方式，就是主从多线程模型。 ​ 使用场景：长连接，客户端数量相对较多，连接持续时间比较长的情况下使用。如：对外提供服务的相册服务器。 二、Netty拆包粘包问题2.1 粘包问题的原因​ Netty使用TCP/IP协议传输数据。而TCP/IP协议类似水流一样的数据传输方式，并且Netty是基于NIO（非阻塞式IO）。多次访问的时候就有可能出现多条数据粘连，造成数据的错误和不完整，这就是Netty的粘包问题。 2.2 粘包问题的解决2.2.1 定长数据流​ 客户端和服务器，提前协调好，每个消息长度固定。（如：长度 10）。如果客户端或服务器写出的数据不足 10，则使用空白字符补足（如：使用空格）。 2.2.2 特殊结束符​ 客户端和服务器，协商定义一个特殊的分隔符号，分隔符号长度自定义。如：‘#’、‘$_$’、‘AA@’。在通讯的时候，只要没有发送分隔符号，则代表一条数据没有结束。 2.2.3 协议​ 相对最成熟的数据传递方式。有服务器的开发者提供一个固定格式的协议标准。客户端和服务器发送数据和接受数据的时候，都依据协议制定和解析消息。 三、定时断线重连​ 客户端断线重连机制。​ 客户端数量多，且需要传递的数据量级较大。可以周期性的发送数据的时候使用。要求对数据的即时性不高的时候，才可使用。​ 优点： 可以使用数据缓存。不是每条数据进行一次数据交互。可以定时回收资源，对资源利用率高。相对来说，即时性可以通过其他方式保证。如： 120 秒自动断线。数据变化 1000 次请求服务器一次。300 秒中自动发送不足 1000 次的变化数据。 四、心跳监测4.1心跳监测​ 使用定时发送消息的方式，实现硬件检测，达到心态检测的目的。​ 心跳监测是用于检测电脑硬件和软件信息的一种技术。如：CPU 使用率，磁盘使用率，内存使用率，进程情况，线程情况等。 4.2 sigar​ 需要下载一个 zip 压缩包。内部包含若干 sigar 需要的操作系统文件。sigar 插件是通过JVM 访问操作系统，读取计算机硬件的一个插件库。读取计算机硬件过程中，必须由操作系统提供硬件信息。硬件信息是通过操作系统提供的。zip 压缩包中是 sigar 编写的操作系统文件，如：windows 中的动态链接库文件。​ 解压需要的操作系统文件，将操作系统文件赋值到${Java_home}/bin 目录中。]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL读写分离]]></title>
    <url>%2F2019%2F08%2F23%2FMySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[一、MySQL的读写分离1.1 为什么要使用MySQL的读写分离？​ 在高并发的场景下，当用户发起大量请求时，缓存肯定放不下所有数据，那么这些请求就会落到数据库上，当数据库的读写请求太高（2000次/s）时，数据库就会报警，磁盘IO开始变慢，CPU负载过高，内存使用率过高。当数据库读写请求达到4000/s，5000/s，8000/s时，数据库就会直接宕机，所以为了解决这种问题就诞生了MySQL的读写分离。 1.2 MySQL的读写分离怎么实现​ 通过MySQL的主从复制 ​ 就是基于主从复制架构，简单的来说，就是搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。 二、主从复制2.1 MySQL主从复制原理是啥？ ​ 图片来自“石杉码农学院” 原理：用户发来一个写请求后，主库将变更数据，然后写binlog日志，然后从库连接到主库之后，从库有一个IO线程，将主库额binlog日志拷贝到自己本地，写入relay日志，接着从库中有一个SQL线程会从relay日志读取变更，然后执行变更的内容，也就是说在自己本地再次执行一遍SQL，这样就可以保证自己跟主库的数据是一样的。 2.2 主从复制带来的问题​ 首先要明确一点，就是从库同步主库数据的过程是串行化的，就就是说主库上并行操作，在从库上会串行执行。 ​ 所以这样就会引出一个问题：由于从库从主库拷贝日志以及串行串行执行SQL的特点，在搞并打场景下，从库的数据一定会比主库慢一些，是有延时的。所以经常会出现，刚写入主库的数据可能读不到，要过个几十毫秒，甚至几百毫秒才能读取到。即主从延迟。 ​ 在实际生产中就有这种场景： ​ 数据已全部同步到从库后，主库突然发生了宕机 ​ 解决：将从库变更为主库 ​ 数据还没有全部同步到从库中时，主库突然发生了宕机 ​ 解决： ​ 提前开启MySQL所支持的半同步机制。所谓半同步机制就是指：当用户发送一个写请求后，如果主库还没有同步到从库时，那么系统会认为这个写操作是失败的，然后给客户反馈一个失败的信息，然后客户重新发送，在这期间系统就将从库变更为了主库。 ​ 并行复制：MySQL5.7支持的新特性，从库开启多个线程，并行读取relay日志中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。 2.3 当主从延迟比较严重时如何解决？​ 先看一个场景：当你写业务代码时，先在数据库中插入一条数据，这时在立马将该数据查询出来，然后对其进行修改。 ​ 分析上述场景：在数据库中插入数据是在主库中修改，然后由于主从延迟问题该数据还没有同步到从库，然后你又立马查询就会查不到结果，然后你的修改起始就也是无效的。 ​ 解决： 分库，将一个主库拆分成为4个主库，每个主库的写并发就降低了，此时的主从延迟就可以忽略不计 打开MySQL支持的并行复制，多个库并行复制，如果说某个库的写入并发就是特别高，单库写并发达到了2000次/s，并行复制的意义其实不是很大 重写代码，插入数据之后直接修改，那么这两个操作就都是在主库中进行的了 如果业务上是存在这种必须先插入，立马查询，在修改的业务逻辑，那么就可以对这个操作设置直连主库。不推荐使用，因为这样导致读写分离的意义丧失了 三、在什么场景下使用MySQL的主从同步​ 建议是一般在读远远多去写，而且读的时候一般对数据时效性要求没那么高的时候，使用 本文参考自：石杉码农学院的中华石杉老师的 “java工程师面试突击第一季”]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈shell]]></title>
    <url>%2F2019%2F08%2F16%2F%E6%B5%85%E8%B0%88shell%2F</url>
    <content type="text"><![CDATA[本文参考自《菜鸟教程》 一、什么是shell？1.1 shell概念Shell是一个用c语言编写的程序，它是用户使用Linux的桥梁；是一个脚本语言。 1.2 第一个shell脚本打开文本编译器（可以使用vi/vim命令来创建文件），新建一个文件test.sh，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好 12#!/bin/bashecho "Hello Shell" #! 是一个约定的标记, 他告诉系统这个脚本需要什么解释器来执行, 即使用哪一种Shell echo 命令用于向chuangko输出文本 1.3 如何运行shell脚本1.3.1 作为可执行程序将上面的代码保存为 test.sh，并 cd 到相应目录： 12chmod +x ./test.sh #使脚本具有执行权限./test.sh #执行脚本 注意，一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。 1.3.2 作为解释器参数这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如： 12/bin/sh test.sh/bin/php test.php 这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。 二、shell变量2.1 shell变量的规则1your_name="holicCode.com" 注意，变量名和等号之间不能有空格。 同时，变量名的命名须遵循如下规则： 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。 2.2 变量的类型运行shell时，会同时存在三种变量： 1) 局部变量 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。 2) 环境变量 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。 3) shell变量 shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行 2.3 shell变量的使用使用一个定义过的变量，只要在变量名前面加美元符号即可： 123your_name="holicCode.com"echo $your_nameecho $&#123;your_name&#125; 变量名外面的花括号是可选的，加不加都行，加话括号是为了帮助解释器识别变量的边界 2.4 设置只读变量使用readonly命令可以将变量定义为只读变量，只读变量的值不能被改变。 123#!/bin/bashmyUrl="https://holicCode.github.io"readonly myUrl 2.5 删除变量使用unset命令可以删除变量 1unset your_name 变量被删除后不能再次使用；unset命令不能删除只读变量 三、shell字符串字符串是shell编程中最常用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号 3.1 单引号1str='this is a string' 单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。 3.2 双引号123your_name='holicCode'str="Hello, I know you are \"$your_name\"! \n"echo -e $str 输出结果为： 1Hello, I know you are "holicCode"! 双引号的优点： 双引号里可以有变量 双引号里可以出现转义字符 3.3 拼接字符串123456789your_name="holicCode"# 使用双引号拼接greeting="hello, "$your_name" !"greeting_1="hello, $&#123;your_name&#125; !"echo $greeting $greeting_1# 使用单引号拼接greeting_2='hello, '$your_name' !'greeting_3='hello, $&#123;your_name&#125; !'echo $greeting_2 $greeting_3 输出结果为： 12hello, holicCode ! hello, holicCode !hello, holicCode ! hello, $&#123;your_name&#125; ! 3.4 获取字符串长度12string="abcd"echo $&#123;#string&#125; #输出 4 3.5 提取子字符串以下实例从字符串第 2 个字符开始截取 4 个字符： 12string="holicCode is a great site"echo $&#123;string:1:4&#125; # 输出 olic 3.6 查找子字符串查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)： 12string="holicCode is a great site"echo `expr index "$string" io` # 输出 2 三、shell基本运算符shell编程支持 算数运算符 关系运算符 布尔运算符 字符串运算符 文件测试运算符 四、shell的流程控制4.1 if条件语句if else-if else if else-if else 语法格式： 123456789if condition1then command1elif condition2 then command2else commandNfi 4.2 for循环1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone 4.3 while语句1234while conditiondo commanddone 4.4 无限循环1234while :do commanddone 或者 1234while truedo commanddone 或者 1for (( ; ; )) 五、shell函数linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。 shell中函数的定义格式如下： 123456789[ function ] funname [()]&#123; action; [return int;]&#125; 说明： 1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。 2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255）]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB相关知识]]></title>
    <url>%2F2019%2F08%2F14%2FMongoDB%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1本文参考自：https://github.com/0voice/interview_internal_reference/tree/master/11.MongoDB%E7%AF%87 一、MongoDB的基本概念？1.1 什么是MongoDB？MongoDB是一个文档数据库，提供好的性能，领先的非关系型数据库 1.2 MongoDB是由哪种语言写的？MongoDB用 C++ 编写 1.3 MongoDB有哪些优势？面向文档的存储：以JSON格式的文档保存数据 任何属性都可以建立索引 复制以及高可扩展性 自动分片 丰富的查询功能 快速的即时更新 1.4 什么是 mongod？mongod是处理MongoDB系统的主要进程。它处理数据请求，管理数据存储，和执行后台管理操作。当我们运行mongod命令意味着正在启动MongoDB进程,并且在后台运行。 1.5 为什么用MongoDB？ 架构简单 没有复杂的连接 深度查询能力,MongoDB支持动态查询。 容易调试 容易扩展 不需要转化/映射应用对象到数据库对象 使用内部内存作为存储工作区,以便更快的存取数据。 1.6 MongoDB支持的数据类型？String；Integer；Boolean；Double；Min/Max keys；Array；Timestamp；Object；Null；Symbol；Date；Object ID；Binary Data；Code；Regular expression 二、MongoDB复制（副本集）12345MongoDB复制是将数据同步在多个服务器的过程。复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。复制还允许您从硬件故障和服务中断中恢复数据。 2.1 MongoDB复制有什么好处? 保障数据的安全性 数据高可用性 (24*7) 灾难恢复 无需停机维护（如备份，重建索引，压缩） 分布式读取数据 2.2 MongoDB复制原理?mongodb的复制至少需要两个节点。其中一个主节点，负责处理客户端请求，其余的都是从节点，负责复制主节点上的数据； mongodb各个节点常见的搭配方式为：一主一从、一主多从； 主节点记录在其上所有操作oplog，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证节点的数据与节点一致； 客户端从主节点读取数据，在客户端写入数据到主节点时，主节点与从节点进行数据交互保障数据的一致性 2.3 副本集的特征？ N 个节点的集群 任何节点可作为主节点 所有写入操作都在主节点上 自动故障转移 自动恢复 三、MongoDB分片123在Mongodb里面存在另一种集群，就是分片技术,可以满足MongoDB数据量大量增长的需求。当MongoDB存储海量的数据时，一台机器可能不足以存储数据，也可能不足以提供可接受的读写吞吐量。这时，我们就可以通过在多台机器上分割数据，使得数据库系统能存储和处理更多的数据。 3.1 为什么使用分片？ 复制所有的写入操作到主节点 延迟的敏感数据会在主节点查询 单个副本集限制在12个节点 当请求量巨大时会出现内存不足。 本地磁盘不足 垂直扩展价格昂贵 四、MongoDB备份（mongodump）与恢复（mongorestore）4.1 数据的备份 mongodump -h dbhost -d dbname -o dbdirectory -h： MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017 -d： 需要备份的数据库实例，例如：test -o： 备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。 4.2 数据恢复 mongorestore -h &lt;:port&gt; -d dbname –host &lt;:port&gt;, -h &lt;:port&gt;： MongoDB所在服务器地址，默认为： localhost:27017 –db , -d ： 需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2 –drop： 恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！ ： mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\data\dump\test。 你不能同时指定 和 –dir 选项，–dir也可以设置备份目录。 –dir： 指定备份的目录 你不能同时指定 和 –dir 选项。 五、MongoDB Java123456789101112131415161718import com.mongodb.MongoClient;import com.mongodb.client.MongoDatabase;public class MongoDBJDBC&#123; public static void main( String args[] )&#123; try&#123; // 连接到 mongodb 服务 MongoClient mongoClient = new MongoClient( "localhost" , 27017 ); // 连接到数据库 MongoDatabase mongoDatabase = mongoClient.getDatabase("mycol"); System.out.println("Connect to database successfully"); &#125;catch(Exception e)&#123; System.err.println( e.getClass().getName() + ": " + e.getMessage() ); &#125; &#125;&#125;]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的相关知识]]></title>
    <url>%2F2019%2F08%2F10%2FLinux%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[一、Linux的目录结构 二、Linux的常用命令2.1 切换目录命令【cd】123456使用 cd app 切换到app目录 cd .. 切换到上一层目录 cd / 切换到系统根目录 cd ~ 切换到用户主目录 cd - 切换到上一个所在目录 2.2 列出文件列表【ls、ll、dir】12345678ls(list)是一个非常有用的命令，用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容。 格式：ls[参数] [路径或文件名]常用：在linux中以 . 开头的文件都是隐藏的文件* ls* ls -a 显示所有文件或目录（包含隐藏的文件）* ls -l 缩写成ll 2.3 创建目录和移除目录【mkdir、rmdir】123456mkdir(make directory)命令可用来创建子目录。 mkdir app 在当前目录下创建app目录 mkdir –p app2/test 级联创建aap2以及test目录rmdir(remove directory)命令可用来删除“空”的子目录： rmdir app 删除app目录 2.4 浏览文件【cat、more、less、tail】123456789101112131415161718192021cat 用于显示文件的内容。 格式：cat[参数]&lt;文件名&gt; * cat yum.conf more 一般用于要显示的内容会超过一个画面长度的情况。按空格键显示下一个画面。 回车显示下一行内容。 按 q 键退出查看。 * more yum.conf * 空格显示下一页数据 回车显示下一行的数据 less 用法和more类似，不同的是less可以通过PgUp、PgDn键来控制。 * less yum.conf * PgUp 和 PgDn 进行上下翻页.tail 命令是在实际使用过程中使用非常多的一个命令，它的功能是：用于显示文件后几行的内容。 用法: tail -10 /etc/passwd 查看后10行数据 tail -f catalina.log 动态查看日志(*****) ctrl+c 结束查看 2.5 文件操作【rm】123456789101112rm 删除文件 用法：rm [选项]... 文件... rm a.txt  删除a.txt文件 删除需要用户确认，y/n rm 删除不询问 rm -f a.txt 不询问，直接删除 rm 删除目录 rm -r a 递归删除 不询问递归删除（慎用） rm -rf a 不询问递归删除 rm -rf * 删除所有文件 rm -rf /* 自杀 【cp、mv】1234567cp(copy)命令可以将文件从一处复制到另一处。一般在使用cp命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。 cp a.txt b.txt 将a.txt复制为b.txt文件 cp a.txt ../ 将a.txt文件复制到上一层目录中 mv 移动或者重命名 mv a.txt ../ 将a.txt文件移动到上一层目录中 mv a.txt b.txt 将a.txt文件重命名为b.txt 【tar】1234567891011121314151617tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。 常用参数： -c：创建一个新tar文件 -v：显示运行过程的信息 -f：指定文件名 -z：调用gzip压缩命令进行压缩 -t：查看压缩文件的内容 -x：解开tar文件 打包： tar –cvf xxx.tar ./*打包并且压缩： tar –zcvf xxx.tar.gz ./* 解压 tar –xvf xxx.tar tar -xvf xxx.tar.gz -C /usr/aaa 【grep】12345查找符合条件的字符串。用法: grep [选项]... PATTERN [FILE]... 示例： grep lang anaconda-ks.cfg 在文件中查找lang grep lang anaconda-ks.cfg –color 高亮显示 2.6 其他常用命令【pwd】 显示当前所在目录 【touch】 创建一个空文件 ​ touch a.txt 【ll -h】 友好显示文件大小 【wget】 下载资料 ​ wget 资料的url 三、Vi和Vim编译器3.1 Vim编译器在Linux下一般使用vi编辑器来编辑文件。 vi既可以查看文件也可以编辑文件。 三种模式：命令行、插入、底行模式。 切换到命令行模式：按Esc键； 切换到插入模式：按 i 、o、a键； ​ i 在当前位置生前插入 ​ I 在当前行首插入 ​ a 在当前位置后插入 ​ A 在当前行尾插入 ​ o 在当前行之后插入一行 ​ O 在当前行之前插入一行 切换到底行模式：按 :（冒号）； 更多详细用法，查询文档《Vim命令合集.docx》和《vi使用方法详细介绍.docx》 打开文件：vim file 退出：esc à :q 修改文件：输入i进入插入模式 保存并退出：esc——&gt;wq 不保存退出：esc——&gt;q! 3中进入插入模式： ​ i:在当前的光标所在处插入 ​ o:在当前光标所在的行的下一行插入 ​ a:在光标所在的下一个字符插入 快捷键： ​ dd – 快速删除一行 ​ R – 替换 3.2 重定向输出 &gt; 和 &gt;&gt;&gt; 重定向输出，覆盖原有内容； &gt;&gt; 重定向输出，又追加功能； 示例： ​ cat /etc/passwd &gt; a.txt 将输出定向到a.txt中 ​ cat /etc/passwd &gt;&gt; a.txt 输出并且追加 ​ ifconfig &gt; ifconfig.txt 3.3 管道管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。 示例 ​ ls –help | more 分页查询帮助信息 ​ ps –ef | grep java 查询名称中包含java的进程 ​ ifconfig | more ​ cat index.html | more ​ ps –ef | grep aio 3.4 &amp;&amp;命令执行控制命令之间使用 &amp;&amp; 连接，实现逻辑与的功能。 ​ 只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才会被执行。 ​ 只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。 mkdir test &amp;&amp; cd test3.5 网络通讯命令ifconfig 显示或设置网络设备。 ifconfig 显示网络设备 ifconfig eth0 up 启用eth0网卡 ifconfig eth0 down 停用eth0网卡 ping 探测网络是否通畅。 ping 192.168.0.1 netstat 查看网络端口。 netstat -an | grep 3306 查询3306端口占用情况 3.6 系统管理命令date 显示或设置系统时间 ​ date 显示当前系统时间 ​ date -s “2014-01-01 10:10:10“ 设置系统时间 df 显示磁盘信息 ​ df –h 友好显示大小 free 显示内存状态 ​ free –m 以mb单位显示内存组昂头 top 显示，管理执行中的程序 clear 清屏幕 ps 正在运行的某个进程的状态 ​ ps –ef 查看所有进程 ​ ps –ef | grep ssh 查找某一进程 kill 杀掉某一进程 ​ kill 2868 杀掉2868编号的进程 ​ kill -9 2868 强制杀死进程 du 显示目录或文件的大小。 ​ du –h 显示当前目录的大小 who 显示目前登入系统的用户信息。 hostname 查看当前主机名 修改：vi /etc/sysconfig/network uname 显示系统信息。 ​ uname -a 显示本机详细信息。 依次为：内核名称(类别)，主机名，内核版本号，内核版本，内核编译日期，硬件名，处理器类型，硬件平台类型，操作系统名称 四、Linux的权限命令4.1 Linux的三种文件类型普通文件： 包括文本文件、数据文件、可执行的二进制程序文件等。 目录文件： Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。 设备文件： Linux系统把每一个设备都看成是一个文件 4.2 文件类型标识普通文件（-） 目录（d） 符号链接（l） * 进入etc可以查看，相当于快捷方式 字符设备文件（c） 块设备文件（s） 套接字（s） 命名管道（p） 4.3 文件权限管理chmod 变更文件或目录的权限。 ​ chmod 755 a.txt ​ chmod u=rwx,g=rx,o=rx a.txt ​ chmod 000 a.txt / chmod 777 a.txt chown 变更文件或目录改文件所属用户和组 ​ chown u1:public a.txt ：变更当前的目录或文件的所属用户和组 ​ chown -R u1:public dir ：变更目录中的所有的子目录及文件的所属用户和组 五、Linux面试有关知识5.1 如何避免开发过程中Linux和Windows下路径拼接不一致问题？1统一使用File.separator 5.2 buffer和cache如何区分？12CPU写数据到磁盘时，磁盘速度比较慢，所以CPU先把数据存进buffer，然后CPU去执行其他任务，buffer中的数据会定期写入磁盘。CPU从磁盘读入数据时，由于磁盘速度比较慢，把即将用到的数据提前存入cache，CPU直接从cache中拿数据要快的多。 5.3 自定义解析域名的时候，我们可以编辑哪个文件？是否可以一个ip对应多个域名？是否可以一个域名对用多个ip？123编辑 /etc/hosts；可以一个ip对应多个域名；不可以一个域名对应多个ip。 5.4 DHCP12DHCP是动态主机配置协议的简称作用：为网络中的主机分配IP地址 未完，待补充……]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML&CSS&jQuery]]></title>
    <url>%2F2019%2F08%2F08%2FHTML%26CSS%26jQuery%2F</url>
    <content type="text"><![CDATA[一、HTML1. 概念是最基础的网页开发语言 * Hyper Text Markup Language 超文本标记语言 * 超文本: * 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本. * 标记语言: * 由标签构成的语言。&lt;标签名称&gt; 如 html，xml * 标记语言不是编程语言 2. 快速入门 语法： 1. html文档后缀名 .html 或者 .htm 2. 标签分为 1. 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt; 2. 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt; 3. 标签可以嵌套： 需要正确嵌套，不能你中有我，我中有你 错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt; 正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt; 4. 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来 5. html的标签不区分大小写，但是建议使用小写。 代码： 12345678910111213&lt;html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;FONT color='red'&gt;Hello World&lt;/font&gt;&lt;br/&gt; &lt;font color='green'&gt;Hello World&lt;/font&gt; &lt;/body&gt;&lt;/html&gt; 3. 标签12345678910111213141516171819202122232425262728293031323334353637381. 文件标签：构成html最基本的标签 * html:html文档的根标签 * head：头标签。用于指定html文档的一些属性。引入外部的资源 * title：标题标签。 * body：体标签 * &lt;!DOCTYPE html&gt;：html5中定义该文档是html文档2. 文本标签：和文本有关的标签 * 注释：&lt;!-- 注释内容 --&gt; * &lt;h1&gt; to &lt;h6&gt;：标题标签 * h1~h6:字体大小逐渐递减 * &lt;p&gt;：段落标签 * &lt;br&gt;：换行标签 * &lt;hr&gt;：展示一条水平线 * 属性： * color：颜色 * width：宽度 * size：高度 * align：对其方式 * center：居中 * left：左对齐 * right：右对齐 * &lt;b&gt;：字体加粗 * &lt;i&gt;：字体斜体 * &lt;font&gt;:字体标签 * &lt;center&gt;:文本居中 * 属性： * color：颜色 * size：大小 * face：字体 * 属性定义： * color： 1. 英文单词：red,green,blue 2. rgb(值1，值2，值3)：值的范围：0~255 如 rgb(0,0,255) 3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF * width： 1. 数值：width='20' ,数值的单位，默认是 px(像素) 2. 数值%：占比相对于父元素的比例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677783. 图片标签： * img：展示图片 * 属性： * src：指定图片的位置 * 代码： &lt;!--展示一张图片 img--&gt; &lt;img src="image/jingxuan_2.jpg" align="right" alt="古镇" width="500" height="500"/&gt; &lt;!-- 相对路径 * 以.开头的路径 * ./：代表当前目录 ./image/1.jpg * ../:代表上一级目录 --&gt; &lt;img src="./image/jiangwai_1.jpg"&gt; &lt;img src="../image/jiangwai_1.jpg"&gt; 4. 列表标签： * 有序列表： * ol: * li: * 无序列表： * ul: * li: 5. 链接标签： * a:定义一个超链接 * 属性： * href：指定访问资源的URL(统一资源定位符) * target：指定打开资源的方式 * _self:默认值，在当前页面打开 * _blank：在空白页面打开 * 代码： &lt;!--超链接 a--&gt; &lt;a href="http://www.itcast.cn"&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href="http://www.itcast.cn" target="_self"&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href="http://www.itcast.cn" target="_blank"&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href="./5_列表标签.html"&gt;列表标签&lt;/a&gt;&lt;br&gt; &lt;a href="mailto:itcast@itcast.cn"&gt;联系我们&lt;/a&gt; &lt;br&gt; &lt;a href="http://www.itcast.cn"&gt;&lt;img src="image/jiangwai_1.jpg"&gt;&lt;/a&gt; 6. div和span： * div:每一个div占满一整行。块级标签 * span：文本信息在一行展示，行内标签 内联标签 7. 语义化标签：html5中为了提高程序的可读性，提供了一些标签。 1. &lt;header&gt;：页眉 2. &lt;footer&gt;：页脚 8. 表格标签： * table：定义表格 * width：宽度 * border：边框 * cellpadding：定义内容和单元格的距离 * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、 * bgcolor：背景色 * align：对齐方式 * tr：定义行 * bgcolor：背景色 * align：对齐方式 * td：定义单元格 * colspan：合并列 * rowspan：合并行 * th：定义表头单元格 * &lt;caption&gt;：表格标题 * &lt;thead&gt;：表示表格的头部分 * &lt;tbody&gt;：表示表格的体部分 * &lt;tfoot&gt;：表示表格的脚部分 二、CSS：页面美化和布局控制1234567891. 概念： Cascading Style Sheets 层叠样式表 * 层叠：多个样式可以作用在同一个html的元素上，同时生效2. 好处： 1. 功能强大 2. 将内容展示和样式控制分离 * 降低耦合度。解耦 * 让分工协作更容易 * 提高开发效率 12345678910111213141516171819202122232425262728293031323334353637383940414243443. CSS的使用：CSS与html结合方式 1. 内联样式 * 在标签内使用style属性指定css代码 * 如：&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt; 2. 内部样式 * 在head标签内，定义style标签，style标签的标签体内容就是css代码 * 如： &lt;style&gt; div&#123; color:blue; &#125; &lt;/style&gt; &lt;div&gt;hello css&lt;/div&gt; 3. 外部样式 1. 定义css资源文件。 2. 在head标签内，定义link标签，引入外部的资源文件 * 如： * a.css文件： div&#123; color:green; &#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt; &lt;div&gt;hello css&lt;/div&gt; &lt;div&gt;hello css&lt;/div&gt; * 注意： * 1,2,3种方式 css作用范围越来越大 * 1方式不常用，后期常用2,3 * 3种格式可以写为： &lt;style&gt; @import &quot;css/a.css&quot;; &lt;/style&gt;4. css语法： * 格式： 选择器 &#123; 属性名1:属性值1; 属性名2:属性值2; ... &#125; * 选择器:筛选具有相似特征的元素 * 注意： * 每一对属性需要使用；隔开，最后一对属性可以不加； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555. 选择器：筛选具有相似特征的元素 * 分类： 1. 基础选择器 1. id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一 * 语法：#id属性值&#123;&#125; 2. 元素选择器：选择具有相同标签名称的元素 * 语法： 标签名称&#123;&#125; * 注意：id选择器优先级高于元素选择器 3. 类选择器：选择具有相同的class属性值的元素。 * 语法：.class属性值&#123;&#125; * 注意：类选择器选择器优先级高于元素选择器 2. 扩展选择器： 1. 选择所有元素： * 语法： *&#123;&#125; 2. 并集选择器： * 选择器1,选择器2&#123;&#125; 3. 子选择器：筛选选择器1元素下的选择器2元素 * 语法： 选择器1 选择器2&#123;&#125; 4. 父选择器：筛选选择器2的父元素选择器1 * 语法： 选择器1 &gt; 选择器2&#123;&#125; 5. 属性选择器：选择元素名称，属性名=属性值的元素 * 语法： 元素名称[属性名=&quot;属性值&quot;]&#123;&#125; 6. 伪类选择器：选择一些元素具有的状态 * 语法： 元素:状态&#123;&#125; * 如： &lt;a&gt; * 状态： * link：初始化的状态 * visited：被访问过的状态 * active：正在访问状态 * hover：鼠标悬浮状态6. 属性 1. 字体、文本 * font-size：字体大小 * color：文本颜色 * text-align：对其方式 * line-height：行高 2. 背景 * background： 3. 边框 * border：设置边框，符合属性 4. 尺寸 * width：宽度 * height：高度 5. 盒子模型：控制布局 * margin：外边距 * padding：内边距 * 默认情况下内边距会影响整个盒子的大小 * box-sizing: border-box; 设置盒子的属性，让width和height就是最终盒子的大小 * float：浮动 * left * right 三、jQuery1. jQuery基础1234567891011121314151617181920212223241. 概念： 一个JavaScript框架。简化JS开发 * jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨 是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优 化HTML文档操作、事件处理、动画设计和Ajax交互。 * JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已2. 快速入门 1. 步骤： 1. 下载JQuery * 目前jQuery有三个大版本： 1.x：兼容ie678,使用最为广泛的，官方只做BUG维护， 功能不再新增。因此一般项目来说，使用1.x版本就可以了， 最终版本：1.12.4 (2016年5月20日) 2.x：不兼容ie678，很少有人使用，官方只做BUG维护， 功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x， 最终版本：2.2.4 (2016年5月20日) 3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求， 一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。 目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日） * jquery-xxx.js 与 jquery-xxx.min.js区别： 1. jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些 2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快 2. 导入JQuery的js文件：导入min.js文件 3. 使用 var div1 = $(&quot;#div1&quot;); 1234563. JQuery对象和JS对象区别与转换 1. JQuery对象在操作时，更加方便。 2. JQuery对象和js对象方法不通用的. 3. 两者相互转换 * jq -- &gt; js : jq对象[索引] 或者 jq对象.get(索引) * js -- &gt; jq : $(js对象) 1234567891011121314151617184. 选择器：筛选具有相似特征的元素(标签) 1. 基本操作学习： 1. 事件绑定 //1.获取b1按钮 $(&quot;#b1&quot;).click(function()&#123; alert(&quot;abc&quot;); &#125;); 2. 入口函数 $(function () &#123; &#125;); window.onload 和 $(function) 区别 * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉 * $(function)可以定义多次的。 3. 样式控制：css方法 // $(&quot;#div1&quot;).css(&quot;background-color&quot;,&quot;red&quot;); $(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 2. 分类 1. 基本选择器 1. 标签选择器（元素选择器） * 语法： $(&quot;html标签名&quot;) 获得所有匹配标签名称的元素 2. id选择器 * 语法： $(&quot;#id的属性值&quot;) 获得与指定id属性值匹配的元素 3. 类选择器 * 语法： $(&quot;.class的属性值&quot;) 获得与指定的class属性值匹配的元素 4. 并集选择器： * 语法： $(&quot;选择器1,选择器2....&quot;) 获取多个选择器选中的所有元素 2. 层级选择器 1. 后代选择器 * 语法： $(&quot;A B &quot;) 选择A元素内部的所有B元素 2. 子选择器 * 语法： $(&quot;A &gt; B&quot;) 选择A元素内部的所有B子元素 3. 属性选择器 1. 属性名称选择器 * 语法： $(&quot;A[属性名]&quot;) 包含指定属性的选择器 2. 属性选择器 * 语法： $(&quot;A[属性名=&apos;值&apos;]&quot;) 包含指定属性等于指定值的选择器 3. 复合属性选择器 * 语法： $(&quot;A[属性名=&apos;值&apos;][]...&quot;) 包含多个属性条件的选择器 4. 过滤选择器 1. 首元素选择器 * 语法： :first 获得选择的元素中的第一个元素 2. 尾元素选择器 * 语法： :last 获得选择的元素中的最后一个元素 3. 非元素选择器 * 语法： :not(selector) 不包括指定内容的元素 4. 偶数选择器 * 语法： :even 偶数，从 0 开始计数 5. 奇数选择器 * 语法： :odd 奇数，从 0 开始计数 6. 等于索引选择器 * 语法： :eq(index) 指定索引元素 7. 大于索引选择器 * 语法： :gt(index) 大于指定索引元素 8. 小于索引选择器 * 语法： :lt(index) 小于指定索引元素 9. 标题选择器 * 语法： :header 获得标题（h1~h6）元素，固定写法 5. 表单过滤选择器 1. 可用元素选择器 * 语法： :enabled 获得可用元素 2. 不可用元素选择器 * 语法： :disabled 获得不可用元素 3. 选中选择器 * 语法： :checked 获得单选/复选框选中的元素 4. 选中选择器 * 语法： :selected 获得下拉框选中的元素5. DOM操作 1. 内容操作 1. html(): 获取/设置元素的标签体内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; &lt;font&gt;内容&lt;/font&gt; 2. text(): 获取/设置元素的标签体纯文本内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容 3. val()： 获取/设置元素的value属性值 2. 属性操作 1. 通用属性操作 1. attr(): 获取/设置元素的属性 2. removeAttr():删除属性 3. prop():获取/设置元素的属性 4. removeProp():删除属性 * attr和prop区别？ 1. 如果操作的是元素的固有属性，则建议使用prop 2. 如果操作的是元素自定义的属性，则建议使用attr 2. 对class属性操作 1. addClass():添加class属性值 2. removeClass():删除class属性值 3. toggleClass():切换class属性 * toggleClass(&quot;one&quot;): * 判断如果元素对象上存在class=&quot;one&quot;，则将属性值one删除掉。 如果元素对象上不存在class=&quot;one&quot;，则添加 4. css(): 3. CRUD操作: 1. append():父元素将子元素追加到末尾 * 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾 2. prepend():父元素将子元素追加到开头 * 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头 3. appendTo(): * 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾 4. prependTo()： * 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头 123456789101112135. after():添加元素到元素后边 * 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系6. before():添加元素到元素前边 * 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系7. insertAfter() * 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系8. insertBefore() * 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系9. remove():移除元素 * 对象.remove():将对象删除掉10. empty():清空元素的所有后代元素。 * 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点 2. jQuery高级12345678910111213141516171819202122231. 动画 1. 三种方式显示和隐藏元素 1. 默认显示和隐藏方式 1. show([speed,[easing],[fn]]) 1. 参数： 1. speed：动画的速度。三个预定义的值(&quot;slow&quot;,&quot;normal&quot;, &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000) 2. easing：用来指定切换效果，默认是&quot;swing&quot;，可用参数&quot;linear&quot; * swing：动画执行时效果是 先慢，中间快，最后又慢 * linear：动画执行时速度是匀速的 3. fn：在动画完成时执行的函数，每个元素执行一次。 2. hide([speed,[easing],[fn]]) 3. toggle([speed],[easing],[fn]) 2. 滑动显示和隐藏方式 1. slideDown([speed],[easing],[fn]) 2. slideUp([speed,[easing],[fn]]) 3. slideToggle([speed],[easing],[fn]) 3. 淡入淡出显示和隐藏方式 1. fadeIn([speed],[easing],[fn]) 2. fadeOut([speed],[easing],[fn]) 3. fadeToggle([speed,[easing],[fn]]) 1234567891011121314151617181920212223242526272829303132332. 遍历 1. js的遍历方式 * for(初始化值;循环结束条件;步长) 2. jq的遍历方式 1. jq对象.each(callback) 1. 语法： jquery对象.each(function(index,element)&#123;&#125;); * index:就是元素在集合中的索引 * element：就是集合中的每一个元素对象 * this：集合中的每一个元素对象 2. 回调函数返回值： * true:如果当前function返回为false，则结束循环(break)。 * false:如果当前function返回为true，则结束本次循环，继续下次循环(continue) 2. $.each(object, [callback]) 3. for..of: jquery 3.0 版本之后提供的方式 for(元素对象 of 容器对象) 3. 事件绑定 1. jquery标准的绑定方式 * jq对象.事件方法(回调函数)； * 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。 * 表单对象.submit();//让表单提交 2. on绑定事件/off解除绑定 * jq对象.on(&quot;事件名称&quot;,回调函数) * jq对象.off(&quot;事件名称&quot;) * 如果off方法不传递任何参数，则将组件上的所有事件全部解绑 3. 事件切换：toggle * jq对象.toggle(fn1,fn2...) * 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2..... * 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。 &lt;script src=&quot;../js/jquery-migrate-1.0.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424. 案例 1. 广告显示和隐藏 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;广告的自动显示与隐藏&lt;/title&gt; &lt;style&gt; #content&#123;width:100%;height:500px;background:#999&#125; &lt;/style&gt; &lt;!--引入jquery--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; /* 需求： 1. 当页面加载完，3秒后。自动显示广告 2. 广告显示5秒后，自动消失。 分析： 1. 使用定时器来完成。setTimeout (执行一次定时器) 2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display 3. 使用 show/hide方法来完成广告的显示 */ //入口函数，在页面加载完成之后，定义定时器，调用这两个方法 $(function () &#123; //定义定时器，调用adShow方法 3秒后执行一次 setTimeout(adShow,3000); //定义定时器，调用adHide方法，8秒后执行一次 setTimeout(adHide,8000); &#125;); //显示广告 function adShow() &#123; //获取广告div，调用显示方法 $(&quot;#ad&quot;).show(&quot;slow&quot;); &#125; //隐藏广告 function adHide() &#123; //获取广告div，调用隐藏方法 $(&quot;#ad&quot;).hide(&quot;slow&quot;); &#125; 1234567891011121314151617 &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 整体的DIV --&gt;&lt;div&gt; &lt;!-- 广告DIV --&gt; &lt;div id=&quot;ad&quot; style=&quot;display: none;&quot;&gt; &lt;img style=&quot;width:100%&quot; src=&quot;../img/adv.jpg&quot; /&gt; &lt;/div&gt; &lt;!-- 下方正文部分 --&gt; &lt;div id=&quot;content&quot;&gt; 正文部分 &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516172. 抽奖 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;jquery案例之抽奖&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script language=&apos;javascript&apos; type=&apos;text/javascript&apos;&gt; /* 分析： 1. 给开始按钮绑定单击事件 1.1 定义循环定时器 1.2 切换小相框的src属性 * 定义数组，存放图片资源路径 * 生成随机数。数组索引 12345678910111213141516171819 2. 给结束按钮绑定单击事件 1.1 停止定时器 1.2 给大相框设置src属性 */var imgs = [&quot;../img/man00.jpg&quot;, &quot;../img/man01.jpg&quot;, &quot;../img/man02.jpg&quot;, &quot;../img/man03.jpg&quot;, &quot;../img/man04.jpg&quot;, &quot;../img/man05.jpg&quot;, &quot;../img/man06.jpg&quot;, ];var startId;//开始定时器的idvar index;//随机角标$(function () &#123; //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true); 1234567//1. 给开始按钮绑定单击事件 $(&quot;#startID&quot;).click(function () &#123; // 1.1 定义循环定时器 20毫秒执行一次 startId = setInterval(function () &#123; //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,true); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,false); 1234567 //1.2生成随机角标 0-6 index = Math.floor(Math.random() * 7);//0.000--0.999 --&gt; * 7 --&gt; 0.0-----6.9999 //1.3设置小相框的src属性 $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]); &#125;,20);&#125;); 12345//2. 给结束按钮绑定单击事件$(&quot;#stopID&quot;).click(function () &#123; //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true); 12345678 // 1.1 停止定时器 clearInterval(startId); // 1.2 给大相框设置src属性 $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]).hide(); //显示1秒之后 $(&quot;#img2ID&quot;).show(1000); &#125;);&#125;); 1234567891011121314151617181920212223242526272829 &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 小像框 --&gt;&lt;div style=&quot;border-style:dotted;width:160px;height:100px&quot;&gt; &lt;img id=&quot;img1ID&quot; src=&quot;../img/man00.jpg&quot; style=&quot;width:160px;height:100px&quot;/&gt;&lt;/div&gt;&lt;!-- 大像框 --&gt;&lt;div style=&quot;border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px&quot;&gt; &lt;img id=&quot;img2ID&quot; src=&quot;../img/man00.jpg&quot; width=&quot;800px&quot; height=&quot;500px&quot;/&gt;&lt;/div&gt;&lt;!-- 开始按钮 --&gt;&lt;input id=&quot;startID&quot; type=&quot;button&quot; value=&quot;点击开始&quot; style=&quot;width:150px;height:150px;font-size:22px&quot;&gt;&lt;!-- 停止按钮 --&gt;&lt;input id=&quot;stopID&quot; type=&quot;button&quot; value=&quot;点击停止&quot; style=&quot;width:150px;height:150px;font-size:22px&quot;&gt; 123456789 &lt;/body&gt; &lt;/html&gt;5. 插件：增强JQuery的功能 1. 实现方式： 1. $.fn.extend(object) * 增强通过Jquery获取的对象的功能 $(&quot;#id&quot;) 2. $.extend(object) * 增强JQeury对象自身的功能 $/jQuery]]></content>
      <categories>
        <category>HTML&amp;CSS&amp;jQuery</category>
      </categories>
      <tags>
        <tag>HTML&amp;CSS&amp;jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX&JSON]]></title>
    <url>%2F2019%2F08%2F08%2FAJAX%26JSON%2F</url>
    <content type="text"><![CDATA[AJAX：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586871. 概念： ASynchronous JavaScript And XML 异步的JavaScript 和 XML 1. 异步和同步：客户端和服务器端相互通信的基础上 * 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 * 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1] 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 提升用户的体验2. 实现方式： 1. 原生的JS实现方式（了解） //1.创建核心对象 var xmlhttp; if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125; else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; //2. 建立连接 /* 参数： 1. 请求方式：GET、POST * get方式，请求参数在URL后边拼接。send方法为空参 * post方式，请求参数在send方法中定义 2. 请求的URL： 3. 同步或异步请求：true（异步）或 false（同步） */ xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username=tom&quot;,true); //3.发送请求 xmlhttp.send(); //4.接受并处理来自服务器的响应结果 //获取方式 ：xmlhttp.responseText //什么时候获取？当服务器响应成功后再获取 //当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。 xmlhttp.onreadystatechange=function() &#123; //判断readyState就绪状态是否为4，判断status响应状态码是否为200 if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; //获取服务器的响应结果 var responseText = xmlhttp.responseText; alert(responseText); &#125; &#125; 2. JQeury实现方式 1. $.ajax() * 语法：$.ajax(&#123;键值对&#125;); //使用$.ajax()发送异步请求 $.ajax(&#123; url:&quot;ajaxServlet1111&quot; , // 请求路径 type:&quot;POST&quot; , //请求方式 //data: &quot;username=jack&amp;age=23&quot;,//请求参数 data:&#123;&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:23&#125;, success:function (data) &#123; alert(data); &#125;,//响应成功后的回调函数 error:function () &#123; alert(&quot;出错啦...&quot;) &#125;,//表示如果请求响应出现错误，会执行的回调函数 dataType:&quot;text&quot;//设置接受到的响应数据的格式 &#125;); 2. $.get()：发送get请求 * 语法：$.get(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 3. $.post()：发送post请求 * 语法：$.post(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 JSON：123456789101112131415161718192021222324252627282930313233343536371. 概念： JavaScript Object Notation JavaScript对象表示法 Person p = new Person(); p.setName(&quot;张三&quot;); p.setAge(23); p.setGender(&quot;男&quot;); var p = &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;&#125;; * json现在多用于存储和交换文本信息的语法 * 进行数据的传输 * JSON 比 XML 更小、更快，更易解析。2. 语法： 1. 基本规则 * 数据在名称/值对中：json数据是由键值对构成的 * 键用引号(单双都行)引起来，也可以不使用引号 * 值得取值类型： 1. 数字（整数或浮点数） 2. 字符串（在双引号中） 3. 逻辑值（true 或 false） 4. 数组（在方括号中） &#123;&quot;persons&quot;:[&#123;&#125;,&#123;&#125;]&#125; 5. 对象（在花括号中） &#123;&quot;address&quot;:&#123;&quot;province&quot;：&quot;陕西&quot;....&#125;&#125; 6. null * 数据由逗号分隔：多个键值对由逗号分隔 * 花括号保存对象：使用&#123;&#125;定义json 格式 * 方括号保存数组：[] 2. 获取数据: 1. json对象.键名 2. json对象[&quot;键名&quot;] 3. 数组对象[索引] 4. 遍历 //1.定义基本格式 var person = &#123;&quot;name&quot;: &quot;张三&quot;, age: 23, &apos;gender&apos;: true&#125;; var ps = [&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;gender&quot;: false&#125;]; ​​​ 123456789101112131415 //获取person对象中所有的键和值 //for in 循环/* for(var key in person)&#123; //这样的方式获取不行。因为相当于 person.&quot;name&quot; //alert(key + &quot;:&quot; + person.key); alert(key+&quot;:&quot;+person[key]); &#125;*/ //获取ps中的所有值 for (var i = 0; i &lt; ps.length; i++) &#123; var p = ps[i]; for(var key in p)&#123; alert(key+&quot;:&quot;+p[key]); &#125; &#125; 123456789101112131415161718192021222324252627282930313. JSON数据和Java对象的相互转换 * JSON解析器： * 常见的解析器：Jsonlib，Gson，fastjson，jackson 1. JSON转为Java对象 1. 导入jackson的相关jar包 2. 创建Jackson核心对象 ObjectMapper 3. 调用ObjectMapper的相关方法进行转换 1. readValue(json字符串数据,Class) 2. Java对象转换JSON 1. 使用步骤： 1. 导入jackson的相关jar包 2. 创建Jackson核心对象 ObjectMapper 3. 调用ObjectMapper的相关方法进行转换 1. 转换方法： * writeValue(参数1，obj): 参数1： File：将obj对象转换为JSON字符串，并保存到指定的文件中 Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中 OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中 * writeValueAsString(obj):将对象转为json字符串 2. 注解： 1. @JsonIgnore：排除属性。 2. @JsonFormat：属性值得格式化 * @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;) 3. 复杂java对象转换 1. List：数组 2. Map：对象格式一致 案例：12345* 校验用户名是否存在 1. 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案： 1. $.get(type):将最后一个参数type指定为&quot;json&quot; 2. 在服务器端设置MIME类型 response.setContentType(&quot;application/json;charset=utf-8&quot;);]]></content>
      <categories>
        <category>AJAX&amp;JSON</category>
      </categories>
      <tags>
        <tag>AJAX&amp;JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot相关知识]]></title>
    <url>%2F2019%2F08%2F08%2FSpringBoot%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[一、SpringBoot简介1.1 原有Spring优缺点分析1.1.1 Spring的优点分析Spring是java企业版（Java Enterprise Edition，JEE，也称为J2EE）的轻量级替代品。无需开发重量级的Enterprise JavaBean（EJB），Spring为企业级Java开发提供了一种相对简单的方法，通过依赖注入（IoC）和面向切面编程（AOP），用简单的Java对象（Plain Old Java Object，POJO）实现EJB的功能。 1.1.2 Spring的缺点分析虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。一开始，Spring用XML配置，而且是很多XML配置。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。 所有这些配置都代表了开发时的损耗。因为在思考Spring特性配置和解决业务问题之间需要进行思维切换，所以编写配置挤占了编写应用程序逻辑的时间。和所有框架一样，Spring实用，但与此同时它要求的回报也不少。 除此之外，项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。 1.2 SpringBoot的概述1.2.1 SpringBoot解决上述Spring的缺点SpringBoot对上述Spring的缺点进行的改善和优化，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编程中，从而大大提高了开发的效率，一定程度上缩短了项目的周期。 1.2.2 SpringBoot的特点 为基于Spring的开发提供更快的入门体验 开箱即用，没有代码生成，与无需XML配置。同时也可以修改默认值来满足特点的需求 提供了一些大型项目中常见的非功能特性，如嵌入式服务器、安全、指标，健康体侧、外部配置等 SpringBoot不是Spring功能上的增强，而是提供了一种快速使用Spring的方式 1.2.3 SpringBoot的核心功能 起步依赖 起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。 简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。 自动配置 Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的。 二、SpringBoot原理分析2.1 起步依赖原理分析2.1.1 分析spring-boot-starter-parentspring-boot-starter-parent的pom.xml，xml配置如下（只摘抄了部分重点配置）： 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt; spring-boot-starter-dependencies的pom.xml，xml配置如下（只摘抄了部分重点配置）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;properties&gt; &lt;activemq.version&gt;5.15.3&lt;/activemq.version&gt; &lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt; &lt;appengine-sdk.version&gt;1.9.63&lt;/appengine-sdk.version&gt; &lt;artemis.version&gt;2.4.0&lt;/artemis.version&gt; &lt;aspectj.version&gt;1.8.13&lt;/aspectj.version&gt; &lt;assertj.version&gt;3.9.1&lt;/assertj.version&gt; &lt;atomikos.version&gt;4.0.6&lt;/atomikos.version&gt; &lt;bitronix.version&gt;2.1.4&lt;/bitronix.version&gt; &lt;build-helper-maven-plugin.version&gt;3.0.0&lt;/build-helper-maven-plugin.version&gt; &lt;byte-buddy.version&gt;1.7.11&lt;/byte-buddy.version&gt; ... ... ...&lt;/properties&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-test&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; ... ... ... &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt; &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;kotlin.version&#125;&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.jooq&lt;/groupId&gt; &lt;artifactId&gt;jooq-codegen-maven&lt;/artifactId&gt; &lt;version&gt;$&#123;jooq.version&#125;&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;/plugin&gt; ... ... ... &lt;/plugins&gt; &lt;/pluginManagement&gt;&lt;/build&gt; 从上面的spring-boot-starter-dependencies的pom.xml中我们可以发现，一部分坐标的版本、依赖管理、插件管理已经定义好，所以我们的SpringBoot工程继承spring-boot-starter-parent后已经具备版本锁定等配置了。所以起步依赖的作用就是进行依赖的传递。 2.1.2 分析spring-boot-starter-webspring-boot-starter-web的pom.xml，xml配置如下（只摘抄了部分重点配置）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starters&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;name&gt;Spring Boot Web Starter&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.9.Final&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 从上面的spring-boot-starter-web的pom.xml中我们可以发现，spring-boot-starter-web就是将web开发要使用的spring-web、spring-webmvc等坐标进行了“打包”，这样我们的工程只要引入spring-boot-starter-web起步依赖的坐标就可以进行web开发了，同样体现了依赖传递的作用。 2.2 自动配置原理解析按住Ctrl点击查看启动类MySpringBootApplication上的注解@SpringBootApplication 123456@SpringBootApplicationpublic class MySpringBootApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MySpringBootApplication.class); &#125;&#125; 注解@SpringBootApplication的源码 123456789101112131415161718192021@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; /** * Exclude specific auto-configuration classes such that they will never be applied. * @return the classes to exclude */ @AliasFor(annotation = EnableAutoConfiguration.class) Class&lt;?&gt;[] exclude() default &#123;&#125;; ... ... ...&#125; 其中， @SpringBootConfiguration：等同与@Configuration，既标注该类是Spring的一个配置类 @EnableAutoConfiguration：SpringBoot自动配置功能开启 按住Ctrl点击查看注解@EnableAutoConfiguration 123456789@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ... ... ...&#125; 其中，@Import(AutoConfigurationImportSelector.class) 导入了AutoConfigurationImportSelector类 按住Ctrl点击查看AutoConfigurationImportSelector源码 123456789101112131415161718192021public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; ... ... ... List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); configurations = removeDuplicates(configurations); Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = filter(configurations, autoConfigurationMetadata); fireAutoConfigurationImportEvents(configurations, exclusions); return StringUtils.toStringArray(configurations);&#125;protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames( getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); return configurations;&#125; 其中，SpringFactoriesLoader.loadFactoryNames 方法的作用就是从META-INF/spring.factories文件中读取指定类对应的类名称列表 spring.factories 文件中有关自动配置的配置信息如下： 12345678910... ... ...org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\... ... ... 上面配置文件存在大量的以Configuration为结尾的类名称，这些类就是存有自动配置信息的类，而SpringApplication在获取这些类名后再加载 我们以ServletWebServerFactoryAutoConfiguration为例来分析源码： 123456789101112@Configuration@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@ConditionalOnClass(ServletRequest.class)@ConditionalOnWebApplication(type = Type.SERVLET)@EnableConfigurationProperties(ServerProperties.class)@Import(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class, ServletWebServerFactoryConfiguration.EmbeddedTomcat.class, ServletWebServerFactoryConfiguration.EmbeddedJetty.class, ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)public class ServletWebServerFactoryAutoConfiguration &#123; ... ... ...&#125; 其中， @EnableConfigurationProperties(ServerProperties.class) 代表加载ServerProperties服务器配置属性类 进入ServerProperties.class源码如下： 12345678910111213141516@ConfigurationProperties(prefix = "server", ignoreUnknownFields = true)public class ServerProperties &#123; /** * Server HTTP port. */ private Integer port; /** * Network address to which the server should bind. */ private InetAddress address; ... ... ... &#125; 其中， prefix = “server” 表示SpringBoot配置文件中的前缀，SpringBoot会将配置文件中以server开始的属性映射到该类的字段中。映射关系如下： 三、SpringBoot的配置文件3.1 SpringBoot配置文件类型3.1.1 SpringBoot配置文件类型和作用SpringBoot是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用application.properties或者application.yml（application.yaml）进行配置。 SpringBoot默认会从Resources目录下加载application.properties或application.yml（application.yaml）文件 其中，application.properties文件是键值对类型的文件，之前一直在使用，所以此处不在对properties文件的格式进行阐述。除了properties文件外，SpringBoot还可以使用yml文件进行配置，下面对yml文件进行讲解。 3.1.2 application.yml配置文件3.1.2.1 yml配置文件简介YML文件格式是YAML (YAML Aint Markup Language)编写的文件格式，YAML是一种直观的能够被电脑识别的的数据数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，比如： C/C++, Ruby, Python, Java, Perl, C#, PHP等。YML文件是以数据为核心的，比传统的xml方式更加简洁。 YML文件的扩展名可以使用.yml或者.yaml。 3.1.2.2 yml配置文件的语法3.1.2.2.1 配置普通数据 语法： key: value 示例代码： 1name: haohao 注意：value之前有一个空格 3.1.2.2.2 配置对象数据 语法： ​ key: ​ key1: value1 ​ key2: value2 ​ 或者： ​ key: {key1: value1,key2: value2} 示例代码： 12345678person: name: haohao age: 31 addr: beijing#或者person: &#123;name: haohao,age: 31,addr: beijing&#125; 注意：key1前面的空格个数不限定，在yml语法中，相同缩进代表同一个级别 3.1.2.2.2 配置Map数据同上面的对象写法 3.1.2.2.3 配置数组（List、Set）数据 语法： ​ key: ​ - value1 ​ - value2 或者： ​ key: [value1,value2] 示例代码： 123456789101112131415161718192021city: - beijing - tianjin - shanghai - chongqing #或者city: [beijing,tianjin,shanghai,chongqing]#集合中的元素是对象形式student: - name: zhangsan age: 18 score: 100 - name: lisi age: 28 score: 88 - name: wangwu age: 38 score: 90 注意：value1与之间的 - 之间存在一个空格 3.1.3 SpringBoot配置信息的查询上面提及过，SpringBoot的配置文件，主要的目的就是对配置信息进行修改的，但在配置时的key从哪里去查询呢？我们可以查阅SpringBoot的官方文档 文档URL：https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#common-application-properties 常用的配置摘抄如下： 123456789101112131415161718192021222324252627282930313233343536373839# QUARTZ SCHEDULER (QuartzProperties)spring.quartz.jdbc.initialize-schema=embedded # Database schema initialization mode.spring.quartz.jdbc.schema=classpath:org/quartz/impl/jdbcjobstore/tables_@@platform@@.sql # Path to the SQL file to use to initialize the database schema.spring.quartz.job-store-type=memory # Quartz job store type.spring.quartz.properties.*= # Additional Quartz Scheduler properties.# ----------------------------------------# WEB PROPERTIES# ----------------------------------------# EMBEDDED SERVER CONFIGURATION (ServerProperties)server.port=8080 # Server HTTP port.server.servlet.context-path= # Context path of the application.server.servlet.path=/ # Path of the main dispatcher servlet.# HTTP encoding (HttpEncodingProperties)spring.http.encoding.charset=UTF-8 # Charset of HTTP requests and responses. Added to the &quot;Content-Type&quot; header if not set explicitly.# JACKSON (JacksonProperties)spring.jackson.date-format= # Date format string or a fully-qualified date format class name. For instance, `yyyy-MM-dd HH:mm:ss`.# SPRING MVC (WebMvcProperties)spring.mvc.servlet.load-on-startup=-1 # Load on startup priority of the dispatcher servlet.spring.mvc.static-path-pattern=/** # Path pattern used for static resources.spring.mvc.view.prefix= # Spring MVC view prefix.spring.mvc.view.suffix= # Spring MVC view suffix.# DATASOURCE (DataSourceAutoConfiguration &amp; DataSourceProperties)spring.datasource.driver-class-name= # Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.spring.datasource.password= # Login password of the database.spring.datasource.url= # JDBC URL of the database.spring.datasource.username= # Login username of the database.# JEST (Elasticsearch HTTP client) (JestProperties)spring.elasticsearch.jest.password= # Login password.spring.elasticsearch.jest.proxy.host= # Proxy host the HTTP client should use.spring.elasticsearch.jest.proxy.port= # Proxy port the HTTP client should use.spring.elasticsearch.jest.read-timeout=3s # Read timeout.spring.elasticsearch.jest.username= # Login username. 我们可以通过配置application.poperties 或者 application.yml 来修改SpringBoot的默认配置 例如： application.properties文件 12server.port=8888server.servlet.context-path=demo application.yml文件 1234server: port: 8888 servlet: context-path: /demo 3.2 配置文件与配置类的属性映射方式3.2.1 使用注解@Value映射我们可以通过@Value注解将配置文件中的值映射到一个Spring管理的Bean的字段上 例如： application.properties配置如下： 123person: name: zhangsan age: 18 或者，application.yml配置如下： 123person: name: zhangsan age: 18 实体Bean代码如下： 12345678910111213141516@Controllerpublic class QuickStartController &#123; @Value("$&#123;person.name&#125;") private String name; @Value("$&#123;person.age&#125;") private Integer age; @RequestMapping("/quick") @ResponseBody public String quick()&#123; return "springboot 访问成功! name="+name+",age="+age; &#125;&#125; 3.2.2 使用注解@ConfigurationProperties映射通过注解@ConfigurationProperties(prefix=”配置文件中的key的前缀”)可以将配置文件中的配置自动与实体进行映射 application.properties配置如下： 123person: name: zhangsan age: 18 或者，application.yml配置如下： 123person: name: zhangsan age: 18 实体Bean代码如下： 123456789101112131415161718192021@Controller@ConfigurationProperties(prefix = "person")public class QuickStartController &#123; private String name; private Integer age; @RequestMapping("/quick") @ResponseBody public String quick()&#123; return "springboot 访问成功! name="+name+",age="+age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 注意：使用@ConfigurationProperties方式可以进行配置文件与实体字段的自动映射，但需要字段必须提供set方法才可以，而使用@Value注解修饰的字段不需要提供set方法 四、SpringBoot与整合其他技术4.1 SpringBoot整合Mybatis4.1.1 添加Mybatis的起步依赖123456&lt;!--mybatis起步依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt; 4.1.2 添加数据库驱动坐标12345&lt;!-- MySQL连接驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 4.1.3 添加数据库连接信息在application.properties中添加数据量的连接信息 12345#DB Configuration:spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8spring.datasource.username=rootspring.datasource.password=root 4.1.4 创建user表在test数据库中创建user表 1234567891011121314151617-- ------------------------------ Table structure for `user`-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(50) DEFAULT NULL, `password` varchar(50) DEFAULT NULL, `name` varchar(50) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user-- ----------------------------INSERT INTO `user` VALUES ('1', 'zhangsan', '123', '张三');INSERT INTO `user` VALUES ('2', 'lisi', '123', '李四'); 4.1.5 创建实体Bean12345678910111213public class User &#123; // 主键 private Long id; // 用户名 private String username; // 密码 private String password; // 姓名 private String name; //此处省略getter和setter方法 .. .. &#125; 4.1.6 编写Mapper1234@Mapperpublic interface UserMapper &#123; public List&lt;User&gt; queryUserList();&#125; 注意：@Mapper标记该类是一个mybatis的mapper接口，可以被spring boot自动扫描到spring上下文中 4.1.7 配置Mapper映射文件在src\main\resources\mapper路径下加入UserMapper.xml配置文件” 1234567&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.itheima.mapper.UserMapper"&gt; &lt;select id="queryUserList" resultType="user"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 4.1.8 在application.properties中添加mybatis的信息12345#spring集成Mybatis环境#pojo别名扫描包mybatis.type-aliases-package=com.itheima.domain#加载Mybatis映射文件mybatis.mapper-locations=classpath:mapper/*Mapper.xml 4.1.9 编写测试Controller1234567891011121314@Controllerpublic class MapperController &#123; @Autowired private UserMapper userMapper; @RequestMapping("/queryUser") @ResponseBody public List&lt;User&gt; queryUser()&#123; List&lt;User&gt; users = userMapper.queryUserList(); return users; &#125;&#125; 4.2 SpringBoot整合Junit4.2.1 添加Junit的起步依赖123456&lt;!--测试的起步依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 4.2.2 编写测试类123456789101112131415161718192021222324252627package com.holicCode.test;import com.holicCode.MySpringBootApplication;import com.holicCode.domain.User;import com.holicCode.mapper.UserMapper;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.util.List;@RunWith(SpringRunner.class)@SpringBootTest(classes = MySpringBootApplication.class)public class MapperTest &#123; @Autowired private UserMapper userMapper; @Test public void test() &#123; List&lt;User&gt; users = userMapper.queryUserList(); System.out.println(users); &#125;&#125; 其中， SpringRunner继承自SpringJUnit4ClassRunner，使用哪一个Spring提供的测试测试引擎都可以 1public final class SpringRunner extends SpringJUnit4ClassRunner @SpringBootTest的属性指定的是引导类的字节码对象 4.3 SpringBoot整合Spring Data JPA4.3.1 添加Spring Data JPA的起步依赖12345&lt;!-- springBoot JPA的起步依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 4.3.2 添加数据库驱动依赖12345&lt;!-- MySQL连接驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 4.3.3 在application.properties中配置数据库和jpa的相关属性123456789101112#DB Configuration:spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8spring.datasource.username=rootspring.datasource.password=root#JPA Configuration:spring.jpa.database=MySQLspring.jpa.show-sql=truespring.jpa.generate-ddl=truespring.jpa.hibernate.ddl-auto=updatespring.jpa.hibernate.naming_strategy=org.hibernate.cfg.ImprovedNamingStrategy 4.3.4 创建实体配置实体123456789101112131415@Entitypublic class User &#123; // 主键 @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; // 用户名 private String username; // 密码 private String password; // 姓名 private String name; //此处省略setter和getter方法... ...&#125; 4.3.5 编写UserRepository123public interface UserRepository extends JpaRepository&lt;User,Long&gt;&#123; public List&lt;User&gt; findAll();&#125; 4.3.6 编写测试类1234567891011121314@RunWith(SpringRunner.class)@SpringBootTest(classes=MySpringBootApplication.class)public class JpaTest &#123; @Autowired private UserRepository userRepository; @Test public void test()&#123; List&lt;User&gt; users = userRepository.findAll(); System.out.println(users); &#125;&#125; 4.3.7 控制台打印信息注意：如果是jdk9，执行报错如下： 原因：jdk缺少相应的jar 解决方案：手动导入对应的maven坐标，如下： 123456&lt;!--jdk9需要导入如下坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt; 4.4 SpringBoot整合Redis4.4.1 添加redis的起步依赖12345&lt;!-- 配置使用redis启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 4.4.2 配置redis的连接信息123#Redisspring.redis.host=127.0.0.1spring.redis.port=6379 4.4.3 注入RedisTemplate测试redis操作123456789101112131415161718192021222324252627282930313233@RunWith(SpringRunner.class)@SpringBootTest(classes = SpringbootJpaApplication.class)public class RedisTest &#123; @Autowired private UserRepository userRepository; @Autowired private RedisTemplate&lt;String, String&gt; redisTemplate; @Test public void test() throws JsonProcessingException &#123; //从redis缓存中获得指定的数据 String userListData = redisTemplate.boundValueOps("user.findAll").get(); //如果redis中没有数据的话 if(null==userListData)&#123; //查询数据库获得数据 List&lt;User&gt; all = userRepository.findAll(); //转换成json格式字符串 ObjectMapper om = new ObjectMapper(); userListData = om.writeValueAsString(all); //将数据存储到redis中，下次在查询直接从redis中获得数据，不用在查询数据库 redisTemplate.boundValueOps("user.findAll").set(userListData); System.out.println("===============从数据库获得数据==============="); &#125;else&#123; System.out.println("===============从redis缓存中获得数据==============="); &#125; System.out.println(userListData); &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven的相关知识]]></title>
    <url>%2F2019%2F08%2F01%2FMaven%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Maven的使用什么是Maven?1Maven 是一个项目管理工具，它包含了一个项目对象模型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。 Maven的作用Maven的依赖管理1Maven 的一个核心特性就是依赖管理。当我们涉及到多模块的项目（包含成百个模块或者子项目），管理依赖就变成一项困难的任务。Maven 展示出了它对处理这种情形的高度控制。 1maven 工程中不直接将 jar 包导入到工程中，而是通过在 pom.xml 文件中添加所需 jar包的坐标，这样就很好的避免了 jar 直接引入进来，在需要用到 jar 包的时候，只要查找 pom.xml 文件，再通过 pom.xml 文件中的坐标，到一个专门用于”存放 jar 包的仓库”(maven 仓库)中根据坐标从而找到这些 jar 包，再把这些 jar 包拿去运行。 项目的一键构建12什么是构建？指的是项目从编译、测试、运行、打包、安装 ，部署整个过程都交给 maven 进行管理，这个过程称为构建。一键构建指的是整个构建过程，使用 maven 一个命令可以轻松完成整个工作。 1通过 tomcat:run 的这个命令，我们发现现在的工程编译，测试，运行都变得非常简单。 Maven仓库Maven仓库的分类 12345本地仓库 ：用来存储从远程仓库或中央仓库下载的插件和 jar 包，项目使用一些插件或 jar 包，优先从本地仓库查找默认本地仓库位置在 $&#123;user.dir&#125;/.m2/repository，$&#123;user.dir&#125;表示 windows 用户目录。远程仓库：如果本地需要插件或者 jar 包，本地仓库没有，默认去远程仓库下载。远程仓库可以在互联网内也可以在局域网内。中央仓库 ：在 maven 软件中内置一个远程仓库地址 http://repo1.maven.org/maven2 ，它是中央仓库，服务于整个互联网，它是由 Maven 团队自己维护，里面存储了非常全的 jar 包，它包含了世界上大部分流行的开源项目构件。 Maven工程的认识Maven工程的目录结构 1作为一个 maven 工程，它的 src 目录和 pom.xml 是必备的。进入 src 目录后，我们发现它里面的目录结构如下： 1234567src/main/java —— 存放项目的.java 文件src/main/resources —— 存放项目资源文件，如 spring, hibernate 配置文件src/test/java —— 存放所有单元测试.java 文件，如 JUnit 测试类src/test/resources —— 测试资源文件target —— 项目输出位置，编译后的 class 文件会输出到此目录pom.xml——maven 项目核心配置文件注意：如果是普通的 java 项目，那么就没有 webapp 目录。 Maven工程的运行1进入 maven 工程目录（当前目录有 pom.xml 文件），运行 tomcat:run 命令。 Maven常用命令compile1compile 是 maven 工程的编译命令，作用是将 src/main/java 下的文件编译为 class 文件输出到 target目录下。 test1test 是 maven 工程的测试命令 mvn test，会执行 src/test/java 下的单元测试类。 clean1clean 是 maven 工程的清理命令，执行 clean 会删除 target 目录及内容。 package1package 是 maven 工程的打包命令，对于 java 工程执行 package 打成 jar 包，对于 web 工程打成 war包。 install1install 是 maven 工程的安装命令，执行 install 将 maven 打成 jar 包或 war 包发布到本地仓库。 Maven指令的生命周期1234maven 对项目构建过程分为三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，这三套生命周期分别是：Clean Lifecycle 在进行真正的构建之前进行一些清理工作。Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。Site Lifecycle 生成项目报告，站点，发布站点。 pom的基本配置1234567891011pom.xml 是 Maven 项目的核心配置文件，位于每个工程的根目录，基本配置如下：&lt;project &gt; ：文件的根节点 .&lt;modelversion &gt; ： pom.xml 使用的对象模型版本&lt;groupId &gt; ：项目名称，一般写项目的域名&lt;artifactId &gt; ：模块名称，子项目名或模块名称&lt;version &gt; ：产品的版本号 .&lt;packaging &gt; ：打包类型，一般有 jar、war、pom 等&lt;name &gt; ：项目的显示名，常用于 Maven 生成的文档。&lt;description &gt; ：项目描述，常用于 Maven 生成的文档&lt;dependencies&gt; ：项目依赖构件配置，配置项目依赖构件的坐标&lt;build&gt; ：项目构建配置，配置编译、运行插件等。]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有关MySQL的几道必会面试题]]></title>
    <url>%2F2019%2F07%2F27%2F%E6%9C%89%E5%85%B3MySQL%E7%9A%84%E5%87%A0%E9%81%93%E5%BF%85%E4%BC%9A%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[MySQL必会知识点说说你对与MySQL常见的两种存储引擎：MyISAM与InnoDB的理解123456关于二者的对比与总结：1.count运算上的区别：因为MyISAM缓存有表meta-data（行数等），因此在做COUNT（*）时对于一个结构很好的查询时不需要消耗多少资源的。而对于InnoDB来说，则没有这种缓存。2.是否支持事务和崩溃后的安全恢复：MyISAM强调的是性能，每次查询具有原子性，其执行行速度比InnoDB类型更快，但是不支持事务。但是InnoDB提供事务的支持，外键等高级数据库功能。具有事务提交（commit）、回滚（rollback）和崩溃修复能力的事务安全（ACID）型表。3.是否支持外键： MyISAM不支持，而InnoDB支持。MyISAM更适合读密集的表，而InnoDB更适合写密集的表。在数据库做主从分离的情况下，经常选择MyISAM做为主库的存储引擎。一般来说，如果需要事务支持，并且有较高的并发读取频率(MyISAM的表锁的粒度太大，所以当该表写并发量较高时，要等待的查询就会很多了)，InnoDB是不错的选择。如果你的数据量很大（MyISAM支持压缩特性可以减少磁盘的空间占用），而且不需要支持事务时，MyISAM是最好的选择。 为什么要用 ORM? 和 JDBC 有何不一样?12orm是一种思想，就是把object转变成数据库中的记录，或者把数据库中的记录转变成object，我们可以用jdbc来实现这种思想，其实，如果我们的项目是严格按照oop方式编写的话，我们的jdbc程序不管是有意还是无意，就已经在实现orm的工作了。现在有许多orm工具，它们底层调用jdbc来实现了orm工作，我们直接使用这些工具，就省去了直接使用jdbc的繁琐细节，提高了开发效率，现在用的较多的orm工具是hibernate。也听说一些其他orm工具，如toplink,ojb等。 存储过程与触发器的区别？123触发器与存储过程非常相似，触发器也是SQL语句集，两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发（激活）执行。触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。触发器不同于存储过程，触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如UPDATE、INSERT、DELETE这些操作时，SQLSERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。 Mysql如何为表字段添加索引？？？1.添加PRIMARY KEY（主键索引） ALTER TABLE table_name ADD PRIMARY KEY ( column ) 2.添加UNIQUE(唯一索引) ALTER TABLE table_name ADD UNIQUE ( column ) 3.添加INDEX(普通索引) ALTER TABLE table_name ADD INDEX index_name ( column ) 4.添加FULLTEXT(全文索引) ALTER TABLE table_name ADD FULLTEXT ( column) 5.添加多列索引 ALTER TABLE table_name ADD INDEX index_name ( column1, column2, column3 ) 为什么要使用索引?123451.通过创建唯一性索引，可以保证数据库中每一行的数据的唯一性2.可以大大加快数据的检索速度（大大减少了检索的数据量），这也是创建索引的最主要的原因3.帮助服务器避免排序和临时表4.将随机IO变为顺序IO5.可以加快表与表之间的连接，特别是在实现数据的参考完整性方面有特别的意义 索引这么多优点，为什么不对表中的每一个列创建一个索引？1231.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚集索引，那么需要的空间就会更大3.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加 索引是如何提高查询速度的？1将无序的数据变成相对有序的数据（就像查目录一样） 使用索引的注意事项12345678910111.在经常需要搜索的列上，可以加快搜索的速度2.在经常使用在where子句中的列上面创建索引，加快条件的判断速度3.在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序的查询时间4.对于中、大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引5.在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度6.避免where子句中对字段施加函数这回造成无法命中索引7.在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键8.将打算加索引的列设置为NOT NULL，否则将导致引擎放弃使用索引而进行全表扫描9.删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗——MySQL5.7可以通过查询sys库的chema_unused_indexes视图来查询那些索引从未被使用10.在使用limit offset查询缓存时,可以借助索引来提高性能 MySQL索引主要使用的两个数据结构123451.哈希索引对于哈希索引来说,底层的数据结构就是哈希表,因此在绝大多数需求为单条记录查询的时候,可以选择哈希索引,查询性能最快;其余大部分场景,建议选择BTree索引2.BTree索引MySQL的BTree索引使用的是B树中的B+Tree。但对于主要的两种存储（MyISAM和InnoDB）的实现方式是不同的 MyISAM和InnoDB实现BTree索引方式的区别123451.MyISAM B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法来搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录。这被称为“非聚集索引”。2.InnoDB 其数据文件本身就是索引文件。相比MyISAM索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。 PS：整理自《Java工程师修炼之道》 覆盖索引123451.什么是覆盖索引 如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！2.覆盖索引使用实例 现在我创建了索引(username,age)，在查询数据的时候：select username , age from user where username = &apos;Java&apos; and age = 22。要查询出的列在叶子节点都存在！所以，就不用回表。 选择索引和编写利用这些索引的查询的3个原则123451. 单行访问是很慢的。特别是在机械硬盘存储中(SSD的随机I/O要快很多，不过这一点仍然成立）。如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建位置引，用以提升效率。2. 按顺序访问范围数据是很快的，这有两个原因。第一，顺序1/0不需要多次磁盘寻道，所以比随机I/O要快很多（特别是对机械硬盘）。第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且GROUPBY查询也无须再做排序和将行按组进行聚合计算了。3. 索引覆盖查询是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就不需要再回表查找行。这避免了大量的单行访问，而上面的第1点已经写明单行访问是很慢的。 你有没有做MySQL读写分离？如何实现MySQL的读写分离？MySQL主从复制原理的是啥？如何解决mysql主从同步的延时问题？123456789101112131、基于主从复制架构；搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。2、主库将变更写binlog日志，然后从库连接到主库之后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入一个中继日志中。接着从库中有一个SQL线程会从中继日志读取binlog日志，然后执行binlog日志中的内容，也就是在自己本地再执行一遍SQL，这样就可以保证自己跟主库的数据是一样的。 这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行SQL的特点，在搞并发场景下，从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。 而且这里还有另一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。 所以MySQL实际上在这一块有两个机制，一个是半同步复制，用来解决主从数据丢失问题；一个是并行复制，用来解决主从同步延时问题。 半同步复制（semi-sync复制）：指的是主库写入binlog日志以后，就将会强制此时立即将数据同步到从库，从库将日志写入自己本地的relay log 之后，接着会返回一个ack个主库，主库接收到至少一个从库的ack之后才会认为写操作完成了。 并行复制：指的是从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。 3、show status，Seconds_Behind_Master，你可以看到从库复制主库的数据落后了几ms 1、分库，将一个主库拆分为4个主库，每个主库的写并发就500/s，此时主从延迟可以忽略不计 2、打开mysql支持的并行复制，多个库并行复制，如果说某个库的写入并发就是特别高，单库写并发达到了2000/s，并行复制还是没意义。28法则，很多时候比如说，就是少数的几个订单表，写入了2000/s，其他几十个表10/s。 3、重写代码，写代码时要慎重，插入数据之后，直接就更新，不要查询 4、如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询设置直连主库。不推荐这种方法，你这么搞导致读写分离的意义就丧失了]]></content>
      <categories>
        <category>面试题, MySQL</category>
      </categories>
      <tags>
        <tag>MySQL, 面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis的相关知识]]></title>
    <url>%2F2019%2F07%2F27%2FRedis%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[一、概念：redis是一款高性能的NoSQL系列的非关系型数据库1.1什么是NoSQL123456789101112131415161718192021222324252627281.1.什么是NoSQL NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。1.1.1. NoSQL和关系型数据库比较 优点： 1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点： 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库十几年的技术同日而语。 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 3）不提供关系型数据库对事务的处理。1.1.2. 非关系型数据库的优势： 1）性能NoSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。1.1.3. 关系型数据库的优势： 1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。1.1.4. 总结 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库， 让NoSQL数据库对关系型数据库的不足进行弥补。 一般会将数据存储在关系型数据库中，在Nosql数据库中备份存储关系型数据库的数据 1.2主流的NoSQL产品123456789101112131415161718192021222324251.2.主流的NOSQL产品• 键值(Key-Value)存储数据库 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化• 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限• 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法• 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 1.3什么是Redis1234567891011121314151.3 什么是Redis Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 1) 字符串类型 string 2) 哈希类型 hash 3) 列表类型 list 4) 集合类型 set 5) 有序集合类型 sortedset1.3.1 redis的应用场景 • 缓存（数据查询、短连接、新闻内容、商品内容等等） • 聊天室的在线好友列表 • 任务队列。（秒杀、抢购、12306等等） • 应用排行榜 • 网站访问统计 • 数据过期处理（可以精确到毫秒） • 分布式集群架构中的session分离 二、关于Redis中的一些操作2.1下载安装1234561. 官网：https://redis.io2. 中文网：http://www.redis.net.cn/3. 解压直接可以使用： * redis.windows.conf：配置文件 * redis-cli.exe：redis的客户端 * redis-server.exe：redis服务器端 2.2命令操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596971. redis的数据结构： * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 * value的数据结构： 1) 字符串类型 string 2) 哈希类型 hash ： map格式 3) 列表类型 list ： linkedlist格式。支持重复元素 4) 集合类型 set ： 不允许重复元素 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 2. 字符串类型 string 1. 存储： set key value 2. 获取： get key 3. 删除： del key3. 哈希类型 hash 1. 存储： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 2. 获取： * hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username &quot;lisi&quot; * hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) &quot;username&quot; 2) &quot;lisi&quot; 3) &quot;password&quot; 4) &quot;123&quot; 3. 删除： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 1 4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 1. 添加： 1. lpush key value: 将元素加入列表左表 2. rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 2. 获取： * lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot; 3. 删除： * lpop key： 删除列表最左边的元素，并将元素返回 * rpop key： 删除列表最右边的元素，并将元素返回5. 集合类型 set ： 不允许重复元素 1. 存储：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 2. 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; 3. 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 16. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 1. 存储：zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 2. 获取：zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) &quot;zhangsan&quot; 2) &quot;60&quot; 3) &quot;wangwu&quot; 4) &quot;80&quot; 5) &quot;lisi&quot; 6) &quot;500&quot; 3. 删除：zrem key value 127.0.0.1:6379&gt; zrem mysort lisi (integer) 17. 通用命令 1. keys * : 查询所有的键 2. type key ： 获取键对应的value的类型 3. del key：删除指定的key value 三、Redis的持久化123456789101112131415161718192021221. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。2. redis持久化机制： 1. RDB：默认方式，不需要进行配置，默认就使用这种机制 * 在一定的间隔时间中，检测key的变化情况，然后持久化数据 1. 编辑redis.windwos.conf文件 # after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changed save 60 10000 2. 重新启动redis服务器，并指定配置文件名称 redis-2.8.9&gt;redis-server.exe redis.windows.conf 2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 1. 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 appendfsync no ： 不进行持久化 四、jedis中连接池：jedisPool的使用1234567891011121314151617181920212223242526271. Java客户端 Jedis * Jedis: 一款java操作redis数据库的工具. * 使用步骤： 1. 下载jedis的jar包，并导入工程中 2. 使用 //1. 获取连接 Jedis jedis = new Jedis(&quot;localhost&quot;,6379); //2. 操作 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //3. 关闭连接 jedis.close();2. 创建JedisPool连接池对象 2. 调用方法 getResource()方法获取Jedis连接 //0.创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1.创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379); //2.获取连接 Jedis jedis = jedisPool.getResource(); //3. 使用 jedis.set(&quot;hehe&quot;,&quot;heihei&quot;); //4. 关闭 归还到连接池中 jedis.close(); 五、注意1234* 注意：使用redis，缓存一些不经常发生变化的数据。 * 数据库的数据一旦发生改变，则需要更新缓存。 * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入 * 在service对应的增删改方法中，将redis数据删除。 六、面试中的Redis相关知识6.1 redis 和 memcached 的区别 redis支持更丰富的数据类型（支持更复杂的应用场景）：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。 Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。 集群模式：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的. Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。 6.2 redis 设置过期时间定期删除：redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！ 惰性删除 ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！ 但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？redis 内存淘汰机制。 6.3 redis 内存淘汰机制（MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？）redis 提供 6种数据淘汰策略： volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）. allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！ 6.4 redis 持久化机制（怎么保证 redis 挂掉之后再重启数据可以进行恢复？）Redis的一种持久化方式叫快照（snapshotting，RDB）,另一种方式是只追加文件（append-only file,AOF） ① 快照（snapshotting）持久化（RDB）： ​ Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。​ 快照持久化是Redis默认采用的持久化方式 ② AOF（append-only file）持久化： 与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启： appendonly yes ​ 开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。在Redis的配置文件中存在三种不同的 AOF 持久化方式，它们分别是： appendfsync always #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度appendfsync everysec #每秒钟同步一次，显示地将多个写命令同步到硬盘appendfsync no #让操作系统决定何时进行同步 为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec选项 ，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。 Redis 4.0 对于持久化机制的优化 Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是AOF 格式，可读性较差。 6.5 缓存雪崩和缓存穿透问题解决方案缓存雪崩简介：缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。解决办法： 事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。 事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉 事后：利用 redis 持久化机制保存的数据尽快恢复缓存 缓存穿透简介：一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。 解决办法： ​ 有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。 6.6 如何保证缓存与数据库双写时的数据一致性？你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况。串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。 6.7 Redis的主从复制如何实现？主节点将自己内存中的数据做一份快照，将快照发给从节点，从节点将数据恢复到内存中 在每次增加新数据的时候，主节点以类似于MySQL的二进制日志方式将语句发送给从节点，从节点拿到主节点发送过来的语句进行重放 6.8 Redis的单线程模型? 为什么redis单线程还能支撑高并发?客户端发出 socket 请求—–&gt;连接到 redis 的 server socket —–&gt;通过 AE_READABLE 发送到IO多路复用器—–&gt;将请求压入任务队列中—–&gt;通过文件事件分派器分配到相应的事件处理器 核心是基于非阻塞的IO多路复用模型 纯内存操作，处理请求非常快]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis, jedis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis的相关知识]]></title>
    <url>%2F2019%2F07%2F26%2FMybatis%2F</url>
    <content type="text"><![CDATA[Mybatis1.Mybatis概述123Mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花精力去处理加载驱动，创建连接，创建statement等繁杂的过程Mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由Mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽jdbc api 底层访问细节，使我们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。 2.搭建Mybatis开发环境2.1创建Maven工程1234创建 mybatis01 的工程，工程信息如下：Groupid:com.holicCodeArtifactId:mybatis01Packing:jar 2.2添加Mybatis3.4.5的坐标在pom.xml文件中添加Mybatis3.4.5的坐标，如下： 123456789101112131415161718192021222324&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.3编写必要代码(实体类和持久层接口)2.4编写SqlMapConfig.xml配置文件12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置 mybatis 的环境 --&gt; &lt;environments default="mysql"&gt; &lt;!-- 配置 mysql 的环境 --&gt; &lt;environment id="mysql"&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置连接数据库的信息：用的是数据源(连接池) --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/student"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt;&lt;!-- 告知 mybatis 映射配置的位置 --&gt;&lt;mappers&gt; &lt;mapper resource="com/holicCode/dao/IUserDao.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.5编写映射配置文件2.6编写测试类3.Mybatis中用到的设计模式123工厂模式（SqlSessionFactory）代理模式(MapperProxyFactory)构建者模式(SqlSessionFactoryBuilder) 4.Mybatis与JDBC编程的比较1234567891011121.数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。解决： 在 SqlMapConfig.xml 中配置数据链接池，使用连接池管理数据库链接。2.Sql 语句写在代码中造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java 代码。解决： 将 Sql 语句配置在 XXXXmapper.xml 文件中与 java 代码分离。3.向 sql 语句传参数麻烦，因为 sql 语句的 where 条件不一定，可能多也可能少，占位符需要和参数对应。解决： Mybatis 自动将 java 对象映射至 sql 语句，通过 statement 中的 parameterType 定义输入参数的类型。4.对结果集解析麻烦，sql 变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成 pojo 对象解析比较方便。解决： Mybatis 自动将 sql 执行结果映射至 java 对象，通过 statement 中的resultType 定义输出结果的类型。 5.当编写的实体类属性名和数据库表的列名不一致时5.1出现的问题12查询出来的结果会都为null有时有可能会出现某一列有值的情况,这是因为MySQL在Windows系统中不区分大小写! 5.2解决方案一12修改映射配置文件给映射配置文件的SQL语句中的列名起别名(该方法当我们查询很多事,都使用的话写起来很麻烦) 5.3解决方案二​ resultMap结果类型 12resultMap 标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。在 select 标签中使用 resultMap 属性指定引用即可。同时 resultMap 可以实现将查询结果映射为复杂类型的 pojo，比如在查询结果映射对象中包括 pojo 和 list 实现一对一查询和一对多查询。 6.Mybatis连接池1Mybatis连接池与web中的连接池不同,Mybatis中的连接池使用的自己的连接池技术,在Mybatis的SqlMapConfig.xml配置文件中,通过&lt;dataSource type=&quot;pooled&quot;&gt;来实现Mybatis中连接池的配置。 6.1Mybatis连接池的分类123UNPOOLED 不使用连接池的数据源POOLED 使用连接池的数据源（我们一般使用的数据源）JNDI 使用JNDI实现的数据源 1相应地，MyBatis 内部分别定义了实现了 java.sql.DataSource 接口的 UnpooledDataSource，PooledDataSource 类来表示 UNPOOLED、POOLED 类型的数据源。 6.2Mybatis中数据源的配置123456789101112数据源配置就是在 SqlMapConfig.xml 文件中，具体配置如下：&lt;!-- 配置数据源（连接池）信息 --&gt;&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/dataSource&gt;MyBatis 在初始化时，根据&lt;dataSource&gt;的 type 属性来创建相应类型的的数据源 DataSource，即：type=”POOLED”：MyBatis 会创建 PooledDataSource 实例type=”UNPOOLED” ： MyBatis 会创建 UnpooledDataSource 实例type=”JNDI”：MyBatis 会从 JNDI 服务上查找 DataSource 实例，然后返回使用 7.Mybatis中事务控制7.3Mybatis中事务提交方式1Mybatis中事务的提交方式，本质上就是调用JDBC的setAutoComment（）来实现事务控制，默认情况下setAutoComment（）的参数为false，所以我们要手动使用SqlSession.commit（）来提交事务 7.4Mybatis自动提交事务的设置12在创建SqlSession工厂对象时，传入trueSqlSession session = factory.openSession（true）; 8.Mybatis中的动态SQL语句1234主要就是使用Mybatis中提供的动态SQL语句标签&lt;if&gt;&lt;where&gt;&lt;foreach&gt; 9.Mybatis延迟加载策略9.1何为延迟加载123延迟加载：就是需要用到数据是才进行加载，不需要用到数据时就不加载数据。也称为懒加载 好处：先从单表查询，需要时再关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快 坏处：因为只有当需要用到数据时，才会进行数据库查询，这样大批量数据查询时，因为查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体检下降。 9.2开启Mybatis的延迟加载策略1234567891011121314151617181920212223242526271.需要再Mybatis的配置文件SqlMapConfig.xml文件中添加延迟加载的配置&lt;settings&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt;&lt;/settings&gt;2.使用Collection实现延迟加载&lt;!-- collection 是用于建立一对多中集合属性的对应关系 ofType 用于指定集合元素的数据类型 select 是用于指定查询账户的唯一标识（账户的 dao 全限定类名加上方法名称） column 是用于指定使用哪个字段的值作为条件查询--&gt;&lt;collection property="accounts" ofType="account" select="" column=""&gt;&lt;/collection&gt;&lt;collection&gt;标签：主要用于加载关联的集合对象select 属性：用于指定查询 account 列表的 sql 语句，所以填写的是该 sql 映射的 idcolumn 属性：用于指定 select 属性的 sql 语句的参数来源，上面的参数来自于 user 的 id 列，所以就写成 id 这一个字段名了 10.Mybatis缓存Mybatis通过缓存策略来减少数据库的查询次数，从而提高性能 10.1Mybatis一级缓存12一级缓存是 SqlSession 级别的缓存，只要 SqlSession 没有 flush 或 close，它就存在。一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()等方法时，就会清空一级缓存。 10.2Mybatis二级缓存1二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。 10.2.1二级缓存的开启与关闭12345678910111213141516171819202122232425第一步：在SqlMapConfig.xml文件开启二级缓存&lt;settings&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;因为 cacheEnabled 的取值默认就为 true，所以这一步可以省略不配置。为 true 代表开启二级缓存；为false 代表不开启二级缓存。第二步：配置相关的Mapper映射文件&lt;cache&gt;标签表示当前这个 mapper 映射将使用二级缓存，区分的标准就看 mapper 的 namespace 值。&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.holicCode.dao.IUserDao&quot;&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;cache&gt;&lt;/cache&gt;&lt;/mapper&gt;第三部：配置statement上面的useCache属性&lt;!-- 根据 id 查询 --&gt;&lt;select id=&quot;findById&quot; resultType=&quot;user&quot; parameterType=&quot;int&quot; useCache=&quot;true&quot;&gt; select * from user where id = #&#123;uid&#125;&lt;/select&gt; 将 UserDao.xml 映射文件中的&lt;select&gt;标签中设置 useCache=”true”代表当前这个 statement 要使用二级缓存，如果不使用二级缓存可以设置为 false。注意：针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存 10.2.2基于注解的二级缓存123456789101.在SqlMapConfig中开启二级缓存支持&lt;!-- 配置二级缓存 --&gt;&lt;settings&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;setting name="cacheEnabled" value="true"/&gt;&lt;/settings&gt;2.在持久层接口中使用注解配置二级缓存@CacheNamespace(blocking=true)//mybatis 基于注解方式实现配置二级缓存public interface IUserDao &#123;&#125; 10.2.3二级缓存的注意事项1当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable 接口，这种就可以使用序列化方式来保存对象。 11.Mybatis的注解开发11.1Mybatis常用注解说明1234567891011@Insert:实现新增@Update:实现更新@Delete:实现删除@Select:实现查询@Result:实现结果集封装@Results:可以与@Result 一起使用，封装多个结果集@ResultMap:实现引用@Results 定义的封装@One:实现一对一结果集封装@Many:实现一对多结果集封装@SelectProvider: 实现动态 SQL 映射@CacheNamespace:实现注解二级缓存的使用]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL初级]]></title>
    <url>%2F2019%2F07%2F24%2FMySQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[MySQL基础知识汇总数据库的基本概念1. 数据库的英文单词： DataBase 简称 ： DB 2. 什么数据库？ * 用于存储和管理数据的仓库。 3. 数据库的特点： 1. 持久化存储数据的。其实数据库就是一个文件系统 2. 方便存储和管理数据 3. 使用了统一的方式操作数据库 -- SQLMySQL数据库软件1. 安装 2. 卸载 1. 去mysql的安装目录找到my.ini文件 * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot; 2. 卸载MySQL 3. 删除C:/ProgramData目录下的MySQL文件夹。 3. 配置 * MySQL服务启动 1. 手动。 2. cmd--&gt; services.msc 打开服务的窗口 3. 使用管理员打开cmd * net start mysql : 启动mysql的服务 * net stop mysql:关闭mysql服务 * MySQL登录 1. mysql -uroot -p密码 2. mysql -hip -uroot -p连接目标的密码 3. mysql --host=ip --user=root --password=连接目标的密码 * MySQL退出 1. exit 2. quit * MySQL目录结构 1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot; * 配置文件 my.ini 2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot; * 几个概念 * 数据库：文件夹 * 表：文件 * 数据：数据SQL1.什么是SQL？ Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 2.SQL通用语法 1. SQL 语句可以单行或多行书写，以分号结尾。 2. 可使用空格和缩进来增强语句的可读性。 3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 4. 3 种注释 * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) * 多行注释: /* 注释 */ 3. SQL分类 1) DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 2) DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 3) DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 4) DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL:操作数据库、表1. 操作数据库：CRUD 1. C(Create):创建 * 创建数据库： * create database 数据库名称; * 创建数据库，判断不存在，再创建： * create database if not exists 数据库名称; * 创建数据库，并指定字符集 * create database 数据库名称 character set 字符集名; * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk * create database if not exists db4 character set gbk; 2. R(Retrieve)：查询 * 查询所有数据库的名称: * show databases; * 查询某个数据库的字符集:查询某个数据库的创建语句 * show create database 数据库名称; 3. U(Update):修改 * 修改数据库的字符集 * alter database 数据库名称 character set 字符集名称; 4. D(Delete):删除 * 删除数据库 * drop database 数据库名称; * 判断数据库存在，存在再删除 * drop database if exists 数据库名称; 5. 使用数据库 * 查询当前正在使用的数据库名称 * select database(); * 使用数据库 * use 数据库名称; 2. 操作表 1. C(Create):创建 1. 语法： create table 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n ); * 注意：最后一列，不需要加逗号（,） * 数据库类型： 1. int：整数类型 * age int, 2. double:小数类型 * score double(5,2) 3. date:日期，只包含年月日，yyyy-MM-dd 4. datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 5. timestamp:时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 6. varchar：字符串 * name varchar(20):姓名最大20个字符 * zhangsan 8个字符 张三 2个字符12345678910111213141516171819202122232425262728293031 * 创建表 create table student( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp ); * 复制表： * create table 表名 like 被复制的表名; 2. R(Retrieve)：查询 * 查询某个数据库中所有的表名称 * show tables; * 查询表结构 * desc 表名;3. U(Update):修改 1. 修改表名 alter table 表名 rename to 新的表名; 2. 修改表的字符集 alter table 表名 character set 字符集名称; 3. 添加一列 alter table 表名 add 列名 数据类型; 4. 修改列名称 类型 alter table 表名 change 列名 新列别 新数据类型; alter table 表名 modify 列名 新数据类型; 5. 删除列 alter table 表名 drop 列名;4. D(Delete):删除 * drop table 表名; * drop table if exists 表名 ; DML：增删改表中数据1. 添加数据： * 语法： * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n); * 注意： 1. 列名和值要一一对应。 2. 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,...值n); 3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来 2. 删除数据： * 语法： * delete from 表名 [where 条件] * 注意： 1. 如果不加条件，则删除表中所有记录。 2. 如果要删除所有记录 1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作 2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 3. 修改数据： * 语法： * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件]; * 注意： 1. 如果不加任何条件，则会将表中所有记录全部修改。DQL：查询表中的记录1234567891011121314151617* select * from 表名;1. 语法： select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定 2. 基础查询 1. 多个字段的查询 select 字段名1，字段名2... from 表名； * 注意： * 如果查询所有字段，则可以使用*来替代字段列表。 2. 去除重复： * distinct 3. 计算列 * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null * 表达式1：哪个字段需要判断是否为null * 如果该字段为null后的替换值。 4. 起别名： * as：as也可以省略1234567891011121314151617181920212223242526272829303132333435363738394041424344453. 条件查询 1. where子句后跟条件 2. 运算符 * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt; * BETWEEN...AND * IN( 集合) * LIKE：模糊查询 * 占位符： * _:单个任意字符 * %：多个任意字符 * IS NULL * and 或 &amp;&amp; * or 或 || * not 或 ! -- 查询年龄大于20岁 SELECT * FROM student WHERE age &gt; 20; SELECT * FROM student WHERE age &gt;= 20; -- 查询年龄等于20岁 SELECT * FROM student WHERE age = 20; -- 查询年龄不等于20岁 SELECT * FROM student WHERE age != 20; SELECT * FROM student WHERE age &lt;&gt; 20; -- 查询年龄大于等于20 小于等于30 SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30; SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30; SELECT * FROM student WHERE age BETWEEN 20 AND 30; -- 查询年龄22岁，18岁，25岁的信息 SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25 SELECT * FROM student WHERE age IN (22,18,25); -- 查询英语成绩为null SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断 SELECT * FROM student WHERE english IS NULL; -- 查询英语成绩不为null SELECT * FROM student WHERE english IS NOT NULL; 1234567891011-- 查询姓马的有哪些？ likeSELECT * FROM student WHERE NAME LIKE '马%';-- 查询姓名第二个字是化的人SELECT * FROM student WHERE NAME LIKE "_化%";-- 查询姓名是3个字的人SELECT * FROM student WHERE NAME LIKE '___';-- 查询姓名中包含德的人SELECT * FROM student WHERE NAME LIKE '%德%'; 123456789104. 排序查询 * 语法：order by 子句 * order by 排序字段1 排序方式1 ， 排序字段2 排序方式2... * 排序方式： * ASC：升序，默认的。 * DESC：降序。 * 注意： * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。 1234567891011122. 聚合函数：将一列数据作为一个整体，进行纵向的计算。 1. count：计算个数 1. 一般选择非空的列：主键 2. count(*) 2. max：计算最大值 3. min：计算最小值 4. sum：计算和 5. avg：计算平均值 * 注意：聚合函数的计算，排除null值。 解决方案： 1. 选择不包含非空的列进行计算 2. IFNULL函数 12345678910111213141516171819202122233. 分组查询: 1. 语法：group by 分组字段； 2. 注意： 1. 分组之后查询的字段：分组字段、聚合函数 2. where 和 having 的区别？ 1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来 2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。 -- 按照性别分组。分别查询男、女同学的平均分 SELECT sex , AVG(math) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2; SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2; 1234567891011124. 分页查询 1. 语法：limit 开始的索引,每页查询的条数; 2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数 -- 每页显示3条记录 SELECT * FROM student LIMIT 0,3; -- 第1页 SELECT * FROM student LIMIT 3,3; -- 第2页 SELECT * FROM student LIMIT 6,3; -- 第3页 3. limit 是一个MySQL"方言" 约束123456789101112131415161718* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。 * 分类： 1. 主键约束：primary key 2. 非空约束：not null 3. 唯一约束：unique 4. 外键约束：foreign key* 非空约束：not null，值不能为null 1. 创建表时添加约束 CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL -- name为非空 ); 2. 创建表完后，添加非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; 3. 删除name的非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546* 唯一约束：unique，值不能重复 1. 创建表时，添加唯一约束 CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束 ); * 注意mysql中，唯一约束限定的列的值可以有多个null 2. 删除唯一约束 ALTER TABLE stu DROP INDEX phone_number; 3. 在创建表后，添加唯一约束 ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;* 主键约束：primary key。 1. 注意： 1. 含义：非空且唯一 2. 一张表只能有一个字段为主键 3. 主键就是表中记录的唯一标识 2. 在创建表时，添加主键约束 create table stu( id int primary key,-- 给id添加主键约束 name varchar(20) ); 3. 删除主键 -- 错误 alter table stu modify id int ; ALTER TABLE stu DROP PRIMARY KEY; 4. 创建完表后，添加主键 ALTER TABLE stu MODIFY id INT PRIMARY KEY; 5. 自动增长： 1. 概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长 2. 在创建表时，添加主键约束，并且完成主键自增长 create table stu( id int primary key auto_increment,-- 给id添加主键约束 name varchar(20) ); 3. 删除自动增长 ALTER TABLE stu MODIFY id INT; 4. 添加自动增长 ALTER TABLE stu MODIFY id INT AUTO_INCREMENT; 12345678910111213141516171819202122* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。 1. 在创建表时，可以添加外键 * 语法： create table 表名( .... 外键列 constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) ); 2. 删除外键 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 3. 创建表之后，添加外键 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); 4. 级联操作 1. 添加级联操作 语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE ; 2. 分类： 1. 级联更新：ON UPDATE CASCADE 2. 级联删除：ON DELETE CASCADE 数据库的设计123456789101112131415161718192021222324252627282930313233343536373839404142431. 多表之间的关系 1. 分类： 1. 一对一(了解)： * 如：人和身份证 * 分析：一个人只有一个身份证，一个身份证只能对应一个人 2. 一对多(多对一)： * 如：部门和员工 * 分析：一个部门有多个员工，一个员工只能对应一个部门 3. 多对多： * 如：学生和课程 * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择 2. 实现关系： 1. 一对多(多对一)： * 如：部门和员工 * 实现方式：在多的一方建立外键，指向一的一方的主键。 2. 多对多： * 如：学生和课程 * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 3. 一对一(了解)： * 如：人和身份证 * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。 3. 案例 /*创建用户表 tab_user uid 用户主键，自增长 username 用户名长度 100，唯一，非空 password 密码长度 30，非空 name 真实姓名长度 100 birthday 生日 sex 性别，定长字符串 1 telephone 手机号，字符串 11 email 邮箱，字符串长度 100 */ CREATE TABLE tab_user ( uid INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) UNIQUE NOT NULL, PASSWORD VARCHAR(30) NOT NULL, NAME VARCHAR(100), birthday DATE, sex CHAR(1) DEFAULT '男', telephone VARCHAR(11), email VARCHAR(100) ); 数据库设计的范式123456789101112131415161. 第一范式（1NF）：每一列都是不可分割的原子数据项2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） * 几个概念： 1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A 例如：学号--&gt;姓名。 （学号，课程名称） --&gt; 分数 2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。 例如：（学号，课程名称） --&gt; 分数 3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。 例如：（学号，课程名称） -- &gt; 姓名 4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A 例如：学号--&gt;系名，系名--&gt;系主任 5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码 例如：该表中码为：（学号，课程名称） * 主属性：码属性组中的所有属性 * 非主属性：除过码属性组的属性3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 数据库的备份和还原123456789101. 命令行： * 语法： * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 * 还原： 1. 登录数据库 2. 创建数据库 3. 使用数据库 4. 执行文件。source 文件路径2. 也可以使用图形化工具, 更加方便 推荐 Navicat for MySQL, 个人觉得比较好用 MySQL的多表查询&amp;事务多表查询123456* 查询语法： select 列名列表 from 表名列表 where.... 123* 笛卡尔积： * 有两个集合A,B .取这两个集合的所有组成情况。 * 要完成多表查询，需要消除无用的数据 1234567* 多表查询的分类： 1. 内连接查询： 1. 隐式内连接：使用where条件消除无用数据 * 语法： SELECT * FROM 表1,表2 WHERE 表名1.`表1的外键` = 表2的主键; 其中表1的外键是表二的主键 2. 显式内连接： * 语法： select 字段列表 from 表1 [inner] join 表2 on 条件 事务1234567891011121314151617181920212223242526272829301. 事务的基本介绍 1. 概念: 如果一个包含多个步骤的业务操作, 被事务管理, 那么这些操作要么都成功, 要们都失败 2.操作: 1.开启事务: start transaction; 2.回滚: rollback; 3.提交: commit;2. 事务的四大特征(ACID): 1. 原子性(Atomicity): 是不可分割的最小操作单位, 要么都成功, 要么都失败 2. 一致性(Consistency): 事务操作前后, 数据总量不变 3. 隔离性(Isolation): 多个事务之间, 相互独立 4. 持久性(Durability): 当事务提交或回滚后, 数据库会持久化的保存数据3. 事务的隔离级别 1. 概念: 多个事务之间是隔离的,相互独立的, 但是如果多个事务操作同一批数据, 则会引发一些问题,设置不同的隔离级别就可以解决这些问题 2. 存在的问题: 1.脏读: 一个事务,读取到另一个事务中没有提交的数据 2.不可重复读(虚读): 在同一个事务中,两次读取到的数据不一样 2.幻读: 一个事务操作(DML)数据表中的所有记录, 另一个事务添加了一条数据,则第一个事务查询不到自己的修改 3. 隔离级别: 1.read uncommitted: 读未提交 产生的问题: 脏读, 不可重复读, 幻读 2. read committed: 读已提交(Oracle) 产生的问题: 不可重复读, 幻读 3. repeatable read: 可重复读(MySQL默认) 产生的问题: 幻读 4. serializable: 串行化 可以解决所有问题 注意: 隔离级别从小到大安全性越来越高, 但是效率越来越低 数据库查询隔离级别: select @@tx_isolation; 数据库设置隔离级别: set global transaction isolation level 级别字符串; DCL1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950DCL：管理用户，授权 1. 管理用户 1. 添加用户： * 语法：CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 2. 删除用户： * 语法：DROP USER '用户名'@'主机名'; 3. 修改用户密码： UPDATE USER SET PASSWORD = PASSWORD('新密码') WHERE USER = '用户名'; UPDATE USER SET PASSWORD = PASSWORD('abc') WHERE USER = 'lisi'; SET PASSWORD FOR '用户名'@'主机名' = PASSWORD('新密码'); SET PASSWORD FOR 'root'@'localhost' = PASSWORD('123'); * mysql中忘记了root用户的密码？ 1. cmd -- &gt; net stop mysql 停止mysql服务 * 需要管理员运行该cmd 2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables 3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功 4. use mysql; 5. update user set password = password('你的新密码') where user = 'root'; 6. 关闭两个窗口 7. 打开任务管理器，手动结束mysqld.exe 的进程 8. 启动mysql服务 9. 使用新密码登录。 4. 查询用户： -- 1. 切换到mysql数据库 USE myql; -- 2. 查询user表 SELECT * FROM USER; * 通配符： % 表示可以在任意主机使用用户登录数据库 2. 权限管理： 1. 查询权限： -- 查询权限 SHOW GRANTS FOR '用户名'@'主机名'; SHOW GRANTS FOR 'lisi'@'%'; 2. 授予权限： -- 授予权限 grant 权限列表 on 数据库名.表名 to '用户名'@'主机名'; -- 给张三用户授予所有权限，在任意数据库任意表上 GRANT ALL ON *.* TO 'zhangsan'@'localhost'; 3. 撤销权限： -- 撤销权限： revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名'; REVOKE UPDATE ON db3.`account` FROM 'lisi'@'%';]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>MySQL, sql语句, MySQL概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题库以及详解]]></title>
    <url>%2F2019%2F07%2F24%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[剑指offer第一题题目:在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路:因为这个二维数组是有序的, 可以先定位到左下角, 判断要找的数, 如果target &gt; 左下角 就往右找, 然后target &lt; 左下角 就往上找 1234567891011121314151617181920public class Solution &#123; public boolean Find(int target, int [][] array) &#123; //得到二维数组的行和列 int rows = array.length; int cols = array[0].length; //定位到左下角 int i = rows - 1; int j = 0; //循环查找, 不知道循环次数, 用while while(i &gt;= 0 &amp;&amp; j &lt; cols)&#123; if(target &gt; array[i][j]) j++; else if(target &lt; array[i][j]) i--; else return true; &#125; return false; &#125;&#125; 第二题题目: 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路:首先不能使用String提供的replace()方法 ①从前往后替换, 每替换一次后面的字符就要移动一次, 效率低下 ②从后往前替换, 每个字符只需要移动一次, 所以选择这个思路 1234567891011121314151617181920212223242526public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; //计算空格数 int spacenum = 0; for(int i = 0; i &lt; str.length(); i++)&#123; if(str.charAt(i) == ' ') spacenum++; &#125; //扩容 int indexOld = str.length() - 1; int newLength = str.length() + spacenum * 2; int indexNew = newLength - 1; str.setLength(indexNew); //替换 for(;indexOld &gt;= 0 &amp;&amp; newLength &gt; indexOld; --indexOld)&#123; if(str.charAt(indexOld) == ' ')&#123; str.setCharAt(indexNew--, '0'); str.setCharAt(indexNew--, '2'); str.setCharAt(indexNew--, '%'); &#125; else &#123; str.setCharAt(indexNew--, str.charAt(indexOld)); &#125; &#125; return str.toString(); &#125;&#125; 第三题题目: 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125; 代码实现: 解法一: 递归 123456789101112131415import java.util.ArrayList;public class Solution &#123; //先创建一个 ArrayList 集合 ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; //判断传入的链表是否不为空 if(listNode != null)&#123; //递归调用 printListFromTailToHead()方法, 传入链表的元素 this.printListFromTailToHead(listNode.next); //将遍历出来的链表的元素的值添加入 arrayList 中 arrayList.add(listNode.val); &#125; return arrayList; &#125;&#125; 解法二: 利用栈(先进后出) 1234567891011121314151617import java.util.ArrayList;import java.util.Stack;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack&lt;Integer&gt; temp = new Stack&lt;&gt;(); ArrayList&lt;Integer&gt; newList = new ArrayList&lt;&gt;(); ListNode t = listNode; while( t != null )&#123; temp.push(t.val); t = t.next; &#125; while( !temp.empty() )&#123; newList.add(temp.pop()); &#125; return newList; &#125;&#125; 第四题题目: 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 1234567Definition for binary tree public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x;&#125; &#125; 代码实现: 12345678910111213141516171819202122public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; TreeNode root=reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1); return root; &#125; //前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125; private TreeNode reConstructBinaryTree(int [] pre,int startPre,int endPre,int [] in,int startIn,int endIn) &#123; if(startPre&gt;endPre||startIn&gt;endIn) return null; TreeNode root= new TreeNode(pre[startPre]); //前序遍历结果的 第一个元素就是根节点 for(int i=startIn;i&lt;=endIn;i++) if(in[i]==pre[startPre])&#123; root.left=reConstructBinaryTree(pre,startPre+1,startPre+i-startIn,in,startIn,i-1); root.right=reConstructBinaryTree(pre,i-startIn+startPre+1,endPre,in,i+1,endIn); break; &#125; return root; &#125;&#125; 第五题题目: 用两个栈来实现一个队列,完成队列的Push和Pop操作, 队列中的元素为 int 类型 思路: 首先栈是先进后出, 队列是先进先出 12345678910111213141516171819202122232425import java.util.Stack; public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); //队列的 push 操作和 栈的 push 是相同的 public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; //判断 stack1 和 stack2 是否为空 if(stack1.empty()&amp;&amp;stack2.empty())&#123; throw new RuntimeException("Queue is empty!"); &#125; if(stack2.empty())&#123; while(!stack1.empty())&#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.pop(); &#125;&#125; 第六题题目:把一个数组最开始的若干元素搬到数组的末尾, 我们称之为数组的旋转. 输入一个非减排序的数组的一个旋转, 输出旋转数组的最小元素.例如数组{3,4,5,1,2} 为 {1,2,3,4,5}, 该数组的最小值为1, NOTE: 给出的所有元素都大于0, 若数组大小为0 ,请返回0 思路:(1)array[mid] &gt; array[high]: 出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。 low = mid + 1 (2)array[mid] == array[high]: 出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边 还是右边,这时只好一个一个试 ， high = high - 1 (3)array[mid] &lt; array[high]: 出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左 边。因为右边必然都是递增的。 high = mid 12345678910111213141516171819202122import java.util.ArrayList;public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; int low = 0; int hight = array.length - 1; while(low &lt; hight)&#123; //中间的位置 int mid = low + (hight - low)/2; //若中间的数 &gt; 最后一个数, 最小的数就是中间数的下一个 if(array[mid] &gt; array[hight])&#123; low = mid + 1; //若中间的数 = 最后一个数, 最小的数左右都有可能, 所有要缩小,继续找 &#125;else if(array[mid] == array[hight])&#123; hight -= 1; //若中间的数 &lt; 最后一个数, 最小的数只能是中间的数,或,中间数的左边的数中的某一个 &#125;else&#123; hight = mid; &#125; &#125; return array[low]; &#125;&#125; 第七题题目: 输入一个整数n, 请你输出斐波那契列的第n项(从0开始,第0项为0) 思路一: 采用递归, 这种解法效率低, 每次都要调自己 123456789public class Solution &#123; public int Fibonacci(int n) &#123; if(n &lt; 2)&#123; return n; &#125;else&#123; return Fibonacci(n - 1) + Fibonacci(n - 2); &#125; &#125;&#125; 思路二: 1234567891011121314public class Solution &#123; public int Fibonacci(int n) &#123; if(n &lt; 0) throw new IllegalArgumentException("输入的数不能小于0"); if(n == 0 || n == 1) return n; int a = 1, b = 0, sum = 0; for(int i = 2;i &lt;= n;i++)&#123; sum = a + b; b = a; a = sum; &#125; return sum; &#125;&#125; 第八题题目: 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 思路: 这还是一个斐波那契列, 唯一不同的是从1开始 1234567891011121314public class Solution &#123; public int JumpFloor(int target) &#123; if(target &lt; 1) throw new IllegalArgumentException("台阶数不能小于1");; if(target &lt; 3) return target; int a = 1, b = 2, sum = 0; for(int i = 3;i &lt;= target;i++)&#123; sum = a + b; a = b; b = sum; &#125; return sum; &#125;&#125; 第九题题目: 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。 求该青蛙跳上一个n级的台阶总共有多少种跳法。分析: f(1) = 1 f(2) = f(2-1) + f(2-2) //f(2-2) 表示2阶一次跳2阶的次数。 f(3) = f(3-1) + f(3-2) + f(3-3) … f(n) = f(n-1) + f(n-2) + f(n-3) + … + f(n-(n-1)) + f(n-n) 说明： 1）这里的f(n) 代表的是n个台阶有一次1,2,...n阶的 跳法数。 2）n = 1时，只有1种跳法，f(1) = 1 3) n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ，f(2) = f(2-1) + f(2-2) 4) n = 3时，会有三种跳得方式，1阶、2阶、3阶，那么就是第一次跳出1阶后面剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3) 因此结论是f(3) = f(3-1)+f(3-2)+f(3-3) 5) n = n时，会有n中跳的方式，1阶、2阶...n阶，得出结论： f(n) = f(n-1)+f(n-2)+...+f(n-(n-1)) + f(n-n) =&gt; f(0) + f(1) + f(2) + f(3) + ... + f(n-1) 6) 由以上已经是一种结论，但是为了简单，我们可以继续简化： f(n-1) = f(0) + f(1)+f(2)+f(3) + ... + f((n-1)-1) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2) f(n) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2) + f(n-1) = f(n-1) + f(n-1) 可以得出：f(n) = 2*f(n-1) 7) 得出最终结论,在n阶台阶，一次有1、2、...n阶的跳的方式时，总得跳法为： | 1 ,(n=0 ) f(n) = | 1 ,(n=1 ) | 2*f(n-1),(n&gt;=2)代码实现: 12345678910public class Solution &#123; public int JumpFloorII(int target) &#123; if(target &lt; 0) throw new IllegalArgumentException("台阶数不能小于0"); if(target == 1)&#123; return 1; &#125;else&#123; return 2 * JumpFloorII(target - 1); &#125; &#125;&#125; 第十题题目: 我们可以用2×1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2×n的大矩形，总共有多少种方法？ 分析: 还是一个斐波那契 采用递归: 12345678910public class Solution &#123; public int RectCover(int target) &#123; if(target &lt; 0) throw new IllegalArgumentException("输入的n不能小于0的整数"); if(target == 0 || target == 1 || target == 2)&#123; return target; &#125; else&#123; return RectCover(target - 1) + RectCover(target - 2); &#125; &#125;&#125; 不用递归, 效率比较高的解法: 1234567891011121314public class Solution &#123; public int RectCover(int target) &#123; if(target &lt; 0) throw new IllegalArgumentException("输入的数不能小于0"); if(target == 0 || target == 1) return target; int a = 1, b = 1, sum = 0; for(int i = 2;i &lt;= target;i++)&#123; sum = a + b; b = a; a = sum; &#125; return sum; &#125;&#125; 第十一题题目: 输入一个整数, 输出该数二进制表示中1的个数, 其中负数用补码表示 思路:如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。 举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。 12345678public int NumberOf1(int n)&#123; int count = 0; while(n != 0)&#123; count++; n = n &amp; (n - 1); &#125; return count;&#125; 第十二题题目: 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 解法一: 常规解法, 时间复杂度为O(n) 12345678910111213public class Solution &#123; public double Power(double base, int exponent) &#123; double result = 1; //abs() : 返回这个数的绝对值 for(int i = 0;i &lt; Math.abs(exponent);i++)&#123; result *= base; &#125; if(exponent &lt; 0)&#123; result = 1/result; &#125; return result; &#125;&#125; 解法二: 递归: ​ n为偶数时, a^n = a^(n/2) * a^(n/2) ​ n为奇数时, a^n=（a^（n-1）/2）×（a^（n-1/2））×a 时间复杂度为 O(logn) 12345678910111213public class Solution()&#123; public double Power(double base, int exponent)&#123; int n = Math.abs(exponent); if(n == 0) return 1; if(n == 1) return base; double result = Power(base, n&gt;&gt;1); result *= result; if((n&amp;1) == 1) result *= base; if(exponent &lt; 0) result = 1/result; return result; &#125;&#125; 第十三题题目: 输入一个整数数组,实现一个函数来调整该数组中的数字的顺序,使得所有的奇数位于数组的前半部分,所有的偶数位于数组的后半部分,并保证奇数和奇数,偶数和偶数之间的相对位置不变. 思路: 123首先统计奇数的个数然后新建一个等长数组，设置两个指针，奇数指针从0开始，偶数指针从奇数个数的末尾开始 遍历，填数此方法的时间复杂度为O(n) 123456789101112131415161718192021222324252627public class Solution&#123; public void reOrderArray(int [] array)&#123; if(array.length == 0 ||array.length == 1) return; int oddCount = 0,oddBegin = 0; //创建一个和原数组等长的新数组 int[] newArray = new int[array.length]; //遍历数组 for(int i = 0;i &lt; array.length;i++)&#123; //判断数组元素为奇数时,将oddCount向后移一位, //最终oddCount的位置就是第一个偶数的位置 if((array[i]&amp;1) == 1) oddCount++; &#125; for(int i = 0;i &lt; array.length;i++)&#123; //判断元素为奇数就从新数组的开头位置开始放 if((array[i]&amp;1) == 1)&#123; newArray[oddBegin++] = array[i]; &#125; else&#123; //如果元素为偶数就从新数组的偶数第一个位置开始放 newArray[oddCount++] = array[i]; &#125; &#125; //最后用新数组排好序的元素替换原数组的元素 for(int i = 0;i &lt; array.length;i++)&#123; array[i] = newArray[i]; &#125; &#125;&#125; 第十四题题目: 输入一个链表,输出该链表中倒数第K个节点 123456789/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/ 思路: 定义两个指针, 先让着两个指针都指向链表的头结点, 然后让其中一个指针往后移(k - 1)位, 再让另一个指针开始跑(此时两个指针在相对静止的跑), 当先跑的那个指针到达链表末尾时, 后跑的那个指针到达的位置就是倒数第k的位置 12345678910111213141516171819public class Solution&#123; public ListNode FindKthToTail(ListNode head,int k)&#123; //定义两个指针都指向头结点 ListNode p, q; p = q = head; //记录k值 int a = k; //记录节点个数 int count = 0; while(p != null)&#123; p = p.next; count++; if(k &lt; 1) q = q.next; k--; &#125; if(count &lt; a) return null; return q; &#125;&#125; 12345678910111213精简写法public class Solution&#123; public ListNode FindKthToTail(ListNode head,int k)&#123; ListNode p, q; p = q = head; int i = 0; for( ; p != null; i++)&#123; if(i &gt;= k) q = q.next; p = p.next; &#125; return i &lt; k ? null : q; &#125;&#125; 第十五题题目: 输入一个人链表, 反转链表后, 输出新链表的表头. 123456789/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/ 题解 12345678910111213141516171819202122232425262728293031public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; if(head==null) return null; //head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null； ListNode pre = null; ListNode next = null; //当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点 //需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre&lt;-head next1-&gt;next2 //即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了 //所以需要用到pre和next两个节点 //1-&gt;2-&gt;3-&gt;4-&gt;5 //1&lt;-2&lt;-3 4-&gt;5 while(head!=null)&#123; //做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre //如此就可以做到反转链表的效果 //先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂 next = head.next; //保存完next，就可以让head从指向next变成指向pre了，代码如下 head.next = pre; //head指向pre后，就继续依次反转下一个节点 //让pre，head，next依次向后移动一个节点，继续下一次的指针反转 pre = head; head = next; &#125; //如果head为null的时候，pre就为最后一个节点了，但是链表已经反转完毕，pre就是反转后链表的第一个节点 //直接输出pre就是我们想要得到的反转后的链表 return pre; &#125;&#125; 第十六题题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 1234567891011121314151617181920212223242526/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*///采用递归的方法public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1 == null) return list2; if(list2 == null) return list1; if(list1.val &lt;= list2.val)&#123; list1.next = Merge(list1.next, list2); return list1; &#125; else&#123; list2.next = Merge(list1, list2.next); return list2; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728//非递归版public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; //新建一个头节点，用来存合并的链表。 ListNode head=new ListNode(-1); head.next=null; ListNode root=head; while(list1!=null&amp;&amp;list2!=null)&#123; if(list1.val&lt;list2.val)&#123; head.next=list1; head=list1; list1=list1.next; &#125;else&#123; head.next=list2; head=list2; list2=list2.next; &#125; &#125; //把未结束的链表连接到合并后的链表尾部 if(list1!=null)&#123; head.next=list1; &#125; if(list2!=null)&#123; head.next=list2; &#125; return root.next; &#125;&#125; 第十七题题目：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public static boolean HasSubtree(TreeNode root1, TreeNode root2) &#123; boolean result = false; //当Tree1和Tree2都不为零的时候，才进行比较。否则直接返回false if (root2 != null &amp;&amp; root1 != null) &#123; //如果找到了对应Tree2的根节点的点 if(root1.val == root2.val)&#123; //以这个根节点为为起点判断是否包含Tree2 result = doesTree1HaveTree2(root1,root2); &#125; //如果找不到，那么就再去root的左儿子当作起点，去判断时候包含Tree2 if (!result) &#123; result = HasSubtree(root1.left,root2); &#125; //如果还找不到，那么就再去root的右儿子当作起点，去判断时候包含Tree2 if (!result) &#123; result = HasSubtree(root1.right,root2); &#125; &#125; //返回结果 return result; &#125; public static boolean doesTree1HaveTree2(TreeNode node1, TreeNode node2) &#123; //如果Tree2已经遍历完了都能对应的上，返回true if (node2 == null) &#123; return true; &#125; //如果Tree2还没有遍历完，Tree1却遍历完了。返回false if (node1 == null) &#123; return false; &#125; //如果其中有一个点没有对应上，返回false if (node1.val != node2.val) &#123; return false; &#125; //如果根节点对应的上，那么就分别去子节点里面匹配 return doesTree1HaveTree2(node1.left,node2.left) &amp;&amp; doesTree1HaveTree2(node1.right,node2.right); &#125; 第十八题题目：操作给定的二叉树，将其变换为源二叉树的镜像 1234567891011121314151617181920212223242526/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public void Mirror(TreeNode root) &#123; if(root == null) return; if(root.left == null &amp;&amp; root.right == null) return; TreeNode temp = root.left; root.left = root.right; root.right = temp; if(root.left != null) Mirror(root.left); if(root.right != null) Mirror(root.right); &#125;&#125; 第十九题题目：两个链表的第一个公共节点 12345678910111213141516171819202122232425262728293031/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*///定义两个起始位置为头结点的指针,p1指在较短链表上,p2指在较长链表上//让这p1,p2同时next,当p1到达链表尾部时,让p1指向较长链表的头部//当p2到达链表尾部时,让p2指向较短链表头部//当它们指向同一个节点时,该节点就是两个链表的第一个公共节点public class Solution &#123; public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; ListNode p1 = pHead1; ListNode p2 = pHead2; while(p1 != p2)&#123; if(p1 != null) p1 = p1.next; if(p2 != null) p2 = p2.next; if(p1 != p2)&#123; if(p1 == null) p1 = pHead2; if(p2 == null) p2 = pHead1; &#125; &#125; return p1; &#125;&#125; 第二十题题目：给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 思路：快慢指针法 12345678910111213141516171819202122232425262728293031323334353637/* public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; ListNode EntryNodeOfLoop(ListNode pHead)&#123; //判断是否为链表,不是直接返回null if(pHead == null || pHead.next == null) return null; //定意两个快慢指针 ListNode m = pHead.next; ListNode k = pHead.next.next; //进行指针前进 while(m != k)&#123; if(k != null &amp;&amp; k.next != null)&#123; m = m.next; k = k.next.next; &#125; else&#123; return null; &#125; &#125; //当快慢指针指向同一个节点时,跳出while循环 k = pHead; while(m != k)&#123; m = m.next; k = k.next; &#125; return m; &#125;&#125; 第二十一题题目: 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.holicCode;import java.util.ArrayList;public class Solution &#123; public static ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (matrix == null || matrix.length == 0) &#123; return list; &#125; int up = 0; int down = matrix.length - 1; int left = 0; int right = matrix[0].length - 1; while (true) &#123; // 向右 for (int i = left; i &lt;= right; i++) &#123; list.add(matrix[up][i]); &#125; if (++up &gt; down) &#123; break; &#125; // 向下 for (int i = up; i &lt;= down; i++) &#123; list.add(matrix[i][right]); &#125; if (--right &lt; left) &#123; break; &#125; // 向左 for (int i = right; i &gt;= left; i--) &#123; list.add(matrix[down][i]); &#125; if (--down &lt; up) &#123; break; &#125; // 向上 for (int i = down; i &gt;= up; i--) &#123; list.add(matrix[i][left]); &#125; if (++left &gt; right) &#123; break; &#125; &#125; return list; &#125; //测试 public static void main(String[] args) &#123; int[][] matrix = &#123;&#123;1&#125;,&#123;2&#125;,&#123;3&#125;,&#123;4&#125;,&#123;5&#125;&#125;; System.out.println(printMatrix(matrix)); &#125;&#125; 未完,待续……….]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指offer, 算法, 详解</tag>
      </tags>
  </entry>
</search>

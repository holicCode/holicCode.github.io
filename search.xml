<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F08%2FHTML%26CSS%26jQuery%2F</url>
    <content type="text"><![CDATA[title:HTML&amp;CSS&amp;jQuerytags:HTML,CSS,jQuery categories:HTML,CSS,jQuery一、HTML1. 概念是最基础的网页开发语言 * Hyper Text Markup Language 超文本标记语言 * 超文本: * 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本. * 标记语言: * 由标签构成的语言。&lt;标签名称&gt; 如 html，xml * 标记语言不是编程语言 2. 快速入门 语法： 1. html文档后缀名 .html 或者 .htm 2. 标签分为 1. 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt; 2. 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt; 3. 标签可以嵌套： 需要正确嵌套，不能你中有我，我中有你 错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt; 正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt; 4. 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来 5. html的标签不区分大小写，但是建议使用小写。 代码： 12345678910111213&lt;html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;FONT color='red'&gt;Hello World&lt;/font&gt;&lt;br/&gt; &lt;font color='green'&gt;Hello World&lt;/font&gt; &lt;/body&gt;&lt;/html&gt; 3. 标签12345678910111213141516171819202122232425262728293031323334353637381. 文件标签：构成html最基本的标签 * html:html文档的根标签 * head：头标签。用于指定html文档的一些属性。引入外部的资源 * title：标题标签。 * body：体标签 * &lt;!DOCTYPE html&gt;：html5中定义该文档是html文档2. 文本标签：和文本有关的标签 * 注释：&lt;!-- 注释内容 --&gt; * &lt;h1&gt; to &lt;h6&gt;：标题标签 * h1~h6:字体大小逐渐递减 * &lt;p&gt;：段落标签 * &lt;br&gt;：换行标签 * &lt;hr&gt;：展示一条水平线 * 属性： * color：颜色 * width：宽度 * size：高度 * align：对其方式 * center：居中 * left：左对齐 * right：右对齐 * &lt;b&gt;：字体加粗 * &lt;i&gt;：字体斜体 * &lt;font&gt;:字体标签 * &lt;center&gt;:文本居中 * 属性： * color：颜色 * size：大小 * face：字体 * 属性定义： * color： 1. 英文单词：red,green,blue 2. rgb(值1，值2，值3)：值的范围：0~255 如 rgb(0,0,255) 3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF * width： 1. 数值：width='20' ,数值的单位，默认是 px(像素) 2. 数值%：占比相对于父元素的比例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677783. 图片标签： * img：展示图片 * 属性： * src：指定图片的位置 * 代码： &lt;!--展示一张图片 img--&gt; &lt;img src="image/jingxuan_2.jpg" align="right" alt="古镇" width="500" height="500"/&gt; &lt;!-- 相对路径 * 以.开头的路径 * ./：代表当前目录 ./image/1.jpg * ../:代表上一级目录 --&gt; &lt;img src="./image/jiangwai_1.jpg"&gt; &lt;img src="../image/jiangwai_1.jpg"&gt; 4. 列表标签： * 有序列表： * ol: * li: * 无序列表： * ul: * li: 5. 链接标签： * a:定义一个超链接 * 属性： * href：指定访问资源的URL(统一资源定位符) * target：指定打开资源的方式 * _self:默认值，在当前页面打开 * _blank：在空白页面打开 * 代码： &lt;!--超链接 a--&gt; &lt;a href="http://www.itcast.cn"&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href="http://www.itcast.cn" target="_self"&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href="http://www.itcast.cn" target="_blank"&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href="./5_列表标签.html"&gt;列表标签&lt;/a&gt;&lt;br&gt; &lt;a href="mailto:itcast@itcast.cn"&gt;联系我们&lt;/a&gt; &lt;br&gt; &lt;a href="http://www.itcast.cn"&gt;&lt;img src="image/jiangwai_1.jpg"&gt;&lt;/a&gt; 6. div和span： * div:每一个div占满一整行。块级标签 * span：文本信息在一行展示，行内标签 内联标签 7. 语义化标签：html5中为了提高程序的可读性，提供了一些标签。 1. &lt;header&gt;：页眉 2. &lt;footer&gt;：页脚 8. 表格标签： * table：定义表格 * width：宽度 * border：边框 * cellpadding：定义内容和单元格的距离 * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、 * bgcolor：背景色 * align：对齐方式 * tr：定义行 * bgcolor：背景色 * align：对齐方式 * td：定义单元格 * colspan：合并列 * rowspan：合并行 * th：定义表头单元格 * &lt;caption&gt;：表格标题 * &lt;thead&gt;：表示表格的头部分 * &lt;tbody&gt;：表示表格的体部分 * &lt;tfoot&gt;：表示表格的脚部分 二、CSS：页面美化和布局控制1234567891. 概念： Cascading Style Sheets 层叠样式表 * 层叠：多个样式可以作用在同一个html的元素上，同时生效2. 好处： 1. 功能强大 2. 将内容展示和样式控制分离 * 降低耦合度。解耦 * 让分工协作更容易 * 提高开发效率 12345678910111213141516171819202122232425262728293031323334353637383940414243443. CSS的使用：CSS与html结合方式 1. 内联样式 * 在标签内使用style属性指定css代码 * 如：&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt; 2. 内部样式 * 在head标签内，定义style标签，style标签的标签体内容就是css代码 * 如： &lt;style&gt; div&#123; color:blue; &#125; &lt;/style&gt; &lt;div&gt;hello css&lt;/div&gt; 3. 外部样式 1. 定义css资源文件。 2. 在head标签内，定义link标签，引入外部的资源文件 * 如： * a.css文件： div&#123; color:green; &#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt; &lt;div&gt;hello css&lt;/div&gt; &lt;div&gt;hello css&lt;/div&gt; * 注意： * 1,2,3种方式 css作用范围越来越大 * 1方式不常用，后期常用2,3 * 3种格式可以写为： &lt;style&gt; @import &quot;css/a.css&quot;; &lt;/style&gt;4. css语法： * 格式： 选择器 &#123; 属性名1:属性值1; 属性名2:属性值2; ... &#125; * 选择器:筛选具有相似特征的元素 * 注意： * 每一对属性需要使用；隔开，最后一对属性可以不加； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555. 选择器：筛选具有相似特征的元素 * 分类： 1. 基础选择器 1. id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一 * 语法：#id属性值&#123;&#125; 2. 元素选择器：选择具有相同标签名称的元素 * 语法： 标签名称&#123;&#125; * 注意：id选择器优先级高于元素选择器 3. 类选择器：选择具有相同的class属性值的元素。 * 语法：.class属性值&#123;&#125; * 注意：类选择器选择器优先级高于元素选择器 2. 扩展选择器： 1. 选择所有元素： * 语法： *&#123;&#125; 2. 并集选择器： * 选择器1,选择器2&#123;&#125; 3. 子选择器：筛选选择器1元素下的选择器2元素 * 语法： 选择器1 选择器2&#123;&#125; 4. 父选择器：筛选选择器2的父元素选择器1 * 语法： 选择器1 &gt; 选择器2&#123;&#125; 5. 属性选择器：选择元素名称，属性名=属性值的元素 * 语法： 元素名称[属性名=&quot;属性值&quot;]&#123;&#125; 6. 伪类选择器：选择一些元素具有的状态 * 语法： 元素:状态&#123;&#125; * 如： &lt;a&gt; * 状态： * link：初始化的状态 * visited：被访问过的状态 * active：正在访问状态 * hover：鼠标悬浮状态6. 属性 1. 字体、文本 * font-size：字体大小 * color：文本颜色 * text-align：对其方式 * line-height：行高 2. 背景 * background： 3. 边框 * border：设置边框，符合属性 4. 尺寸 * width：宽度 * height：高度 5. 盒子模型：控制布局 * margin：外边距 * padding：内边距 * 默认情况下内边距会影响整个盒子的大小 * box-sizing: border-box; 设置盒子的属性，让width和height就是最终盒子的大小 * float：浮动 * left * right 三、jQuery1. jQuery基础1234567891011121314151617181920212223241. 概念： 一个JavaScript框架。简化JS开发 * jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨 是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优 化HTML文档操作、事件处理、动画设计和Ajax交互。 * JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已2. 快速入门 1. 步骤： 1. 下载JQuery * 目前jQuery有三个大版本： 1.x：兼容ie678,使用最为广泛的，官方只做BUG维护， 功能不再新增。因此一般项目来说，使用1.x版本就可以了， 最终版本：1.12.4 (2016年5月20日) 2.x：不兼容ie678，很少有人使用，官方只做BUG维护， 功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x， 最终版本：2.2.4 (2016年5月20日) 3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求， 一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。 目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日） * jquery-xxx.js 与 jquery-xxx.min.js区别： 1. jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些 2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快 2. 导入JQuery的js文件：导入min.js文件 3. 使用 var div1 = $(&quot;#div1&quot;); 1234563. JQuery对象和JS对象区别与转换 1. JQuery对象在操作时，更加方便。 2. JQuery对象和js对象方法不通用的. 3. 两者相互转换 * jq -- &gt; js : jq对象[索引] 或者 jq对象.get(索引) * js -- &gt; jq : $(js对象) 1234567891011121314151617184. 选择器：筛选具有相似特征的元素(标签) 1. 基本操作学习： 1. 事件绑定 //1.获取b1按钮 $(&quot;#b1&quot;).click(function()&#123; alert(&quot;abc&quot;); &#125;); 2. 入口函数 $(function () &#123; &#125;); window.onload 和 $(function) 区别 * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉 * $(function)可以定义多次的。 3. 样式控制：css方法 // $(&quot;#div1&quot;).css(&quot;background-color&quot;,&quot;red&quot;); $(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 2. 分类 1. 基本选择器 1. 标签选择器（元素选择器） * 语法： $(&quot;html标签名&quot;) 获得所有匹配标签名称的元素 2. id选择器 * 语法： $(&quot;#id的属性值&quot;) 获得与指定id属性值匹配的元素 3. 类选择器 * 语法： $(&quot;.class的属性值&quot;) 获得与指定的class属性值匹配的元素 4. 并集选择器： * 语法： $(&quot;选择器1,选择器2....&quot;) 获取多个选择器选中的所有元素 2. 层级选择器 1. 后代选择器 * 语法： $(&quot;A B &quot;) 选择A元素内部的所有B元素 2. 子选择器 * 语法： $(&quot;A &gt; B&quot;) 选择A元素内部的所有B子元素 3. 属性选择器 1. 属性名称选择器 * 语法： $(&quot;A[属性名]&quot;) 包含指定属性的选择器 2. 属性选择器 * 语法： $(&quot;A[属性名=&apos;值&apos;]&quot;) 包含指定属性等于指定值的选择器 3. 复合属性选择器 * 语法： $(&quot;A[属性名=&apos;值&apos;][]...&quot;) 包含多个属性条件的选择器 4. 过滤选择器 1. 首元素选择器 * 语法： :first 获得选择的元素中的第一个元素 2. 尾元素选择器 * 语法： :last 获得选择的元素中的最后一个元素 3. 非元素选择器 * 语法： :not(selector) 不包括指定内容的元素 4. 偶数选择器 * 语法： :even 偶数，从 0 开始计数 5. 奇数选择器 * 语法： :odd 奇数，从 0 开始计数 6. 等于索引选择器 * 语法： :eq(index) 指定索引元素 7. 大于索引选择器 * 语法： :gt(index) 大于指定索引元素 8. 小于索引选择器 * 语法： :lt(index) 小于指定索引元素 9. 标题选择器 * 语法： :header 获得标题（h1~h6）元素，固定写法 5. 表单过滤选择器 1. 可用元素选择器 * 语法： :enabled 获得可用元素 2. 不可用元素选择器 * 语法： :disabled 获得不可用元素 3. 选中选择器 * 语法： :checked 获得单选/复选框选中的元素 4. 选中选择器 * 语法： :selected 获得下拉框选中的元素5. DOM操作 1. 内容操作 1. html(): 获取/设置元素的标签体内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; &lt;font&gt;内容&lt;/font&gt; 2. text(): 获取/设置元素的标签体纯文本内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容 3. val()： 获取/设置元素的value属性值 2. 属性操作 1. 通用属性操作 1. attr(): 获取/设置元素的属性 2. removeAttr():删除属性 3. prop():获取/设置元素的属性 4. removeProp():删除属性 * attr和prop区别？ 1. 如果操作的是元素的固有属性，则建议使用prop 2. 如果操作的是元素自定义的属性，则建议使用attr 2. 对class属性操作 1. addClass():添加class属性值 2. removeClass():删除class属性值 3. toggleClass():切换class属性 * toggleClass(&quot;one&quot;): * 判断如果元素对象上存在class=&quot;one&quot;，则将属性值one删除掉。 如果元素对象上不存在class=&quot;one&quot;，则添加 4. css(): 3. CRUD操作: 1. append():父元素将子元素追加到末尾 * 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾 2. prepend():父元素将子元素追加到开头 * 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头 3. appendTo(): * 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾 4. prependTo()： * 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头 123456789101112135. after():添加元素到元素后边 * 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系6. before():添加元素到元素前边 * 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系7. insertAfter() * 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系8. insertBefore() * 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系9. remove():移除元素 * 对象.remove():将对象删除掉10. empty():清空元素的所有后代元素。 * 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点 2. jQuery高级12345678910111213141516171819202122231. 动画 1. 三种方式显示和隐藏元素 1. 默认显示和隐藏方式 1. show([speed,[easing],[fn]]) 1. 参数： 1. speed：动画的速度。三个预定义的值(&quot;slow&quot;,&quot;normal&quot;, &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000) 2. easing：用来指定切换效果，默认是&quot;swing&quot;，可用参数&quot;linear&quot; * swing：动画执行时效果是 先慢，中间快，最后又慢 * linear：动画执行时速度是匀速的 3. fn：在动画完成时执行的函数，每个元素执行一次。 2. hide([speed,[easing],[fn]]) 3. toggle([speed],[easing],[fn]) 2. 滑动显示和隐藏方式 1. slideDown([speed],[easing],[fn]) 2. slideUp([speed,[easing],[fn]]) 3. slideToggle([speed],[easing],[fn]) 3. 淡入淡出显示和隐藏方式 1. fadeIn([speed],[easing],[fn]) 2. fadeOut([speed],[easing],[fn]) 3. fadeToggle([speed,[easing],[fn]]) 1234567891011121314151617181920212223242526272829303132332. 遍历 1. js的遍历方式 * for(初始化值;循环结束条件;步长) 2. jq的遍历方式 1. jq对象.each(callback) 1. 语法： jquery对象.each(function(index,element)&#123;&#125;); * index:就是元素在集合中的索引 * element：就是集合中的每一个元素对象 * this：集合中的每一个元素对象 2. 回调函数返回值： * true:如果当前function返回为false，则结束循环(break)。 * false:如果当前function返回为true，则结束本次循环，继续下次循环(continue) 2. $.each(object, [callback]) 3. for..of: jquery 3.0 版本之后提供的方式 for(元素对象 of 容器对象) 3. 事件绑定 1. jquery标准的绑定方式 * jq对象.事件方法(回调函数)； * 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。 * 表单对象.submit();//让表单提交 2. on绑定事件/off解除绑定 * jq对象.on(&quot;事件名称&quot;,回调函数) * jq对象.off(&quot;事件名称&quot;) * 如果off方法不传递任何参数，则将组件上的所有事件全部解绑 3. 事件切换：toggle * jq对象.toggle(fn1,fn2...) * 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2..... * 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。 &lt;script src=&quot;../js/jquery-migrate-1.0.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424. 案例 1. 广告显示和隐藏 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;广告的自动显示与隐藏&lt;/title&gt; &lt;style&gt; #content&#123;width:100%;height:500px;background:#999&#125; &lt;/style&gt; &lt;!--引入jquery--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; /* 需求： 1. 当页面加载完，3秒后。自动显示广告 2. 广告显示5秒后，自动消失。 分析： 1. 使用定时器来完成。setTimeout (执行一次定时器) 2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display 3. 使用 show/hide方法来完成广告的显示 */ //入口函数，在页面加载完成之后，定义定时器，调用这两个方法 $(function () &#123; //定义定时器，调用adShow方法 3秒后执行一次 setTimeout(adShow,3000); //定义定时器，调用adHide方法，8秒后执行一次 setTimeout(adHide,8000); &#125;); //显示广告 function adShow() &#123; //获取广告div，调用显示方法 $(&quot;#ad&quot;).show(&quot;slow&quot;); &#125; //隐藏广告 function adHide() &#123; //获取广告div，调用隐藏方法 $(&quot;#ad&quot;).hide(&quot;slow&quot;); &#125; 1234567891011121314151617 &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 整体的DIV --&gt;&lt;div&gt; &lt;!-- 广告DIV --&gt; &lt;div id=&quot;ad&quot; style=&quot;display: none;&quot;&gt; &lt;img style=&quot;width:100%&quot; src=&quot;../img/adv.jpg&quot; /&gt; &lt;/div&gt; &lt;!-- 下方正文部分 --&gt; &lt;div id=&quot;content&quot;&gt; 正文部分 &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516172. 抽奖 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;jquery案例之抽奖&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script language=&apos;javascript&apos; type=&apos;text/javascript&apos;&gt; /* 分析： 1. 给开始按钮绑定单击事件 1.1 定义循环定时器 1.2 切换小相框的src属性 * 定义数组，存放图片资源路径 * 生成随机数。数组索引 12345678910111213141516171819 2. 给结束按钮绑定单击事件 1.1 停止定时器 1.2 给大相框设置src属性 */var imgs = [&quot;../img/man00.jpg&quot;, &quot;../img/man01.jpg&quot;, &quot;../img/man02.jpg&quot;, &quot;../img/man03.jpg&quot;, &quot;../img/man04.jpg&quot;, &quot;../img/man05.jpg&quot;, &quot;../img/man06.jpg&quot;, ];var startId;//开始定时器的idvar index;//随机角标$(function () &#123; //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true); 1234567//1. 给开始按钮绑定单击事件 $(&quot;#startID&quot;).click(function () &#123; // 1.1 定义循环定时器 20毫秒执行一次 startId = setInterval(function () &#123; //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,true); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,false); 1234567 //1.2生成随机角标 0-6 index = Math.floor(Math.random() * 7);//0.000--0.999 --&gt; * 7 --&gt; 0.0-----6.9999 //1.3设置小相框的src属性 $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]); &#125;,20);&#125;); 12345//2. 给结束按钮绑定单击事件$(&quot;#stopID&quot;).click(function () &#123; //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true); 12345678 // 1.1 停止定时器 clearInterval(startId); // 1.2 给大相框设置src属性 $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]).hide(); //显示1秒之后 $(&quot;#img2ID&quot;).show(1000); &#125;);&#125;); 1234567891011121314151617181920212223242526272829 &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 小像框 --&gt;&lt;div style=&quot;border-style:dotted;width:160px;height:100px&quot;&gt; &lt;img id=&quot;img1ID&quot; src=&quot;../img/man00.jpg&quot; style=&quot;width:160px;height:100px&quot;/&gt;&lt;/div&gt;&lt;!-- 大像框 --&gt;&lt;div style=&quot;border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px&quot;&gt; &lt;img id=&quot;img2ID&quot; src=&quot;../img/man00.jpg&quot; width=&quot;800px&quot; height=&quot;500px&quot;/&gt;&lt;/div&gt;&lt;!-- 开始按钮 --&gt;&lt;input id=&quot;startID&quot; type=&quot;button&quot; value=&quot;点击开始&quot; style=&quot;width:150px;height:150px;font-size:22px&quot;&gt;&lt;!-- 停止按钮 --&gt;&lt;input id=&quot;stopID&quot; type=&quot;button&quot; value=&quot;点击停止&quot; style=&quot;width:150px;height:150px;font-size:22px&quot;&gt; 123456789 &lt;/body&gt; &lt;/html&gt;5. 插件：增强JQuery的功能 1. 实现方式： 1. $.fn.extend(object) * 增强通过Jquery获取的对象的功能 $(&quot;#id&quot;) 2. $.extend(object) * 增强JQeury对象自身的功能 $/jQuery]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F08%2FAJAX%26JSON%2F</url>
    <content type="text"><![CDATA[title:AJAX&amp;JSONtags:AJAX，JSON categories:AJAX,JSONAJAX：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586871. 概念： ASynchronous JavaScript And XML 异步的JavaScript 和 XML 1. 异步和同步：客户端和服务器端相互通信的基础上 * 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 * 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1] 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 提升用户的体验2. 实现方式： 1. 原生的JS实现方式（了解） //1.创建核心对象 var xmlhttp; if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125; else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; //2. 建立连接 /* 参数： 1. 请求方式：GET、POST * get方式，请求参数在URL后边拼接。send方法为空参 * post方式，请求参数在send方法中定义 2. 请求的URL： 3. 同步或异步请求：true（异步）或 false（同步） */ xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username=tom&quot;,true); //3.发送请求 xmlhttp.send(); //4.接受并处理来自服务器的响应结果 //获取方式 ：xmlhttp.responseText //什么时候获取？当服务器响应成功后再获取 //当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。 xmlhttp.onreadystatechange=function() &#123; //判断readyState就绪状态是否为4，判断status响应状态码是否为200 if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; //获取服务器的响应结果 var responseText = xmlhttp.responseText; alert(responseText); &#125; &#125; 2. JQeury实现方式 1. $.ajax() * 语法：$.ajax(&#123;键值对&#125;); //使用$.ajax()发送异步请求 $.ajax(&#123; url:&quot;ajaxServlet1111&quot; , // 请求路径 type:&quot;POST&quot; , //请求方式 //data: &quot;username=jack&amp;age=23&quot;,//请求参数 data:&#123;&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:23&#125;, success:function (data) &#123; alert(data); &#125;,//响应成功后的回调函数 error:function () &#123; alert(&quot;出错啦...&quot;) &#125;,//表示如果请求响应出现错误，会执行的回调函数 dataType:&quot;text&quot;//设置接受到的响应数据的格式 &#125;); 2. $.get()：发送get请求 * 语法：$.get(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 3. $.post()：发送post请求 * 语法：$.post(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 JSON：123456789101112131415161718192021222324252627282930313233343536371. 概念： JavaScript Object Notation JavaScript对象表示法 Person p = new Person(); p.setName(&quot;张三&quot;); p.setAge(23); p.setGender(&quot;男&quot;); var p = &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;&#125;; * json现在多用于存储和交换文本信息的语法 * 进行数据的传输 * JSON 比 XML 更小、更快，更易解析。2. 语法： 1. 基本规则 * 数据在名称/值对中：json数据是由键值对构成的 * 键用引号(单双都行)引起来，也可以不使用引号 * 值得取值类型： 1. 数字（整数或浮点数） 2. 字符串（在双引号中） 3. 逻辑值（true 或 false） 4. 数组（在方括号中） &#123;&quot;persons&quot;:[&#123;&#125;,&#123;&#125;]&#125; 5. 对象（在花括号中） &#123;&quot;address&quot;:&#123;&quot;province&quot;：&quot;陕西&quot;....&#125;&#125; 6. null * 数据由逗号分隔：多个键值对由逗号分隔 * 花括号保存对象：使用&#123;&#125;定义json 格式 * 方括号保存数组：[] 2. 获取数据: 1. json对象.键名 2. json对象[&quot;键名&quot;] 3. 数组对象[索引] 4. 遍历 //1.定义基本格式 var person = &#123;&quot;name&quot;: &quot;张三&quot;, age: 23, &apos;gender&apos;: true&#125;; var ps = [&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;gender&quot;: false&#125;]; ​​​ 123456789101112131415 //获取person对象中所有的键和值 //for in 循环/* for(var key in person)&#123; //这样的方式获取不行。因为相当于 person.&quot;name&quot; //alert(key + &quot;:&quot; + person.key); alert(key+&quot;:&quot;+person[key]); &#125;*/ //获取ps中的所有值 for (var i = 0; i &lt; ps.length; i++) &#123; var p = ps[i]; for(var key in p)&#123; alert(key+&quot;:&quot;+p[key]); &#125; &#125; 123456789101112131415161718192021222324252627282930313. JSON数据和Java对象的相互转换 * JSON解析器： * 常见的解析器：Jsonlib，Gson，fastjson，jackson 1. JSON转为Java对象 1. 导入jackson的相关jar包 2. 创建Jackson核心对象 ObjectMapper 3. 调用ObjectMapper的相关方法进行转换 1. readValue(json字符串数据,Class) 2. Java对象转换JSON 1. 使用步骤： 1. 导入jackson的相关jar包 2. 创建Jackson核心对象 ObjectMapper 3. 调用ObjectMapper的相关方法进行转换 1. 转换方法： * writeValue(参数1，obj): 参数1： File：将obj对象转换为JSON字符串，并保存到指定的文件中 Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中 OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中 * writeValueAsString(obj):将对象转为json字符串 2. 注解： 1. @JsonIgnore：排除属性。 2. @JsonFormat：属性值得格式化 * @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;) 3. 复杂java对象转换 1. List：数组 2. Map：对象格式一致 案例：12345* 校验用户名是否存在 1. 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案： 1. $.get(type):将最后一个参数type指定为&quot;json&quot; 2. 在服务器端设置MIME类型 response.setContentType(&quot;application/json;charset=utf-8&quot;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[Maven的相关知识]]></title>
    <url>%2F2019%2F08%2F01%2FMaven%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Maven的使用什么是Maven?1Maven 是一个项目管理工具，它包含了一个项目对象模型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。 Maven的作用Maven的依赖管理1Maven 的一个核心特性就是依赖管理。当我们涉及到多模块的项目（包含成百个模块或者子项目），管理依赖就变成一项困难的任务。Maven 展示出了它对处理这种情形的高度控制。 1maven 工程中不直接将 jar 包导入到工程中，而是通过在 pom.xml 文件中添加所需 jar包的坐标，这样就很好的避免了 jar 直接引入进来，在需要用到 jar 包的时候，只要查找 pom.xml 文件，再通过 pom.xml 文件中的坐标，到一个专门用于”存放 jar 包的仓库”(maven 仓库)中根据坐标从而找到这些 jar 包，再把这些 jar 包拿去运行。 项目的一键构建12什么是构建？指的是项目从编译、测试、运行、打包、安装 ，部署整个过程都交给 maven 进行管理，这个过程称为构建。一键构建指的是整个构建过程，使用 maven 一个命令可以轻松完成整个工作。 1通过 tomcat:run 的这个命令，我们发现现在的工程编译，测试，运行都变得非常简单。 Maven仓库Maven仓库的分类 12345本地仓库 ：用来存储从远程仓库或中央仓库下载的插件和 jar 包，项目使用一些插件或 jar 包，优先从本地仓库查找默认本地仓库位置在 $&#123;user.dir&#125;/.m2/repository，$&#123;user.dir&#125;表示 windows 用户目录。远程仓库：如果本地需要插件或者 jar 包，本地仓库没有，默认去远程仓库下载。远程仓库可以在互联网内也可以在局域网内。中央仓库 ：在 maven 软件中内置一个远程仓库地址 http://repo1.maven.org/maven2 ，它是中央仓库，服务于整个互联网，它是由 Maven 团队自己维护，里面存储了非常全的 jar 包，它包含了世界上大部分流行的开源项目构件。 Maven工程的认识Maven工程的目录结构 1作为一个 maven 工程，它的 src 目录和 pom.xml 是必备的。进入 src 目录后，我们发现它里面的目录结构如下： 1234567src/main/java —— 存放项目的.java 文件src/main/resources —— 存放项目资源文件，如 spring, hibernate 配置文件src/test/java —— 存放所有单元测试.java 文件，如 JUnit 测试类src/test/resources —— 测试资源文件target —— 项目输出位置，编译后的 class 文件会输出到此目录pom.xml——maven 项目核心配置文件注意：如果是普通的 java 项目，那么就没有 webapp 目录。 Maven工程的运行1进入 maven 工程目录（当前目录有 pom.xml 文件），运行 tomcat:run 命令。 Maven常用命令compile1compile 是 maven 工程的编译命令，作用是将 src/main/java 下的文件编译为 class 文件输出到 target目录下。 test1test 是 maven 工程的测试命令 mvn test，会执行 src/test/java 下的单元测试类。 clean1clean 是 maven 工程的清理命令，执行 clean 会删除 target 目录及内容。 package1package 是 maven 工程的打包命令，对于 java 工程执行 package 打成 jar 包，对于 web 工程打成 war包。 install1install 是 maven 工程的安装命令，执行 install 将 maven 打成 jar 包或 war 包发布到本地仓库。 Maven指令的生命周期1234maven 对项目构建过程分为三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，这三套生命周期分别是：Clean Lifecycle 在进行真正的构建之前进行一些清理工作。Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。Site Lifecycle 生成项目报告，站点，发布站点。 pom的基本配置1234567891011pom.xml 是 Maven 项目的核心配置文件，位于每个工程的根目录，基本配置如下：&lt;project &gt; ：文件的根节点 .&lt;modelversion &gt; ： pom.xml 使用的对象模型版本&lt;groupId &gt; ：项目名称，一般写项目的域名&lt;artifactId &gt; ：模块名称，子项目名或模块名称&lt;version &gt; ：产品的版本号 .&lt;packaging &gt; ：打包类型，一般有 jar、war、pom 等&lt;name &gt; ：项目的显示名，常用于 Maven 生成的文档。&lt;description &gt; ：项目描述，常用于 Maven 生成的文档&lt;dependencies&gt; ：项目依赖构件配置，配置项目依赖构件的坐标&lt;build&gt; ：项目构建配置，配置编译、运行插件等。]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有关MySQL的几道必会面试题]]></title>
    <url>%2F2019%2F07%2F27%2F%E6%9C%89%E5%85%B3MySQL%E7%9A%84%E5%87%A0%E9%81%93%E5%BF%85%E4%BC%9A%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[MySQL必会知识点说说你对与MySQL常见的两种存储引擎：MyISAM与InnoDB的理解12345关于二者的对比与总结：1.count运算上的区别：因为MyISAM缓存有表meta-data（行数等），因此在做COUNT（*）时对于一个结构很好的查询时不需要消耗多少资源的。而对于InnoDB来说，则没有这种缓存。2.是否支持事务和崩溃后的安全恢复：MyISAM强调的是性能，每次查询具有原子性，其执行行速度比InnoDB类型更快，但是不支持事务。但是InnoDB提供事务的支持，外键等高级数据库功能。具有事务提交（commit）、回滚（rollback）和崩溃修复能力的事务安全（ACID）型表。MyISAM更适合读密集的表，而InnoDB更适合写密集的表。在数据库做主从分离的情况下，经常选择MyISAM做为主库的存储引擎。一般来说，如果需要事务支持，并且有较高的并发读取频率(MyISAM的表锁的粒度太大，所以当该表写并发量较高时，要等待的查询就会很多了)，InnoDB是不错的选择。如果你的数据量很大（MyISAM支持压缩特性可以减少磁盘的空间占用），而且不需要支持事务时，MyISAM是最好的选择。 为什么要用 ORM? 和 JDBC 有何不一样?12orm是一种思想，就是把object转变成数据库中的记录，或者把数据库中的记录转变成object，我们可以用jdbc来实现这种思想，其实，如果我们的项目是严格按照oop方式编写的话，我们的jdbc程序不管是有意还是无意，就已经在实现orm的工作了。现在有许多orm工具，它们底层调用jdbc来实现了orm工作，我们直接使用这些工具，就省去了直接使用jdbc的繁琐细节，提高了开发效率，现在用的较多的orm工具是hibernate。也听说一些其他orm工具，如toplink,ojb等。 存储过程与触发器的区别？123触发器与存储过程非常相似，触发器也是SQL语句集，两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发（激活）执行。触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。触发器不同于存储过程，触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如UPDATE、INSERT、DELETE这些操作时，SQLSERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。 Mysql如何为表字段添加索引？？？1.添加PRIMARY KEY（主键索引） ALTER TABLE table_name ADD PRIMARY KEY ( column ) 2.添加UNIQUE(唯一索引) ALTER TABLE table_name ADD UNIQUE ( column ) 3.添加INDEX(普通索引) ALTER TABLE table_name ADD INDEX index_name ( column ) 4.添加FULLTEXT(全文索引) ALTER TABLE table_name ADD FULLTEXT ( column) 5.添加多列索引 ALTER TABLE table_name ADD INDEX index_name ( column1, column2, column3 ) 为什么要使用索引?123451.通过创建唯一性索引，可以保证数据库中每一行的数据的唯一性2.可以大大加快数据的检索速度（大大减少了检索的数据量），这也是创建索引的最主要的原因3.帮助服务器避免排序和临时表4.将随机IO变为顺序IO5.可以加快表与表之间的连接，特别是在实现数据的参考完整性方面有特别的意义 索引这么多优点，为什么不对表中的每一个列创建一个索引？1231.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚集索引，那么需要的空间就会更大3.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加 索引是如何提高查询速度的？1将无序的数据变成相对有序的数据（就像查目录一样） 使用索引的注意事项12345678910111.在经常需要搜索的列上，可以加快搜索的速度2.在经常使用在where子句中的列上面创建索引，加快条件的判断速度3.在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序的查询时间4.对于中、大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引5.在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度6.避免where子句中对字段施加函数这回造成无法命中索引7.在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键8.将打算加索引的列设置为NOT NULL，否则将导致引擎放弃使用索引而进行全表扫描9.删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗——MySQL5.7可以通过查询sys库的chema_unused_indexes视图来查询那些索引从未被使用10.在使用limit offset查询缓存时,可以借助索引来提高性能 MySQL索引主要使用的两个数据结构123451.哈希索引对于哈希索引来说,底层的数据结构就是哈希表,因此在绝大多数需求为单条记录查询的时候,可以选择哈希索引,查询性能最快;其余大部分场景,建议选择BTree索引2.BTree索引MySQL的BTree索引使用的是B树中的B+Tree。但对于主要的两种存储（MyISAM和InnoDB）的实现方式是不同的 MyISAM和InnoDB实现BTree索引方式的区别123451.MyISAM B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法来搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录。这被称为“非聚集索引”。2.InnoDB 其数据文件本身就是索引文件。相比MyISAM索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。 PS：整理自《Java工程师修炼之道》 覆盖索引123451.什么是覆盖索引 如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！2.覆盖索引使用实例 现在我创建了索引(username,age)，在查询数据的时候：select username , age from user where username = &apos;Java&apos; and age = 22。要查询出的列在叶子节点都存在！所以，就不用回表。 选择索引和编写利用这些索引的查询的3个原则123451. 单行访问是很慢的。特别是在机械硬盘存储中(SSD的随机I/O要快很多，不过这一点仍然成立）。如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建位置引，用以提升效率。2. 按顺序访问范围数据是很快的，这有两个原因。第一，顺序1/0不需要多次磁盘寻道，所以比随机I/O要快很多（特别是对机械硬盘）。第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且GROUPBY查询也无须再做排序和将行按组进行聚合计算了。3. 索引覆盖查询是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就不需要再回表查找行。这避免了大量的单行访问，而上面的第1点已经写明单行访问是很慢的。]]></content>
      <categories>
        <category>面试题, MySQL</category>
      </categories>
      <tags>
        <tag>MySQL, 面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis的相关知识]]></title>
    <url>%2F2019%2F07%2F27%2FRedis%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Redis1.概念：redis是一款高性能的NoSQL系列的非关系型数据库1.1什么是NoSQL123456789101112131415161718192021222324252627281.1.什么是NoSQL NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。1.1.1. NOSQL和关系型数据库比较 优点： 1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点： 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 3）不提供关系型数据库对事务的处理。1.1.2. 非关系型数据库的优势： 1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。1.1.3. 关系型数据库的优势： 1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。1.1.4. 总结 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库， 让NoSQL数据库对关系型数据库的不足进行弥补。 一般会将数据存储在关系型数据库中，在Nosql数据库中备份存储关系型数据库的数据 1.2主流的NoSQL产品123456789101112131415161718192021222324251.2.主流的NOSQL产品• 键值(Key-Value)存储数据库 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化• 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限• 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法• 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 1.3什么是Redis1234567891011121314151.3 什么是Redis Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 1) 字符串类型 string 2) 哈希类型 hash 3) 列表类型 list 4) 集合类型 set 5) 有序集合类型 sortedset1.3.1 redis的应用场景 • 缓存（数据查询、短连接、新闻内容、商品内容等等） • 聊天室的在线好友列表 • 任务队列。（秒杀、抢购、12306等等） • 应用排行榜 • 网站访问统计 • 数据过期处理（可以精确到毫秒） • 分布式集群架构中的session分离 2.关于Redis中的一些操作2.1下载安装1234561. 官网：https://redis.io2. 中文网：http://www.redis.net.cn/3. 解压直接可以使用： * redis.windows.conf：配置文件 * redis-cli.exe：redis的客户端 * redis-server.exe：redis服务器端 2.2命令操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596971. redis的数据结构： * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 * value的数据结构： 1) 字符串类型 string 2) 哈希类型 hash ： map格式 3) 列表类型 list ： linkedlist格式。支持重复元素 4) 集合类型 set ： 不允许重复元素 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 2. 字符串类型 string 1. 存储： set key value 2. 获取： get key 3. 删除： del key3. 哈希类型 hash 1. 存储： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 2. 获取： * hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username &quot;lisi&quot; * hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) &quot;username&quot; 2) &quot;lisi&quot; 3) &quot;password&quot; 4) &quot;123&quot; 3. 删除： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 1 4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 1. 添加： 1. lpush key value: 将元素加入列表左表 2. rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 2. 获取： * lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot; 3. 删除： * lpop key： 删除列表最左边的元素，并将元素返回 * rpop key： 删除列表最右边的元素，并将元素返回5. 集合类型 set ： 不允许重复元素 1. 存储：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 2. 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; 3. 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 16. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 1. 存储：zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 2. 获取：zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) &quot;zhangsan&quot; 2) &quot;60&quot; 3) &quot;wangwu&quot; 4) &quot;80&quot; 5) &quot;lisi&quot; 6) &quot;500&quot; 3. 删除：zrem key value 127.0.0.1:6379&gt; zrem mysort lisi (integer) 17. 通用命令 1. keys * : 查询所有的键 2. type key ： 获取键对应的value的类型 3. del key：删除指定的key value 3.Redis的持久化12345678910111213141516171819202122232425262728293031321. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。2. redis持久化机制： 1. RDB：默认方式，不需要进行配置，默认就使用这种机制 * 在一定的间隔时间中，检测key的变化情况，然后持久化数据 1. 编辑redis.windwos.conf文件 # after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changed save 60 10000 2. 重新启动redis服务器，并指定配置文件名称 redis-2.8.9&gt;redis-server.exe redis.windows.conf 2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 1. 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） # appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 # appendfsync no ： 不进行持久化5. Java客户端 Jedis * Jedis: 一款java操作redis数据库的工具. * 使用步骤： 1. 下载jedis的jar包，并导入工程中 2. 使用 //1. 获取连接 Jedis jedis = new Jedis(&quot;localhost&quot;,6379); //2. 操作 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //3. 关闭连接 jedis.close(); 4.jedis中连接池：jedisPool的使用123456789101112131415161. 创建JedisPool连接池对象 2. 调用方法 getResource()方法获取Jedis连接 //0.创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1.创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379); //2.获取连接 Jedis jedis = jedisPool.getResource(); //3. 使用 jedis.set(&quot;hehe&quot;,&quot;heihei&quot;); //4. 关闭 归还到连接池中 jedis.close(); 5.注意1234* 注意：使用redis，缓存一些不经常发生变化的数据。 * 数据库的数据一旦发生改变，则需要更新缓存。 * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入 * 在service对应的增删改方法中，将redis数据删除。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis, jedis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis的相关知识]]></title>
    <url>%2F2019%2F07%2F26%2FMybatis%2F</url>
    <content type="text"><![CDATA[Mybatis1.Mybatis概述123Mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花精力去处理加载驱动，创建连接，创建statement等繁杂的过程Mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由Mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽jdbc api 底层访问细节，使我们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。 2.搭建Mybatis开发环境2.1创建Maven工程1234创建 mybatis01 的工程，工程信息如下：Groupid:com.holicCodeArtifactId:mybatis01Packing:jar 2.2添加Mybatis3.4.5的坐标在pom.xml文件中添加Mybatis3.4.5的坐标，如下： 123456789101112131415161718192021222324&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.3编写必要代码(实体类和持久层接口)2.4编写SqlMapConfig.xml配置文件12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置 mybatis 的环境 --&gt; &lt;environments default="mysql"&gt; &lt;!-- 配置 mysql 的环境 --&gt; &lt;environment id="mysql"&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置连接数据库的信息：用的是数据源(连接池) --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/student"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt;&lt;!-- 告知 mybatis 映射配置的位置 --&gt;&lt;mappers&gt; &lt;mapper resource="com/holicCode/dao/IUserDao.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.5编写映射配置文件2.6编写测试类3.Mybatis中用到的设计模式123工厂模式（SqlSessionFactory）代理模式(MapperProxyFactory)构建者模式(SqlSessionFactoryBuilder) 4.Mybatis与JDBC编程的比较1234567891011121.数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。解决： 在 SqlMapConfig.xml 中配置数据链接池，使用连接池管理数据库链接。2.Sql 语句写在代码中造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java 代码。解决： 将 Sql 语句配置在 XXXXmapper.xml 文件中与 java 代码分离。3.向 sql 语句传参数麻烦，因为 sql 语句的 where 条件不一定，可能多也可能少，占位符需要和参数对应。解决： Mybatis 自动将 java 对象映射至 sql 语句，通过 statement 中的 parameterType 定义输入参数的类型。4.对结果集解析麻烦，sql 变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成 pojo 对象解析比较方便。解决： Mybatis 自动将 sql 执行结果映射至 java 对象，通过 statement 中的resultType 定义输出结果的类型。 5.当编写的实体类属性名和数据库表的列名不一致时5.1出现的问题12查询出来的结果会都为null有时有可能会出现某一列有值的情况,这是因为MySQL在Windows系统中不区分大小写! 5.2解决方案一12修改映射配置文件给映射配置文件的SQL语句中的列名起别名(该方法当我们查询很多事,都使用的话写起来很麻烦) 5.3解决方案二​ resultMap结果类型 12resultMap 标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。在 select 标签中使用 resultMap 属性指定引用即可。同时 resultMap 可以实现将查询结果映射为复杂类型的 pojo，比如在查询结果映射对象中包括 pojo 和 list 实现一对一查询和一对多查询。 6.Mybatis连接池1Mybatis连接池与web中的连接池不同,Mybatis中的连接池使用的自己的连接池技术,在Mybatis的SqlMapConfig.xml配置文件中,通过&lt;dataSource type=&quot;pooled&quot;&gt;来实现Mybatis中连接池的配置。 6.1Mybatis连接池的分类123UNPOOLED 不使用连接池的数据源POOLED 使用连接池的数据源（我们一般使用的数据源）JNDI 使用JNDI实现的数据源 1相应地，MyBatis 内部分别定义了实现了 java.sql.DataSource 接口的 UnpooledDataSource，PooledDataSource 类来表示 UNPOOLED、POOLED 类型的数据源。 6.2Mybatis中数据源的配置123456789101112数据源配置就是在 SqlMapConfig.xml 文件中，具体配置如下：&lt;!-- 配置数据源（连接池）信息 --&gt;&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/dataSource&gt;MyBatis 在初始化时，根据&lt;dataSource&gt;的 type 属性来创建相应类型的的数据源 DataSource，即：type=”POOLED”：MyBatis 会创建 PooledDataSource 实例type=”UNPOOLED” ： MyBatis 会创建 UnpooledDataSource 实例type=”JNDI”：MyBatis 会从 JNDI 服务上查找 DataSource 实例，然后返回使用 7.Mybatis中事务控制7.3Mybatis中事务提交方式1Mybatis中事务的提交方式，本质上就是调用JDBC的setAutoComment（）来实现事务控制，默认情况下setAutoComment（）的参数为false，所以我们要手动使用SqlSession.commit（）来提交事务 7.4Mybatis自动提交事务的设置12在创建SqlSession工厂对象时，传入trueSqlSession session = factory.openSession（true）; 8.Mybatis中的动态SQL语句1234主要就是使用Mybatis中提供的动态SQL语句标签&lt;if&gt;&lt;where&gt;&lt;foreach&gt; 9.Mybatis延迟加载策略9.1何为延迟加载123延迟加载：就是需要用到数据是才进行加载，不需要用到数据时就不加载数据。也称为懒加载 好处：先从单表查询，需要时再关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快 坏处：因为只有当需要用到数据时，才会进行数据库查询，这样大批量数据查询时，因为查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体检下降。 9.2开启Mybatis的延迟加载策略1234567891011121314151617181920212223242526271.需要再Mybatis的配置文件SqlMapConfig.xml文件中添加延迟加载的配置&lt;settings&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt;&lt;/settings&gt;2.使用Collection实现延迟加载&lt;!-- collection 是用于建立一对多中集合属性的对应关系 ofType 用于指定集合元素的数据类型 select 是用于指定查询账户的唯一标识（账户的 dao 全限定类名加上方法名称） column 是用于指定使用哪个字段的值作为条件查询--&gt;&lt;collection property="accounts" ofType="account" select="" column=""&gt;&lt;/collection&gt;&lt;collection&gt;标签：主要用于加载关联的集合对象select 属性：用于指定查询 account 列表的 sql 语句，所以填写的是该 sql 映射的 idcolumn 属性：用于指定 select 属性的 sql 语句的参数来源，上面的参数来自于 user 的 id 列，所以就写成 id 这一个字段名了 10.Mybatis缓存Mybatis通过缓存策略来减少数据库的查询次数，从而提高性能 10.1Mybatis一级缓存12一级缓存是 SqlSession 级别的缓存，只要 SqlSession 没有 flush 或 close，它就存在。一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()等方法时，就会清空一级缓存。 10.2Mybatis二级缓存1二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。 10.2.1二级缓存的开启与关闭12345678910111213141516171819202122232425第一步：在SqlMapConfig.xml文件开启二级缓存&lt;settings&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;因为 cacheEnabled 的取值默认就为 true，所以这一步可以省略不配置。为 true 代表开启二级缓存；为false 代表不开启二级缓存。第二步：配置相关的Mapper映射文件&lt;cache&gt;标签表示当前这个 mapper 映射将使用二级缓存，区分的标准就看 mapper 的 namespace 值。&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.holicCode.dao.IUserDao&quot;&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;cache&gt;&lt;/cache&gt;&lt;/mapper&gt;第三部：配置statement上面的useCache属性&lt;!-- 根据 id 查询 --&gt;&lt;select id=&quot;findById&quot; resultType=&quot;user&quot; parameterType=&quot;int&quot; useCache=&quot;true&quot;&gt; select * from user where id = #&#123;uid&#125;&lt;/select&gt; 将 UserDao.xml 映射文件中的&lt;select&gt;标签中设置 useCache=”true”代表当前这个 statement 要使用二级缓存，如果不使用二级缓存可以设置为 false。注意：针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存 10.2.2基于注解的二级缓存123456789101.在SqlMapConfig中开启二级缓存支持&lt;!-- 配置二级缓存 --&gt;&lt;settings&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;setting name="cacheEnabled" value="true"/&gt;&lt;/settings&gt;2.在持久层接口中使用注解配置二级缓存@CacheNamespace(blocking=true)//mybatis 基于注解方式实现配置二级缓存public interface IUserDao &#123;&#125; 10.2.3二级缓存的注意事项1当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable 接口，这种就可以使用序列化方式来保存对象。 11.Mybatis的注解开发11.1Mybatis常用注解说明1234567891011@Insert:实现新增@Update:实现更新@Delete:实现删除@Select:实现查询@Result:实现结果集封装@Results:可以与@Result 一起使用，封装多个结果集@ResultMap:实现引用@Results 定义的封装@One:实现一对一结果集封装@Many:实现一对多结果集封装@SelectProvider: 实现动态 SQL 映射@CacheNamespace:实现注解二级缓存的使用]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL初级]]></title>
    <url>%2F2019%2F07%2F24%2FMySQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[MySQL基础知识汇总数据库的基本概念1. 数据库的英文单词： DataBase 简称 ： DB 2. 什么数据库？ * 用于存储和管理数据的仓库。 3. 数据库的特点： 1. 持久化存储数据的。其实数据库就是一个文件系统 2. 方便存储和管理数据 3. 使用了统一的方式操作数据库 -- SQLMySQL数据库软件1. 安装 2. 卸载 1. 去mysql的安装目录找到my.ini文件 * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot; 2. 卸载MySQL 3. 删除C:/ProgramData目录下的MySQL文件夹。 3. 配置 * MySQL服务启动 1. 手动。 2. cmd--&gt; services.msc 打开服务的窗口 3. 使用管理员打开cmd * net start mysql : 启动mysql的服务 * net stop mysql:关闭mysql服务 * MySQL登录 1. mysql -uroot -p密码 2. mysql -hip -uroot -p连接目标的密码 3. mysql --host=ip --user=root --password=连接目标的密码 * MySQL退出 1. exit 2. quit * MySQL目录结构 1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot; * 配置文件 my.ini 2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot; * 几个概念 * 数据库：文件夹 * 表：文件 * 数据：数据SQL1.什么是SQL？ Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 2.SQL通用语法 1. SQL 语句可以单行或多行书写，以分号结尾。 2. 可使用空格和缩进来增强语句的可读性。 3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 4. 3 种注释 * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) * 多行注释: /* 注释 */ 3. SQL分类 1) DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 2) DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 3) DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 4) DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL:操作数据库、表1. 操作数据库：CRUD 1. C(Create):创建 * 创建数据库： * create database 数据库名称; * 创建数据库，判断不存在，再创建： * create database if not exists 数据库名称; * 创建数据库，并指定字符集 * create database 数据库名称 character set 字符集名; * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk * create database if not exists db4 character set gbk; 2. R(Retrieve)：查询 * 查询所有数据库的名称: * show databases; * 查询某个数据库的字符集:查询某个数据库的创建语句 * show create database 数据库名称; 3. U(Update):修改 * 修改数据库的字符集 * alter database 数据库名称 character set 字符集名称; 4. D(Delete):删除 * 删除数据库 * drop database 数据库名称; * 判断数据库存在，存在再删除 * drop database if exists 数据库名称; 5. 使用数据库 * 查询当前正在使用的数据库名称 * select database(); * 使用数据库 * use 数据库名称; 2. 操作表 1. C(Create):创建 1. 语法： create table 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n ); * 注意：最后一列，不需要加逗号（,） * 数据库类型： 1. int：整数类型 * age int, 2. double:小数类型 * score double(5,2) 3. date:日期，只包含年月日，yyyy-MM-dd 4. datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 5. timestamp:时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 6. varchar：字符串 * name varchar(20):姓名最大20个字符 * zhangsan 8个字符 张三 2个字符12345678910111213141516171819202122232425262728293031 * 创建表 create table student( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp ); * 复制表： * create table 表名 like 被复制的表名; 2. R(Retrieve)：查询 * 查询某个数据库中所有的表名称 * show tables; * 查询表结构 * desc 表名;3. U(Update):修改 1. 修改表名 alter table 表名 rename to 新的表名; 2. 修改表的字符集 alter table 表名 character set 字符集名称; 3. 添加一列 alter table 表名 add 列名 数据类型; 4. 修改列名称 类型 alter table 表名 change 列名 新列别 新数据类型; alter table 表名 modify 列名 新数据类型; 5. 删除列 alter table 表名 drop 列名;4. D(Delete):删除 * drop table 表名; * drop table if exists 表名 ; DML：增删改表中数据1. 添加数据： * 语法： * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n); * 注意： 1. 列名和值要一一对应。 2. 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,...值n); 3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来 2. 删除数据： * 语法： * delete from 表名 [where 条件] * 注意： 1. 如果不加条件，则删除表中所有记录。 2. 如果要删除所有记录 1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作 2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 3. 修改数据： * 语法： * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件]; * 注意： 1. 如果不加任何条件，则会将表中所有记录全部修改。DQL：查询表中的记录1234567891011121314151617* select * from 表名;1. 语法： select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定 2. 基础查询 1. 多个字段的查询 select 字段名1，字段名2... from 表名； * 注意： * 如果查询所有字段，则可以使用*来替代字段列表。 2. 去除重复： * distinct 3. 计算列 * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null * 表达式1：哪个字段需要判断是否为null * 如果该字段为null后的替换值。 4. 起别名： * as：as也可以省略1234567891011121314151617181920212223242526272829303132333435363738394041424344453. 条件查询 1. where子句后跟条件 2. 运算符 * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt; * BETWEEN...AND * IN( 集合) * LIKE：模糊查询 * 占位符： * _:单个任意字符 * %：多个任意字符 * IS NULL * and 或 &amp;&amp; * or 或 || * not 或 ! -- 查询年龄大于20岁 SELECT * FROM student WHERE age &gt; 20; SELECT * FROM student WHERE age &gt;= 20; -- 查询年龄等于20岁 SELECT * FROM student WHERE age = 20; -- 查询年龄不等于20岁 SELECT * FROM student WHERE age != 20; SELECT * FROM student WHERE age &lt;&gt; 20; -- 查询年龄大于等于20 小于等于30 SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30; SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30; SELECT * FROM student WHERE age BETWEEN 20 AND 30; -- 查询年龄22岁，18岁，25岁的信息 SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25 SELECT * FROM student WHERE age IN (22,18,25); -- 查询英语成绩为null SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断 SELECT * FROM student WHERE english IS NULL; -- 查询英语成绩不为null SELECT * FROM student WHERE english IS NOT NULL; 1234567891011-- 查询姓马的有哪些？ likeSELECT * FROM student WHERE NAME LIKE '马%';-- 查询姓名第二个字是化的人SELECT * FROM student WHERE NAME LIKE "_化%";-- 查询姓名是3个字的人SELECT * FROM student WHERE NAME LIKE '___';-- 查询姓名中包含德的人SELECT * FROM student WHERE NAME LIKE '%德%'; 123456789104. 排序查询 * 语法：order by 子句 * order by 排序字段1 排序方式1 ， 排序字段2 排序方式2... * 排序方式： * ASC：升序，默认的。 * DESC：降序。 * 注意： * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。 1234567891011122. 聚合函数：将一列数据作为一个整体，进行纵向的计算。 1. count：计算个数 1. 一般选择非空的列：主键 2. count(*) 2. max：计算最大值 3. min：计算最小值 4. sum：计算和 5. avg：计算平均值 * 注意：聚合函数的计算，排除null值。 解决方案： 1. 选择不包含非空的列进行计算 2. IFNULL函数 12345678910111213141516171819202122233. 分组查询: 1. 语法：group by 分组字段； 2. 注意： 1. 分组之后查询的字段：分组字段、聚合函数 2. where 和 having 的区别？ 1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来 2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。 -- 按照性别分组。分别查询男、女同学的平均分 SELECT sex , AVG(math) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2; SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2; 1234567891011124. 分页查询 1. 语法：limit 开始的索引,每页查询的条数; 2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数 -- 每页显示3条记录 SELECT * FROM student LIMIT 0,3; -- 第1页 SELECT * FROM student LIMIT 3,3; -- 第2页 SELECT * FROM student LIMIT 6,3; -- 第3页 3. limit 是一个MySQL"方言" 约束123456789101112131415161718* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。 * 分类： 1. 主键约束：primary key 2. 非空约束：not null 3. 唯一约束：unique 4. 外键约束：foreign key* 非空约束：not null，值不能为null 1. 创建表时添加约束 CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL -- name为非空 ); 2. 创建表完后，添加非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; 3. 删除name的非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546* 唯一约束：unique，值不能重复 1. 创建表时，添加唯一约束 CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束 ); * 注意mysql中，唯一约束限定的列的值可以有多个null 2. 删除唯一约束 ALTER TABLE stu DROP INDEX phone_number; 3. 在创建表后，添加唯一约束 ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;* 主键约束：primary key。 1. 注意： 1. 含义：非空且唯一 2. 一张表只能有一个字段为主键 3. 主键就是表中记录的唯一标识 2. 在创建表时，添加主键约束 create table stu( id int primary key,-- 给id添加主键约束 name varchar(20) ); 3. 删除主键 -- 错误 alter table stu modify id int ; ALTER TABLE stu DROP PRIMARY KEY; 4. 创建完表后，添加主键 ALTER TABLE stu MODIFY id INT PRIMARY KEY; 5. 自动增长： 1. 概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长 2. 在创建表时，添加主键约束，并且完成主键自增长 create table stu( id int primary key auto_increment,-- 给id添加主键约束 name varchar(20) ); 3. 删除自动增长 ALTER TABLE stu MODIFY id INT; 4. 添加自动增长 ALTER TABLE stu MODIFY id INT AUTO_INCREMENT; 12345678910111213141516171819202122* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。 1. 在创建表时，可以添加外键 * 语法： create table 表名( .... 外键列 constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) ); 2. 删除外键 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 3. 创建表之后，添加外键 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); 4. 级联操作 1. 添加级联操作 语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE ; 2. 分类： 1. 级联更新：ON UPDATE CASCADE 2. 级联删除：ON DELETE CASCADE 数据库的设计123456789101112131415161718192021222324252627282930313233343536373839404142431. 多表之间的关系 1. 分类： 1. 一对一(了解)： * 如：人和身份证 * 分析：一个人只有一个身份证，一个身份证只能对应一个人 2. 一对多(多对一)： * 如：部门和员工 * 分析：一个部门有多个员工，一个员工只能对应一个部门 3. 多对多： * 如：学生和课程 * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择 2. 实现关系： 1. 一对多(多对一)： * 如：部门和员工 * 实现方式：在多的一方建立外键，指向一的一方的主键。 2. 多对多： * 如：学生和课程 * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 3. 一对一(了解)： * 如：人和身份证 * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。 3. 案例 /*创建用户表 tab_user uid 用户主键，自增长 username 用户名长度 100，唯一，非空 password 密码长度 30，非空 name 真实姓名长度 100 birthday 生日 sex 性别，定长字符串 1 telephone 手机号，字符串 11 email 邮箱，字符串长度 100 */ CREATE TABLE tab_user ( uid INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) UNIQUE NOT NULL, PASSWORD VARCHAR(30) NOT NULL, NAME VARCHAR(100), birthday DATE, sex CHAR(1) DEFAULT '男', telephone VARCHAR(11), email VARCHAR(100) ); 数据库设计的范式123456789101112131415161. 第一范式（1NF）：每一列都是不可分割的原子数据项2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） * 几个概念： 1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A 例如：学号--&gt;姓名。 （学号，课程名称） --&gt; 分数 2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。 例如：（学号，课程名称） --&gt; 分数 3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。 例如：（学号，课程名称） -- &gt; 姓名 4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A 例如：学号--&gt;系名，系名--&gt;系主任 5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码 例如：该表中码为：（学号，课程名称） * 主属性：码属性组中的所有属性 * 非主属性：除过码属性组的属性3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 数据库的备份和还原123456789101. 命令行： * 语法： * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 * 还原： 1. 登录数据库 2. 创建数据库 3. 使用数据库 4. 执行文件。source 文件路径2. 也可以使用图形化工具, 更加方便 推荐 Navicat for MySQL, 个人觉得比较好用 MySQL的多表查询&amp;事务多表查询123456* 查询语法： select 列名列表 from 表名列表 where.... 123* 笛卡尔积： * 有两个集合A,B .取这两个集合的所有组成情况。 * 要完成多表查询，需要消除无用的数据 1234567* 多表查询的分类： 1. 内连接查询： 1. 隐式内连接：使用where条件消除无用数据 * 语法： SELECT * FROM 表1,表2 WHERE 表名1.`表1的外键` = 表2的主键; 其中表1的外键是表二的主键 2. 显式内连接： * 语法： select 字段列表 from 表1 [inner] join 表2 on 条件 事务1234567891011121314151617181920212223242526272829301. 事务的基本介绍 1. 概念: 如果一个包含多个步骤的业务操作, 被事务管理, 那么这些操作要么都成功, 要们都失败 2.操作: 1.开启事务: start transaction; 2.回滚: rollback; 3.提交: commit;2. 事务的四大特征(ACID): 1. 原子性(Atomicity): 是不可分割的最小操作单位, 要么都成功, 要么都失败 2. 一致性(Consistency): 事务操作前后, 数据总量不变 3. 隔离性(Isolation): 多个事务之间, 相互独立 4. 持久性(Durability): 当事务提交或回滚后, 数据库会持久化的保存数据3. 事务的隔离级别 1. 概念: 多个事务之间是隔离的,相互独立的, 但是如果多个事务操作同一批数据, 则会引发一些问题,设置不同的隔离级别就可以解决这些问题 2. 存在的问题: 1.脏读: 一个事务,读取到另一个事务中没有提交的数据 2.不可重复读(虚读): 在同一个事务中,两次读取到的数据不一样 2.幻读: 一个事务操作(DML)数据表中的所有记录, 另一个事务添加了一条数据,则第一个事务查询不到自己的修改 3. 隔离级别: 1.read uncommitted: 读未提交 产生的问题: 脏读, 不可重复读, 幻读 2. read committed: 读已提交(Oracle) 产生的问题: 不可重复读, 幻读 3. repeatable read: 可重复读(MySQL默认) 产生的问题: 幻读 4. serializable: 串行化 可以解决所有问题 注意: 隔离级别从小到大安全性越来越高, 但是效率越来越低 数据库查询隔离级别: select @@tx_isolation; 数据库设置隔离级别: set global transaction isolation level 级别字符串; DCL1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950DCL：管理用户，授权 1. 管理用户 1. 添加用户： * 语法：CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 2. 删除用户： * 语法：DROP USER '用户名'@'主机名'; 3. 修改用户密码： UPDATE USER SET PASSWORD = PASSWORD('新密码') WHERE USER = '用户名'; UPDATE USER SET PASSWORD = PASSWORD('abc') WHERE USER = 'lisi'; SET PASSWORD FOR '用户名'@'主机名' = PASSWORD('新密码'); SET PASSWORD FOR 'root'@'localhost' = PASSWORD('123'); * mysql中忘记了root用户的密码？ 1. cmd -- &gt; net stop mysql 停止mysql服务 * 需要管理员运行该cmd 2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables 3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功 4. use mysql; 5. update user set password = password('你的新密码') where user = 'root'; 6. 关闭两个窗口 7. 打开任务管理器，手动结束mysqld.exe 的进程 8. 启动mysql服务 9. 使用新密码登录。 4. 查询用户： -- 1. 切换到mysql数据库 USE myql; -- 2. 查询user表 SELECT * FROM USER; * 通配符： % 表示可以在任意主机使用用户登录数据库 2. 权限管理： 1. 查询权限： -- 查询权限 SHOW GRANTS FOR '用户名'@'主机名'; SHOW GRANTS FOR 'lisi'@'%'; 2. 授予权限： -- 授予权限 grant 权限列表 on 数据库名.表名 to '用户名'@'主机名'; -- 给张三用户授予所有权限，在任意数据库任意表上 GRANT ALL ON *.* TO 'zhangsan'@'localhost'; 3. 撤销权限： -- 撤销权限： revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名'; REVOKE UPDATE ON db3.`account` FROM 'lisi'@'%';]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>MySQL, sql语句, MySQL概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题库以及详解]]></title>
    <url>%2F2019%2F07%2F24%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[剑指offer第一题题目:在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路:因为这个二维数组是有序的, 可以先定位到左下角, 判断要找的数, 如果target &gt; 左下角 就往右找, 然后target &lt; 左下角 就往上找 1234567891011121314151617181920public class Solution &#123; public boolean Find(int target, int [][] array) &#123; //得到二维数组的行和列 int rows = array.length; int cols = array[0].length; //定位到左下角 int i = rows - 1; int j = 0; //循环查找, 不知道循环次数, 用while while(i &gt;= 0 &amp;&amp; j &lt; cols)&#123; if(target &gt; array[i][j]) j++; else if(target &lt; array[i][j]) i--; else return true; &#125; return false; &#125;&#125; 第二题题目: 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路:首先不能使用String提供的replace()方法 ①从前往后替换, 每替换一次后面的字符就要移动一次, 效率低下 ②从后往前替换, 每个字符只需要移动一次, 所以选择这个思路 1234567891011121314151617181920212223242526public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; //计算空格数 int spacenum = 0; for(int i = 0; i &lt; str.length(); i++)&#123; if(str.charAt(i) == ' ') spacenum++; &#125; //扩容 int indexOld = str.length() - 1; int newLength = str.length() + spacenum * 2; int indexNew = newLength - 1; str.setLength(indexNew); //替换 for(;indexOld &gt;= 0 &amp;&amp; newLength &gt; indexOld; --indexOld)&#123; if(str.charAt(indexOld) == ' ')&#123; str.setCharAt(indexNew--, '0'); str.setCharAt(indexNew--, '2'); str.setCharAt(indexNew--, '%'); &#125; else &#123; str.setCharAt(indexNew--, str.charAt(indexOld)); &#125; &#125; return str.toString(); &#125;&#125; 第三题题目: 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125; 代码实现: 解法一: 递归 123456789101112131415import java.util.ArrayList;public class Solution &#123; //先创建一个 ArrayList 集合 ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; //判断传入的链表是否不为空 if(listNode != null)&#123; //递归调用 printListFromTailToHead()方法, 传入链表的元素 this.printListFromTailToHead(listNode.next); //将遍历出来的链表的元素的值添加入 arrayList 中 arrayList.add(listNode.val); &#125; return arrayList; &#125;&#125; 解法二: 利用栈(先进后出) 1234567891011121314151617import java.util.ArrayList;import java.util.Stack;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack&lt;Integer&gt; temp = new Stack&lt;&gt;(); ArrayList&lt;Integer&gt; newList = new ArrayList&lt;&gt;(); ListNode t = listNode; while( t != null )&#123; temp.push(t.val); t = t.next; &#125; while( !temp.empty() )&#123; newList.add(temp.pop()); &#125; return newList; &#125;&#125; 第四题题目: 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 1234567Definition for binary tree public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x;&#125; &#125; 代码实现: 12345678910111213141516171819202122public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; TreeNode root=reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1); return root; &#125; //前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125; private TreeNode reConstructBinaryTree(int [] pre,int startPre,int endPre,int [] in,int startIn,int endIn) &#123; if(startPre&gt;endPre||startIn&gt;endIn) return null; TreeNode root= new TreeNode(pre[startPre]); //前序遍历结果的 第一个元素就是根节点 for(int i=startIn;i&lt;=endIn;i++) if(in[i]==pre[startPre])&#123; root.left=reConstructBinaryTree(pre,startPre+1,startPre+i-startIn,in,startIn,i-1); root.right=reConstructBinaryTree(pre,i-startIn+startPre+1,endPre,in,i+1,endIn); break; &#125; return root; &#125;&#125; 第五题题目: 用两个栈来实现一个队列,完成队列的Push和Pop操作, 队列中的元素为 int 类型 思路: 首先栈是先进后出, 队列是先进先出 12345678910111213141516171819202122232425import java.util.Stack; public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); //队列的 push 操作和 栈的 push 是相同的 public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; //判断 stack1 和 stack2 是否为空 if(stack1.empty()&amp;&amp;stack2.empty())&#123; throw new RuntimeException("Queue is empty!"); &#125; if(stack2.empty())&#123; while(!stack1.empty())&#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.pop(); &#125;&#125; 第六题题目:把一个数组最开始的若干元素搬到数组的末尾, 我们称之为数组的旋转. 输入一个非减排序的数组的一个旋转, 输出旋转数组的最小元素.例如数组{3,4,5,1,2} 为 {1,2,3,4,5}, 该数组的最小值为1, NOTE: 给出的所有元素都大于0, 若数组大小为0 ,请返回0 思路:(1)array[mid] &gt; array[high]: 出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。 low = mid + 1 (2)array[mid] == array[high]: 出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边 还是右边,这时只好一个一个试 ， high = high - 1 (3)array[mid] &lt; array[high]: 出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左 边。因为右边必然都是递增的。 high = mid 12345678910111213141516171819202122import java.util.ArrayList;public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; int low = 0; int hight = array.length - 1; while(low &lt; hight)&#123; //中间的位置 int mid = low + (hight - low)/2; //若中间的数 &gt; 最后一个数, 最小的数就是中间数的下一个 if(array[mid] &gt; array[hight])&#123; low = mid + 1; //若中间的数 = 最后一个数, 最小的数左右都有可能, 所有要缩小,继续找 &#125;else if(array[mid] == array[hight])&#123; hight -= 1; //若中间的数 &lt; 最后一个数, 最小的数只能是中间的数,或,中间数的左边的数中的某一个 &#125;else&#123; hight = mid; &#125; &#125; return array[low]; &#125;&#125; 第七题题目: 输入一个整数n, 请你输出斐波那契列的第n项(从0开始,第0项为0) 思路一: 采用递归, 这种解法效率低, 每次都要调自己 123456789public class Solution &#123; public int Fibonacci(int n) &#123; if(n &lt; 2)&#123; return n; &#125;else&#123; return Fibonacci(n - 1) + Fibonacci(n - 2); &#125; &#125;&#125; 思路二: 1234567891011121314public class Solution &#123; public int Fibonacci(int n) &#123; if(n &lt; 0) throw new IllegalArgumentException("输入的数不能小于0"); if(n == 0 || n == 1) return n; int a = 1, b = 0, sum = 0; for(int i = 2;i &lt;= n;i++)&#123; sum = a + b; b = a; a = sum; &#125; return sum; &#125;&#125; 第八题题目: 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 思路: 这还是一个斐波那契列, 唯一不同的是从1开始 1234567891011121314public class Solution &#123; public int JumpFloor(int target) &#123; if(target &lt; 1) throw new IllegalArgumentException("台阶数不能小于1");; if(target &lt; 3) return target; int a = 1, b = 2, sum = 0; for(int i = 3;i &lt;= target;i++)&#123; sum = a + b; a = b; b = sum; &#125; return sum; &#125;&#125; 第九题题目: 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。 求该青蛙跳上一个n级的台阶总共有多少种跳法。分析: f(1) = 1 f(2) = f(2-1) + f(2-2) //f(2-2) 表示2阶一次跳2阶的次数。 f(3) = f(3-1) + f(3-2) + f(3-3) … f(n) = f(n-1) + f(n-2) + f(n-3) + … + f(n-(n-1)) + f(n-n) 说明： 1）这里的f(n) 代表的是n个台阶有一次1,2,...n阶的 跳法数。 2）n = 1时，只有1种跳法，f(1) = 1 3) n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ，f(2) = f(2-1) + f(2-2) 4) n = 3时，会有三种跳得方式，1阶、2阶、3阶，那么就是第一次跳出1阶后面剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3) 因此结论是f(3) = f(3-1)+f(3-2)+f(3-3) 5) n = n时，会有n中跳的方式，1阶、2阶...n阶，得出结论： f(n) = f(n-1)+f(n-2)+...+f(n-(n-1)) + f(n-n) =&gt; f(0) + f(1) + f(2) + f(3) + ... + f(n-1) 6) 由以上已经是一种结论，但是为了简单，我们可以继续简化： f(n-1) = f(0) + f(1)+f(2)+f(3) + ... + f((n-1)-1) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2) f(n) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2) + f(n-1) = f(n-1) + f(n-1) 可以得出：f(n) = 2*f(n-1) 7) 得出最终结论,在n阶台阶，一次有1、2、...n阶的跳的方式时，总得跳法为： | 1 ,(n=0 ) f(n) = | 1 ,(n=1 ) | 2*f(n-1),(n&gt;=2)代码实现: 12345678910public class Solution &#123; public int JumpFloorII(int target) &#123; if(target &lt; 0) throw new IllegalArgumentException("台阶数不能小于0"); if(target == 1)&#123; return 1; &#125;else&#123; return 2 * JumpFloorII(target - 1); &#125; &#125;&#125; 第十题题目: 我们可以用2×1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2×n的大矩形，总共有多少种方法？ 分析: 还是一个斐波那契 采用递归: 12345678910public class Solution &#123; public int RectCover(int target) &#123; if(target &lt; 0) throw new IllegalArgumentException("输入的n不能小于0的整数"); if(target == 0 || target == 1 || target == 2)&#123; return target; &#125; else&#123; return RectCover(target - 1) + RectCover(target - 2); &#125; &#125;&#125; 不用递归, 效率比较高的解法: 1234567891011121314public class Solution &#123; public int RectCover(int target) &#123; if(target &lt; 0) throw new IllegalArgumentException("输入的数不能小于0"); if(target == 0 || target == 1) return target; int a = 1, b = 1, sum = 0; for(int i = 2;i &lt;= target;i++)&#123; sum = a + b; b = a; a = sum; &#125; return sum; &#125;&#125; 第十一题题目: 输入一个整数, 输出该数二进制表示中1的个数, 其中负数用补码表示 思路:如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。 举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。 12345678public int NumberOf1(int n)&#123; int count = 0; while(n != 0)&#123; count++; n = n &amp; (n - 1); &#125; return count;&#125; 第十二题题目: 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 解法一: 常规解法, 时间复杂度为O(n) 12345678910111213public class Solution &#123; public double Power(double base, int exponent) &#123; double result = 1; //abs() : 返回这个数的绝对值 for(int i = 0;i &lt; Math.abs(exponent);i++)&#123; result *= base; &#125; if(exponent &lt; 0)&#123; result = 1/result; &#125; return result; &#125;&#125; 解法二: 递归: ​ n为偶数时, a^n = a^(n/2) * a^(n/2) ​ n为奇数时, a^n=（a^（n-1）/2）×（a^（n-1/2））×a 时间复杂度为 O(logn) 12345678910111213public class Solution()&#123; public double Power(double base, int exponent)&#123; int n = Math.abs(exponent); if(n == 0) return 1; if(n == 1) return base; double result = Power(base, n&gt;&gt;1); result *= result; if((n&amp;1) == 1) result *= base; if(exponent &lt; 0) result = 1/result; return result; &#125;&#125; 第十三题题目: 输入一个整数数组,实现一个函数来调整该数组中的数字的顺序,使得所有的奇数位于数组的前半部分,所有的偶数位于数组的后半部分,并保证奇数和奇数,偶数和偶数之间的相对位置不变. 思路: 123首先统计奇数的个数然后新建一个等长数组，设置两个指针，奇数指针从0开始，偶数指针从奇数个数的末尾开始 遍历，填数此方法的时间复杂度为O(n) 123456789101112131415161718192021222324252627public class Solution&#123; public void reOrderArray(int [] array)&#123; if(array.length == 0 ||array.length == 1) return; int oddCount = 0,oddBegin = 0; //创建一个和原数组等长的新数组 int[] newArray = new int[array.length]; //遍历数组 for(int i = 0;i &lt; array.length;i++)&#123; //判断数组元素为奇数时,将oddCount向后移一位, //最终oddCount的位置就是第一个偶数的位置 if((array[i]&amp;1) == 1) oddCount++; &#125; for(int i = 0;i &lt; array.length;i++)&#123; //判断元素为奇数就从新数组的开头位置开始放 if((array[i]&amp;1) == 1)&#123; newArray[oddBegin++] = array[i]; &#125; else&#123; //如果元素为偶数就从新数组的偶数第一个位置开始放 newArray[oddCount++] = array[i]; &#125; &#125; //最后用新数组排好序的元素替换原数组的元素 for(int i = 0;i &lt; array.length;i++)&#123; array[i] = newArray[i]; &#125; &#125;&#125; 第十四题题目: 输入一个链表,输出该链表中倒数第K个节点 123456789/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/ 思路: 定义两个指针, 先让着两个指针都指向链表的头结点, 然后让其中一个指针往后移(k - 1)位, 再让另一个指针开始跑(此时两个指针在相对静止的跑), 当先跑的那个指针到达链表末尾时, 后跑的那个指针到达的位置就是倒数第k的位置 12345678910111213141516171819public class Solution&#123; public ListNode FindKthToTail(ListNode head,int k)&#123; //定义两个指针都指向头结点 ListNode p, q; p = q = head; //记录k值 int a = k; //记录节点个数 int count = 0; while(p != null)&#123; p = p.next; count++; if(k &lt; 1) q = q.next; k--; &#125; if(count &lt; a) return null; return q; &#125;&#125; 12345678910111213精简写法public class Solution&#123; public ListNode FindKthToTail(ListNode head,int k)&#123; ListNode p, q; p = q = head; int i = 0; for( ; p != null; i++)&#123; if(i &gt;= k) q = q.next; p = p.next; &#125; return i &lt; k ? null : q; &#125;&#125; 第十五题题目: 输入一个人链表, 反转链表后, 输出新链表的表头. 123456789/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/ 题解 12345678910111213141516171819202122232425262728293031public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; if(head==null) return null; //head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null； ListNode pre = null; ListNode next = null; //当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点 //需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre&lt;-head next1-&gt;next2 //即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了 //所以需要用到pre和next两个节点 //1-&gt;2-&gt;3-&gt;4-&gt;5 //1&lt;-2&lt;-3 4-&gt;5 while(head!=null)&#123; //做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre //如此就可以做到反转链表的效果 //先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂 next = head.next; //保存完next，就可以让head从指向next变成指向pre了，代码如下 head.next = pre; //head指向pre后，就继续依次反转下一个节点 //让pre，head，next依次向后移动一个节点，继续下一次的指针反转 pre = head; head = next; &#125; //如果head为null的时候，pre就为最后一个节点了，但是链表已经反转完毕，pre就是反转后链表的第一个节点 //直接输出pre就是我们想要得到的反转后的链表 return pre; &#125;&#125; 未完,待续……….]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指offer, 算法, 详解</tag>
      </tags>
  </entry>
</search>

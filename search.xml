<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL初级]]></title>
    <url>%2F2019%2F07%2F24%2FMySQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[MySQL基础知识汇总数据库的基本概念1. 数据库的英文单词： DataBase 简称 ： DB 2. 什么数据库？ * 用于存储和管理数据的仓库。 3. 数据库的特点： 1. 持久化存储数据的。其实数据库就是一个文件系统 2. 方便存储和管理数据 3. 使用了统一的方式操作数据库 -- SQLMySQL数据库软件1. 安装 2. 卸载 1. 去mysql的安装目录找到my.ini文件 * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot; 2. 卸载MySQL 3. 删除C:/ProgramData目录下的MySQL文件夹。 3. 配置 * MySQL服务启动 1. 手动。 2. cmd--&gt; services.msc 打开服务的窗口 3. 使用管理员打开cmd * net start mysql : 启动mysql的服务 * net stop mysql:关闭mysql服务 * MySQL登录 1. mysql -uroot -p密码 2. mysql -hip -uroot -p连接目标的密码 3. mysql --host=ip --user=root --password=连接目标的密码 * MySQL退出 1. exit 2. quit * MySQL目录结构 1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot; * 配置文件 my.ini 2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot; * 几个概念 * 数据库：文件夹 * 表：文件 * 数据：数据SQL1.什么是SQL？ Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 2.SQL通用语法 1. SQL 语句可以单行或多行书写，以分号结尾。 2. 可使用空格和缩进来增强语句的可读性。 3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 4. 3 种注释 * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) * 多行注释: /* 注释 */ 3. SQL分类 1) DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 2) DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 3) DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 4) DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL:操作数据库、表1. 操作数据库：CRUD 1. C(Create):创建 * 创建数据库： * create database 数据库名称; * 创建数据库，判断不存在，再创建： * create database if not exists 数据库名称; * 创建数据库，并指定字符集 * create database 数据库名称 character set 字符集名; * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk * create database if not exists db4 character set gbk; 2. R(Retrieve)：查询 * 查询所有数据库的名称: * show databases; * 查询某个数据库的字符集:查询某个数据库的创建语句 * show create database 数据库名称; 3. U(Update):修改 * 修改数据库的字符集 * alter database 数据库名称 character set 字符集名称; 4. D(Delete):删除 * 删除数据库 * drop database 数据库名称; * 判断数据库存在，存在再删除 * drop database if exists 数据库名称; 5. 使用数据库 * 查询当前正在使用的数据库名称 * select database(); * 使用数据库 * use 数据库名称; 2. 操作表 1. C(Create):创建 1. 语法： create table 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n ); * 注意：最后一列，不需要加逗号（,） * 数据库类型： 1. int：整数类型 * age int, 2. double:小数类型 * score double(5,2) 3. date:日期，只包含年月日，yyyy-MM-dd 4. datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 5. timestamp:时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 6. varchar：字符串 * name varchar(20):姓名最大20个字符 * zhangsan 8个字符 张三 2个字符12345678910111213141516171819202122232425262728293031 * 创建表 create table student( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp ); * 复制表： * create table 表名 like 被复制的表名; 2. R(Retrieve)：查询 * 查询某个数据库中所有的表名称 * show tables; * 查询表结构 * desc 表名;3. U(Update):修改 1. 修改表名 alter table 表名 rename to 新的表名; 2. 修改表的字符集 alter table 表名 character set 字符集名称; 3. 添加一列 alter table 表名 add 列名 数据类型; 4. 修改列名称 类型 alter table 表名 change 列名 新列别 新数据类型; alter table 表名 modify 列名 新数据类型; 5. 删除列 alter table 表名 drop 列名;4. D(Delete):删除 * drop table 表名; * drop table if exists 表名 ; DML：增删改表中数据1. 添加数据： * 语法： * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n); * 注意： 1. 列名和值要一一对应。 2. 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,...值n); 3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来 2. 删除数据： * 语法： * delete from 表名 [where 条件] * 注意： 1. 如果不加条件，则删除表中所有记录。 2. 如果要删除所有记录 1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作 2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 3. 修改数据： * 语法： * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件]; * 注意： 1. 如果不加任何条件，则会将表中所有记录全部修改。DQL：查询表中的记录1234567891011121314151617* select * from 表名;1. 语法： select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定 2. 基础查询 1. 多个字段的查询 select 字段名1，字段名2... from 表名； * 注意： * 如果查询所有字段，则可以使用*来替代字段列表。 2. 去除重复： * distinct 3. 计算列 * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null * 表达式1：哪个字段需要判断是否为null * 如果该字段为null后的替换值。 4. 起别名： * as：as也可以省略1234567891011121314151617181920212223242526272829303132333435363738394041424344453. 条件查询 1. where子句后跟条件 2. 运算符 * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt; * BETWEEN...AND * IN( 集合) * LIKE：模糊查询 * 占位符： * _:单个任意字符 * %：多个任意字符 * IS NULL * and 或 &amp;&amp; * or 或 || * not 或 ! -- 查询年龄大于20岁 SELECT * FROM student WHERE age &gt; 20; SELECT * FROM student WHERE age &gt;= 20; -- 查询年龄等于20岁 SELECT * FROM student WHERE age = 20; -- 查询年龄不等于20岁 SELECT * FROM student WHERE age != 20; SELECT * FROM student WHERE age &lt;&gt; 20; -- 查询年龄大于等于20 小于等于30 SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30; SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30; SELECT * FROM student WHERE age BETWEEN 20 AND 30; -- 查询年龄22岁，18岁，25岁的信息 SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25 SELECT * FROM student WHERE age IN (22,18,25); -- 查询英语成绩为null SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断 SELECT * FROM student WHERE english IS NULL; -- 查询英语成绩不为null SELECT * FROM student WHERE english IS NOT NULL; 1234567891011-- 查询姓马的有哪些？ likeSELECT * FROM student WHERE NAME LIKE '马%';-- 查询姓名第二个字是化的人SELECT * FROM student WHERE NAME LIKE "_化%";-- 查询姓名是3个字的人SELECT * FROM student WHERE NAME LIKE '___';-- 查询姓名中包含德的人SELECT * FROM student WHERE NAME LIKE '%德%'; 123456789104. 排序查询 * 语法：order by 子句 * order by 排序字段1 排序方式1 ， 排序字段2 排序方式2... * 排序方式： * ASC：升序，默认的。 * DESC：降序。 * 注意： * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。 1234567891011122. 聚合函数：将一列数据作为一个整体，进行纵向的计算。 1. count：计算个数 1. 一般选择非空的列：主键 2. count(*) 2. max：计算最大值 3. min：计算最小值 4. sum：计算和 5. avg：计算平均值 * 注意：聚合函数的计算，排除null值。 解决方案： 1. 选择不包含非空的列进行计算 2. IFNULL函数 12345678910111213141516171819202122233. 分组查询: 1. 语法：group by 分组字段； 2. 注意： 1. 分组之后查询的字段：分组字段、聚合函数 2. where 和 having 的区别？ 1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来 2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。 -- 按照性别分组。分别查询男、女同学的平均分 SELECT sex , AVG(math) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2; SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2; 1234567891011124. 分页查询 1. 语法：limit 开始的索引,每页查询的条数; 2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数 -- 每页显示3条记录 SELECT * FROM student LIMIT 0,3; -- 第1页 SELECT * FROM student LIMIT 3,3; -- 第2页 SELECT * FROM student LIMIT 6,3; -- 第3页 3. limit 是一个MySQL"方言" 约束123456789101112131415161718* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。 * 分类： 1. 主键约束：primary key 2. 非空约束：not null 3. 唯一约束：unique 4. 外键约束：foreign key* 非空约束：not null，值不能为null 1. 创建表时添加约束 CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL -- name为非空 ); 2. 创建表完后，添加非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; 3. 删除name的非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546* 唯一约束：unique，值不能重复 1. 创建表时，添加唯一约束 CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束 ); * 注意mysql中，唯一约束限定的列的值可以有多个null 2. 删除唯一约束 ALTER TABLE stu DROP INDEX phone_number; 3. 在创建表后，添加唯一约束 ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;* 主键约束：primary key。 1. 注意： 1. 含义：非空且唯一 2. 一张表只能有一个字段为主键 3. 主键就是表中记录的唯一标识 2. 在创建表时，添加主键约束 create table stu( id int primary key,-- 给id添加主键约束 name varchar(20) ); 3. 删除主键 -- 错误 alter table stu modify id int ; ALTER TABLE stu DROP PRIMARY KEY; 4. 创建完表后，添加主键 ALTER TABLE stu MODIFY id INT PRIMARY KEY; 5. 自动增长： 1. 概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长 2. 在创建表时，添加主键约束，并且完成主键自增长 create table stu( id int primary key auto_increment,-- 给id添加主键约束 name varchar(20) ); 3. 删除自动增长 ALTER TABLE stu MODIFY id INT; 4. 添加自动增长 ALTER TABLE stu MODIFY id INT AUTO_INCREMENT; 12345678910111213141516171819202122* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。 1. 在创建表时，可以添加外键 * 语法： create table 表名( .... 外键列 constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) ); 2. 删除外键 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 3. 创建表之后，添加外键 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); 4. 级联操作 1. 添加级联操作 语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE ; 2. 分类： 1. 级联更新：ON UPDATE CASCADE 2. 级联删除：ON DELETE CASCADE 数据库的设计123456789101112131415161718192021222324252627282930313233343536373839404142431. 多表之间的关系 1. 分类： 1. 一对一(了解)： * 如：人和身份证 * 分析：一个人只有一个身份证，一个身份证只能对应一个人 2. 一对多(多对一)： * 如：部门和员工 * 分析：一个部门有多个员工，一个员工只能对应一个部门 3. 多对多： * 如：学生和课程 * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择 2. 实现关系： 1. 一对多(多对一)： * 如：部门和员工 * 实现方式：在多的一方建立外键，指向一的一方的主键。 2. 多对多： * 如：学生和课程 * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 3. 一对一(了解)： * 如：人和身份证 * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。 3. 案例 /*创建用户表 tab_user uid 用户主键，自增长 username 用户名长度 100，唯一，非空 password 密码长度 30，非空 name 真实姓名长度 100 birthday 生日 sex 性别，定长字符串 1 telephone 手机号，字符串 11 email 邮箱，字符串长度 100 */ CREATE TABLE tab_user ( uid INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) UNIQUE NOT NULL, PASSWORD VARCHAR(30) NOT NULL, NAME VARCHAR(100), birthday DATE, sex CHAR(1) DEFAULT '男', telephone VARCHAR(11), email VARCHAR(100) ); 数据库设计的范式12345678910111213141516171. 第一范式（1NF）：每一列都是不可分割的原子数据项 2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） * 几个概念： 1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A 例如：学号--&gt;姓名。 （学号，课程名称） --&gt; 分数 2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。 例如：（学号，课程名称） --&gt; 分数 3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。 例如：（学号，课程名称） -- &gt; 姓名 4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A 例如：学号--&gt;系名，系名--&gt;系主任 5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码 例如：该表中码为：（学号，课程名称） * 主属性：码属性组中的所有属性 * 非主属性：除过码属性组的属性 3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 数据库的备份和还原123456789101. 命令行： * 语法： * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 * 还原： 1. 登录数据库 2. 创建数据库 3. 使用数据库 4. 执行文件。source 文件路径2. 也可以使用图形化工具, 更加方便 推荐 Navicat for MySQL, 个人觉得比较好用 MySQL的多表查询&amp;事务多表查询123456* 查询语法： select 列名列表 from 表名列表 where.... 123* 笛卡尔积： * 有两个集合A,B .取这两个集合的所有组成情况。 * 要完成多表查询，需要消除无用的数据 1234567* 多表查询的分类： 1. 内连接查询： 1. 隐式内连接：使用where条件消除无用数据 * 语法： SELECT * FROM 表1,表2 WHERE 表名1.`表1的外键` = 表2的主键; 其中表1的外键是表二的主键 2. 显式内连接： * 语法： select 字段列表 from 表1 [inner] join 表2 on 条件 事务1234567891011121314151617181920212223242526272829301. 事务的基本介绍 1. 概念: 如果一个包含多个步骤的业务操作, 被事务管理, 那么这些操作要么都成功, 要们都失败 2.操作: 1.开启事务: start transaction; 2.回滚: rollback; 3.提交: commit;2. 事务的四大特征(ACID): 1. 原子性(Atomicity): 是不可分割的最小操作单位, 要么都成功, 要么都失败 2. 一致性(Consistency): 事务操作前后, 数据总量不变 3. 隔离性(Isolation): 多个事务之间, 相互独立 4. 持久性(Durability): 当事务提交或回滚后, 数据库会持久化的保存数据3. 事务的隔离级别 1. 概念: 多个事务之间是隔离的,相互独立的, 但是如果多个事务操作同一批数据, 则会引发一些问题,设置不同的隔离级别就可以解决这些问题 2. 存在的问题: 1.脏读: 一个事务,读取到另一个事务中没有提交的数据 2.不可重复读(虚读): 在同一个事务中,两次读取到的数据不一样 2.幻读: 一个事务操作(DML)数据表中的所有记录, 另一个事务添加了一条数据,则第一个事务查询不到自己的修改 3. 隔离级别: 1.read uncommitted: 读未提交 产生的问题: 脏读, 不可重复读, 幻读 2. read committed: 读已提交(Oracle) 产生的问题: 不可重复读, 幻读 3. repeatable read: 可重复读(MySQL默认) 产生的问题: 幻读 4. serializable: 串行化 可以解决所有问题 注意: 隔离级别从小到大安全性越来越高, 但是效率越来越低 数据库查询隔离级别: select @@tx_isolation; 数据库设置隔离级别: set global transaction isolation level 级别字符串; DCL1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950DCL：管理用户，授权 1. 管理用户 1. 添加用户： * 语法：CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 2. 删除用户： * 语法：DROP USER '用户名'@'主机名'; 3. 修改用户密码： UPDATE USER SET PASSWORD = PASSWORD('新密码') WHERE USER = '用户名'; UPDATE USER SET PASSWORD = PASSWORD('abc') WHERE USER = 'lisi'; SET PASSWORD FOR '用户名'@'主机名' = PASSWORD('新密码'); SET PASSWORD FOR 'root'@'localhost' = PASSWORD('123'); * mysql中忘记了root用户的密码？ 1. cmd -- &gt; net stop mysql 停止mysql服务 * 需要管理员运行该cmd 2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables 3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功 4. use mysql; 5. update user set password = password('你的新密码') where user = 'root'; 6. 关闭两个窗口 7. 打开任务管理器，手动结束mysqld.exe 的进程 8. 启动mysql服务 9. 使用新密码登录。 4. 查询用户： -- 1. 切换到mysql数据库 USE myql; -- 2. 查询user表 SELECT * FROM USER; * 通配符： % 表示可以在任意主机使用用户登录数据库 2. 权限管理： 1. 查询权限： -- 查询权限 SHOW GRANTS FOR '用户名'@'主机名'; SHOW GRANTS FOR 'lisi'@'%'; 2. 授予权限： -- 授予权限 grant 权限列表 on 数据库名.表名 to '用户名'@'主机名'; -- 给张三用户授予所有权限，在任意数据库任意表上 GRANT ALL ON *.* TO 'zhangsan'@'localhost'; 3. 撤销权限： -- 撤销权限： revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名'; REVOKE UPDATE ON db3.`account` FROM 'lisi'@'%';]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>MySQL, sql语句, MySQL概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题库以及详解]]></title>
    <url>%2F2019%2F07%2F24%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[剑指offer第一题题目:在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路:因为这个二维数组是有序的, 可以先定位到左下角, 判断要找的数, 如果target &gt; 左下角 就往右找, 然后target &lt; 左下角 就往上找 1234567891011121314151617181920public class Solution &#123; public boolean Find(int target, int [][] array) &#123; //得到二维数组的行和列 int rows = array.length; int cols = array[0].length; //定位到左下角 int i = rows - 1; int j = 0; //循环查找, 不知道循环次数, 用while while(i &gt;= 0 &amp;&amp; j &lt; cols)&#123; if(target &gt; array[i][j]) j++; else if(target &lt; array[i][j]) i--; else return true; &#125; return false; &#125;&#125; 第二题题目: 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路:首先不能使用String提供的replace()方法 ①从前往后替换, 每替换一次后面的字符就要移动一次, 效率低下 ②从后往前替换, 每个字符只需要移动一次, 所以选择这个思路 1234567891011121314151617181920212223242526public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; //计算空格数 int spacenum = 0; for(int i = 0; i &lt; str.length(); i++)&#123; if(str.charAt(i) == ' ') spacenum++; &#125; //扩容 int indexOld = str.length() - 1; int newLength = str.length() + spacenum * 2; int indexNew = newLength - 1; str.setLength(indexNew); //替换 for(;indexOld &gt;= 0 &amp;&amp; newLength &gt; indexOld; --indexOld)&#123; if(str.charAt(indexOld) == ' ')&#123; str.setCharAt(indexNew--, '0'); str.setCharAt(indexNew--, '2'); str.setCharAt(indexNew--, '%'); &#125; else &#123; str.setCharAt(indexNew--, str.charAt(indexOld)); &#125; &#125; return str.toString(); &#125;&#125; 第三题题目: 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125; 代码实现: 解法一: 递归 123456789101112131415import java.util.ArrayList;public class Solution &#123; //先创建一个 ArrayList 集合 ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; //判断传入的链表是否不为空 if(listNode != null)&#123; //递归调用 printListFromTailToHead()方法, 传入链表的元素 this.printListFromTailToHead(listNode.next); //将遍历出来的链表的元素的值添加入 arrayList 中 arrayList.add(listNode.val); &#125; return arrayList; &#125;&#125; 解法二: 利用栈(先进后出) 1234567891011121314151617import java.util.ArrayList;import java.util.Stack;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack&lt;Integer&gt; temp = new Stack&lt;&gt;(); ArrayList&lt;Integer&gt; newList = new ArrayList&lt;&gt;(); ListNode t = listNode; while( t != null )&#123; temp.push(t.val); t = t.next; &#125; while( !temp.empty() )&#123; newList.add(temp.pop()); &#125; return newList; &#125;&#125; 第四题题目: 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 1234567Definition for binary tree public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x;&#125; &#125; 代码实现: 12345678910111213141516171819202122public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; TreeNode root=reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1); return root; &#125; //前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125; private TreeNode reConstructBinaryTree(int [] pre,int startPre,int endPre,int [] in,int startIn,int endIn) &#123; if(startPre&gt;endPre||startIn&gt;endIn) return null; TreeNode root= new TreeNode(pre[startPre]); //前序遍历结果的 第一个元素就是根节点 for(int i=startIn;i&lt;=endIn;i++) if(in[i]==pre[startPre])&#123; root.left=reConstructBinaryTree(pre,startPre+1,startPre+i-startIn,in,startIn,i-1); root.right=reConstructBinaryTree(pre,i-startIn+startPre+1,endPre,in,i+1,endIn); break; &#125; return root; &#125;&#125; 第五题题目: 用两个栈来实现一个队列,完成队列的Push和Pop操作, 队列中的元素为 int 类型 思路: 首先栈是先进后出, 队列是先进先出 12345678910111213141516171819202122232425import java.util.Stack; public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); //队列的 push 操作和 栈的 push 是相同的 public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; //判断 stack1 和 stack2 是否为空 if(stack1.empty()&amp;&amp;stack2.empty())&#123; throw new RuntimeException("Queue is empty!"); &#125; if(stack2.empty())&#123; while(!stack1.empty())&#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.pop(); &#125;&#125; 第六题题目:把一个数组最开始的若干元素搬到数组的末尾, 我们称之为数组的旋转. 输入一个非减排序的数组的一个旋转, 输出旋转数组的最小元素.例如数组{3,4,5,1,2} 为 {1,2,3,4,5}, 该数组的最小值为1, NOTE: 给出的所有元素都大于0, 若数组大小为0 ,请返回0 思路:(1)array[mid] &gt; array[high]: 出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。 low = mid + 1 (2)array[mid] == array[high]: 出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边 还是右边,这时只好一个一个试 ， high = high - 1 (3)array[mid] &lt; array[high]: 出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左 边。因为右边必然都是递增的。 high = mid 12345678910111213141516171819202122import java.util.ArrayList;public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; int low = 0; int hight = array.length - 1; while(low &lt; hight)&#123; //中间的位置 int mid = low + (hight - low)/2; //若中间的数 &gt; 最后一个数, 最小的数就是中间数的下一个 if(array[mid] &gt; array[hight])&#123; low = mid + 1; //若中间的数 = 最后一个数, 最小的数左右都有可能, 所有要缩小,继续找 &#125;else if(array[mid] == array[hight])&#123; hight -= 1; //若中间的数 &lt; 最后一个数, 最小的数只能是中间的数,或,中间数的左边的数中的某一个 &#125;else&#123; hight = mid; &#125; &#125; return array[low]; &#125;&#125; 第七题题目: 输入一个整数n, 请你输出斐波那契列的第n项(从0开始,第0项为0) 思路一: 采用递归, 这种解法效率低, 每次都要调自己 123456789public class Solution &#123; public int Fibonacci(int n) &#123; if(n &lt; 2)&#123; return n; &#125;else&#123; return Fibonacci(n - 1) + Fibonacci(n - 2); &#125; &#125;&#125; 思路二: 1234567891011121314public class Solution &#123; public int Fibonacci(int n) &#123; if(n &lt; 0) throw new IllegalArgumentException("输入的数不能小于0"); if(n == 0 || n == 1) return n; int a = 1, b = 0, sum = 0; for(int i = 2;i &lt;= n;i++)&#123; sum = a + b; b = a; a = sum; &#125; return sum; &#125;&#125; 第八题题目: 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 思路: 这还是一个斐波那契列, 唯一不同的是从1开始 1234567891011121314public class Solution &#123; public int JumpFloor(int target) &#123; if(target &lt; 1) throw new IllegalArgumentException("台阶数不能小于1");; if(target &lt; 3) return target; int a = 1, b = 2, sum = 0; for(int i = 3;i &lt;= target;i++)&#123; sum = a + b; a = b; b = sum; &#125; return sum; &#125;&#125; 第九题题目: 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。 求该青蛙跳上一个n级的台阶总共有多少种跳法。分析: f(1) = 1 f(2) = f(2-1) + f(2-2) //f(2-2) 表示2阶一次跳2阶的次数。 f(3) = f(3-1) + f(3-2) + f(3-3) … f(n) = f(n-1) + f(n-2) + f(n-3) + … + f(n-(n-1)) + f(n-n) 说明： 1）这里的f(n) 代表的是n个台阶有一次1,2,...n阶的 跳法数。 2）n = 1时，只有1种跳法，f(1) = 1 3) n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ，f(2) = f(2-1) + f(2-2) 4) n = 3时，会有三种跳得方式，1阶、2阶、3阶，那么就是第一次跳出1阶后面剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3) 因此结论是f(3) = f(3-1)+f(3-2)+f(3-3) 5) n = n时，会有n中跳的方式，1阶、2阶...n阶，得出结论： f(n) = f(n-1)+f(n-2)+...+f(n-(n-1)) + f(n-n) =&gt; f(0) + f(1) + f(2) + f(3) + ... + f(n-1) 6) 由以上已经是一种结论，但是为了简单，我们可以继续简化： f(n-1) = f(0) + f(1)+f(2)+f(3) + ... + f((n-1)-1) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2) f(n) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2) + f(n-1) = f(n-1) + f(n-1) 可以得出：f(n) = 2*f(n-1) 7) 得出最终结论,在n阶台阶，一次有1、2、...n阶的跳的方式时，总得跳法为： | 1 ,(n=0 ) f(n) = | 1 ,(n=1 ) | 2*f(n-1),(n&gt;=2)代码实现: 12345678910public class Solution &#123; public int JumpFloorII(int target) &#123; if(target &lt; 0) throw new IllegalArgumentException("台阶数不能小于0"); if(target == 1)&#123; return 1; &#125;else&#123; return 2 * JumpFloorII(target - 1); &#125; &#125;&#125; 第十题题目: 我们可以用2×1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2×n的大矩形，总共有多少种方法？ 分析: 还是一个斐波那契 采用递归: 12345678910public class Solution &#123; public int RectCover(int target) &#123; if(target &lt; 0) throw new IllegalArgumentException("输入的n不能小于0的整数"); if(target == 0 || target == 1 || target == 2)&#123; return target; &#125; else&#123; return RectCover(target - 1) + RectCover(target - 2); &#125; &#125;&#125; 不用递归, 效率比较高的解法: 1234567891011121314public class Solution &#123; public int RectCover(int target) &#123; if(target &lt; 0) throw new IllegalArgumentException("输入的数不能小于0"); if(target == 0 || target == 1) return target; int a = 1, b = 1, sum = 0; for(int i = 2;i &lt;= target;i++)&#123; sum = a + b; b = a; a = sum; &#125; return sum; &#125;&#125; 第十一题题目: 输入一个整数, 输出该数二进制表示中1的个数, 其中负数用补码表示 思路:如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。 举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。 12345678public int NumberOf1(int n)&#123; int count = 0; while(n != 0)&#123; count++; n = n &amp; (n - 1); &#125; return count;&#125; 第十二题题目: 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 解法一: 常规解法, 时间复杂度为O(n) 12345678910111213public class Solution &#123; public double Power(double base, int exponent) &#123; double result = 1; //abs() : 返回这个数的绝对值 for(int i = 0;i &lt; Math.abs(exponent);i++)&#123; result *= base; &#125; if(exponent &lt; 0)&#123; result = 1/result; &#125; return result; &#125;&#125; 解法二: 递归: ​ n为偶数时, a^n = a^(n/2) * a^(n/2) ​ n为奇数时, a^n=（a^（n-1）/2）×（a^（n-1/2））×a 时间复杂度为 O(logn) 12345678910111213public class Solution()&#123; public double Power(double base, int exponent)&#123; int n = Math.abs(exponent); if(n == 0) return 1; if(n == 1) return base; double result = Power(base, n&gt;&gt;1); result *= result; if((n&amp;1) == 1) result *= base; if(exponent &lt; 0) result = 1/result; return result; &#125;&#125; 未完,待续……….]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指offer, 算法, 详解</tag>
      </tags>
  </entry>
</search>

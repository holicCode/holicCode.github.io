<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剑指offer题库以及详解]]></title>
    <url>%2F2019%2F07%2F24%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[剑指offer1. 第一题题目:在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路:因为这个二维数组是有序的, 可以先定位到左下角, 判断要找的数, 如果target &gt; 左下角 就往右找, 然后target &lt; 左下角 就往上找 1234567891011121314151617181920public class Solution &#123; public boolean Find(int target, int [][] array) &#123; //得到二维数组的行和列 int rows = array.length; int cols = array[0].length; //定位到左下角 int i = rows - 1; int j = 0; //循环查找, 不知道循环次数, 用while while(i &gt;= 0 &amp;&amp; j &lt; cols)&#123; if(target &gt; array[i][j]) j++; else if(target &lt; array[i][j]) i--; else return true; &#125; return false; &#125;&#125; 2. 第二题题目: 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路:首先不能使用String提供的replace()方法 ①从前往后替换, 每替换一次后面的字符就要移动一次, 效率低下 ②从后往前替换, 每个字符只需要移动一次, 所以选择这个思路 1234567891011121314151617181920212223242526public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; //计算空格数 int spacenum = 0; for(int i = 0; i &lt; str.length(); i++)&#123; if(str.charAt(i) == ' ') spacenum++; &#125; //扩容 int indexOld = str.length() - 1; int newLength = str.length() + spacenum * 2; int indexNew = newLength - 1; str.setLength(indexNew); //替换 for(;indexOld &gt;= 0 &amp;&amp; newLength &gt; indexOld; --indexOld)&#123; if(str.charAt(indexOld) == ' ')&#123; str.setCharAt(indexNew--, '0'); str.setCharAt(indexNew--, '2'); str.setCharAt(indexNew--, '%'); &#125; else &#123; str.setCharAt(indexNew--, str.charAt(indexOld)); &#125; &#125; return str.toString(); &#125;&#125; 3. 第三题题目: 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 ​ 12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125; 代码实现: 解法一: 递归 123456789101112131415import java.util.ArrayList;public class Solution &#123; //先创建一个 ArrayList 集合 ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; //判断传入的链表是否不为空 if(listNode != null)&#123; //递归调用 printListFromTailToHead()方法, 传入链表的元素 this.printListFromTailToHead(listNode.next); //将遍历出来的链表的元素的值添加入 arrayList 中 arrayList.add(listNode.val); &#125; return arrayList; &#125;&#125; 解法二: 利用栈(先进后出) 1234567891011121314151617import java.util.ArrayList;import java.util.Stack;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack&lt;Integer&gt; temp = new Stack&lt;&gt;(); ArrayList&lt;Integer&gt; newList = new ArrayList&lt;&gt;(); ListNode t = listNode; while( t != null )&#123; temp.push(t.val); t = t.next; &#125; while( !temp.empty() )&#123; newList.add(temp.pop()); &#125; return newList; &#125;&#125; 4. 第四题题目: 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 1234567Definition for binary tree public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x;&#125; &#125; 代码实现: 12345678910111213141516171819202122public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; TreeNode root=reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1); return root; &#125; //前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125; private TreeNode reConstructBinaryTree(int [] pre,int startPre,int endPre,int [] in,int startIn,int endIn) &#123; if(startPre&gt;endPre||startIn&gt;endIn) return null; TreeNode root= new TreeNode(pre[startPre]); //前序遍历结果的 第一个元素就是根节点 for(int i=startIn;i&lt;=endIn;i++) if(in[i]==pre[startPre])&#123; root.left=reConstructBinaryTree(pre,startPre+1,startPre+i-startIn,in,startIn,i-1); root.right=reConstructBinaryTree(pre,i-startIn+startPre+1,endPre,in,i+1,endIn); break; &#125; return root; &#125;&#125; 5. 第五题题目: 用两个栈来实现一个队列,完成队列的Push和Pop操作, 队列中的元素为 int 类型 思路: 首先栈是先进后出, 队列是先进先出 12345678910111213141516171819202122232425import java.util.Stack; public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); //队列的 push 操作和 栈的 push 是相同的 public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; //判断 stack1 和 stack2 是否为空 if(stack1.empty()&amp;&amp;stack2.empty())&#123; throw new RuntimeException("Queue is empty!"); &#125; if(stack2.empty())&#123; while(!stack1.empty())&#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.pop(); &#125;&#125; 6. 第六题题目:把一个数组最开始的若干元素搬到数组的末尾, 我们称之为数组的旋转. 输入一个非减排序的数组的一个旋转, 输出旋转数组的最小元素.例如数组{3,4,5,1,2} 为 {1,2,3,4,5}, 该数组的最小值为1, NOTE: 给出的所有元素都大于0, 若数组大小为0 ,请返回0 思路:(1)array[mid] &gt; array[high]: 出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。 low = mid + 1 (2)array[mid] == array[high]: 出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边 还是右边,这时只好一个一个试 ， high = high - 1 (3)array[mid] &lt; array[high]: 出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左 边。因为右边必然都是递增的。 high = mid 12345678910111213141516171819202122import java.util.ArrayList;public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; int low = 0; int hight = array.length - 1; while(low &lt; hight)&#123; //中间的位置 int mid = low + (hight - low)/2; //若中间的数 &gt; 最后一个数, 最小的数就是中间数的下一个 if(array[mid] &gt; array[hight])&#123; low = mid + 1; //若中间的数 = 最后一个数, 最小的数左右都有可能, 所有要缩小,继续找 &#125;else if(array[mid] == array[hight])&#123; hight -= 1; //若中间的数 &lt; 最后一个数, 最小的数只能是中间的数,或,中间数的左边的数中的某一个 &#125;else&#123; hight = mid; &#125; &#125; return array[low]; &#125;&#125; 7.第七题题目: 输入一个整数n, 请你输出斐波那契列的第n项(从0开始,第0项为0) 思路一: 采用递归, 这种解法效率低, 每次都要调自己 123456789public class Solution &#123; public int Fibonacci(int n) &#123; if(n &lt; 2)&#123; return n; &#125;else&#123; return Fibonacci(n - 1) + Fibonacci(n - 2); &#125; &#125;&#125; 思路二: 1234567891011121314public class Solution &#123; public int Fibonacci(int n) &#123; if(n &lt; 0) throw new IllegalArgumentException("输入的数不能小于0"); if(n == 0 || n == 1) return n; int a = 1, b = 0, sum = 0; for(int i = 2;i &lt;= n;i++)&#123; sum = a + b; b = a; a = sum; &#125; return sum; &#125;&#125; 8. 第八题题目: 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 思路: 这还是一个斐波那契列, 唯一不同的是从1开始 1234567891011121314public class Solution &#123; public int JumpFloor(int target) &#123; if(target &lt; 1) throw new IllegalArgumentException("台阶数不能小于1");; if(target &lt; 3) return target; int a = 1, b = 2, sum = 0; for(int i = 3;i &lt;= target;i++)&#123; sum = a + b; a = b; b = sum; &#125; return sum; &#125;&#125; 9. 第九题题目: 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。 求该青蛙跳上一个n级的台阶总共有多少种跳法。分析: f(1) = 1 f(2) = f(2-1) + f(2-2) //f(2-2) 表示2阶一次跳2阶的次数。 f(3) = f(3-1) + f(3-2) + f(3-3) … f(n) = f(n-1) + f(n-2) + f(n-3) + … + f(n-(n-1)) + f(n-n) 说明： 1）这里的f(n) 代表的是n个台阶有一次1,2,...n阶的 跳法数。 2）n = 1时，只有1种跳法，f(1) = 1 3) n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ，f(2) = f(2-1) + f(2-2) 4) n = 3时，会有三种跳得方式，1阶、2阶、3阶，那么就是第一次跳出1阶后面剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3) 因此结论是f(3) = f(3-1)+f(3-2)+f(3-3) 5) n = n时，会有n中跳的方式，1阶、2阶...n阶，得出结论： f(n) = f(n-1)+f(n-2)+...+f(n-(n-1)) + f(n-n) =&gt; f(0) + f(1) + f(2) + f(3) + ... + f(n-1) 6) 由以上已经是一种结论，但是为了简单，我们可以继续简化： f(n-1) = f(0) + f(1)+f(2)+f(3) + ... + f((n-1)-1) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2) f(n) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2) + f(n-1) = f(n-1) + f(n-1) 可以得出：f(n) = 2*f(n-1) 7) 得出最终结论,在n阶台阶，一次有1、2、...n阶的跳的方式时，总得跳法为： | 1 ,(n=0 ) f(n) = | 1 ,(n=1 ) | 2*f(n-1),(n&gt;=2)代码实现: 12345678910public class Solution &#123; public int JumpFloorII(int target) &#123; if(target &lt; 0) throw new IllegalArgumentException("台阶数不能小于0"); if(target == 1)&#123; return 1; &#125;else&#123; return 2 * JumpFloorII(target - 1); &#125; &#125;&#125; 10. 第十题题目: 我们可以用2×1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2×n的大矩形，总共有多少种方法？ 分析: 还是一个斐波那契 采用递归: 12345678910public class Solution &#123; public int RectCover(int target) &#123; if(target &lt; 0) throw new IllegalArgumentException("输入的n不能小于0的整数"); if(target == 0 || target == 1 || target == 2)&#123; return target; &#125; else&#123; return RectCover(target - 1) + RectCover(target - 2); &#125; &#125;&#125; 不用递归, 效率比较高的解法: 123456789101112131415public class Solution &#123; public int RectCover(int target) &#123; if(target &lt; 0) throw new IllegalArgumentException("输入的数不能小于0"); if(target == 0 || target == 1) return target; int a = 1, b = 1, sum = 0; for(int i = 2;i &lt;= target;i++)&#123; sum = a + b; b = a; a = sum; &#125; return sum; &#125;&#125; 11.未完,待续……….]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指offer, 算法, 详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

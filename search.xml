<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis的相关知识]]></title>
    <url>%2F2019%2F07%2F27%2FRedis%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Redis1.概念：redis是一款高性能的NoSQL系列的非关系型数据库1.1什么是NoSQL123456789101112131415161718192021222324252627281.1.什么是NoSQL NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。1.1.1. NOSQL和关系型数据库比较 优点： 1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点： 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 3）不提供关系型数据库对事务的处理。1.1.2. 非关系型数据库的优势： 1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。1.1.3. 关系型数据库的优势： 1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。1.1.4. 总结 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库， 让NoSQL数据库对关系型数据库的不足进行弥补。 一般会将数据存储在关系型数据库中，在Nosql数据库中备份存储关系型数据库的数据 1.2主流的NoSQL产品123456789101112131415161718192021222324251.2.主流的NOSQL产品• 键值(Key-Value)存储数据库 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化• 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限• 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法• 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 1.3什么是Redis1234567891011121314151.3 什么是Redis Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 1) 字符串类型 string 2) 哈希类型 hash 3) 列表类型 list 4) 集合类型 set 5) 有序集合类型 sortedset1.3.1 redis的应用场景 • 缓存（数据查询、短连接、新闻内容、商品内容等等） • 聊天室的在线好友列表 • 任务队列。（秒杀、抢购、12306等等） • 应用排行榜 • 网站访问统计 • 数据过期处理（可以精确到毫秒） • 分布式集群架构中的session分离 2.关于Redis中的一些操作2.1下载安装1234561. 官网：https://redis.io2. 中文网：http://www.redis.net.cn/3. 解压直接可以使用： * redis.windows.conf：配置文件 * redis-cli.exe：redis的客户端 * redis-server.exe：redis服务器端 2.2命令操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596971. redis的数据结构： * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 * value的数据结构： 1) 字符串类型 string 2) 哈希类型 hash ： map格式 3) 列表类型 list ： linkedlist格式。支持重复元素 4) 集合类型 set ： 不允许重复元素 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 2. 字符串类型 string 1. 存储： set key value 2. 获取： get key 3. 删除： del key3. 哈希类型 hash 1. 存储： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 2. 获取： * hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username &quot;lisi&quot; * hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) &quot;username&quot; 2) &quot;lisi&quot; 3) &quot;password&quot; 4) &quot;123&quot; 3. 删除： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 1 4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 1. 添加： 1. lpush key value: 将元素加入列表左表 2. rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 2. 获取： * lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot; 3. 删除： * lpop key： 删除列表最左边的元素，并将元素返回 * rpop key： 删除列表最右边的元素，并将元素返回5. 集合类型 set ： 不允许重复元素 1. 存储：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 2. 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; 3. 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 16. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 1. 存储：zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 2. 获取：zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) &quot;zhangsan&quot; 2) &quot;60&quot; 3) &quot;wangwu&quot; 4) &quot;80&quot; 5) &quot;lisi&quot; 6) &quot;500&quot; 3. 删除：zrem key value 127.0.0.1:6379&gt; zrem mysort lisi (integer) 17. 通用命令 1. keys * : 查询所有的键 2. type key ： 获取键对应的value的类型 3. del key：删除指定的key value 3.Redis的持久化12345678910111213141516171819202122232425262728293031321. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。2. redis持久化机制： 1. RDB：默认方式，不需要进行配置，默认就使用这种机制 * 在一定的间隔时间中，检测key的变化情况，然后持久化数据 1. 编辑redis.windwos.conf文件 # after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changed save 60 10000 2. 重新启动redis服务器，并指定配置文件名称 redis-2.8.9&gt;redis-server.exe redis.windows.conf 2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 1. 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） # appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 # appendfsync no ： 不进行持久化5. Java客户端 Jedis * Jedis: 一款java操作redis数据库的工具. * 使用步骤： 1. 下载jedis的jar包，并导入工程中 2. 使用 //1. 获取连接 Jedis jedis = new Jedis(&quot;localhost&quot;,6379); //2. 操作 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //3. 关闭连接 jedis.close(); 4.jedis中连接池：jedisPool的使用123456789101112131415161. 创建JedisPool连接池对象 2. 调用方法 getResource()方法获取Jedis连接 //0.创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1.创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379); //2.获取连接 Jedis jedis = jedisPool.getResource(); //3. 使用 jedis.set(&quot;hehe&quot;,&quot;heihei&quot;); //4. 关闭 归还到连接池中 jedis.close(); 5.注意1234* 注意：使用redis，缓存一些不经常发生变化的数据。 * 数据库的数据一旦发生改变，则需要更新缓存。 * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入 * 在service对应的增删改方法中，将redis数据删除。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis, jedis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis的相关知识]]></title>
    <url>%2F2019%2F07%2F26%2FMybatis%2F</url>
    <content type="text"><![CDATA[Mybatis1.Mybatis概述123Mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花精力去处理加载驱动，创建连接，创建statement等繁杂的过程Mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由Mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽jdbc api 底层访问细节，使我们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。 2.搭建Mybatis开发环境2.1创建Maven工程1234创建 mybatis01 的工程，工程信息如下：Groupid:com.holicCodeArtifactId:mybatis01Packing:jar 2.2添加Mybatis3.4.5的坐标在pom.xml文件中添加Mybatis3.4.5的坐标，如下： 123456789101112131415161718192021222324&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.3编写必要代码(实体类和持久层接口)2.4编写SqlMapConfig.xml配置文件12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置 mybatis 的环境 --&gt; &lt;environments default="mysql"&gt; &lt;!-- 配置 mysql 的环境 --&gt; &lt;environment id="mysql"&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置连接数据库的信息：用的是数据源(连接池) --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/student"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt;&lt;!-- 告知 mybatis 映射配置的位置 --&gt;&lt;mappers&gt; &lt;mapper resource="com/holicCode/dao/IUserDao.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.5编写映射配置文件2.6编写测试类3.Mybatis中用到的设计模式123工厂模式（SqlSessionFactory）代理模式(MapperProxyFactory)构建者模式(SqlSessionFactoryBuilder) 4.Mybatis与JDBC编程的比较1234567891011121.数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。解决： 在 SqlMapConfig.xml 中配置数据链接池，使用连接池管理数据库链接。2.Sql 语句写在代码中造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java 代码。解决： 将 Sql 语句配置在 XXXXmapper.xml 文件中与 java 代码分离。3.向 sql 语句传参数麻烦，因为 sql 语句的 where 条件不一定，可能多也可能少，占位符需要和参数对应。解决： Mybatis 自动将 java 对象映射至 sql 语句，通过 statement 中的 parameterType 定义输入参数的类型。4.对结果集解析麻烦，sql 变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成 pojo 对象解析比较方便。解决： Mybatis 自动将 sql 执行结果映射至 java 对象，通过 statement 中的resultType 定义输出结果的类型。 5.当编写的实体类属性名和数据库表的列名不一致时5.1出现的问题12查询出来的结果会都为null有时有可能会出现某一列有值的情况,这是因为MySQL在Windows系统中不区分大小写! 5.2解决方案一12修改映射配置文件给映射配置文件的SQL语句中的列名起别名(该方法当我们查询很多事,都使用的话写起来很麻烦) 5.3解决方案二​ resultMap结果类型 12resultMap 标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。在 select 标签中使用 resultMap 属性指定引用即可。同时 resultMap 可以实现将查询结果映射为复杂类型的 pojo，比如在查询结果映射对象中包括 pojo 和 list 实现一对一查询和一对多查询。 6.Mybatis连接池1Mybatis连接池与web中的连接池不同,Mybatis中的连接池使用的自己的连接池技术,在Mybatis的SqlMapConfig.xml配置文件中,通过&lt;dataSource type=&quot;pooled&quot;&gt;来实现Mybatis中连接池的配置。 6.1Mybatis连接池的分类123UNPOOLED 不使用连接池的数据源POOLED 使用连接池的数据源（我们一般使用的数据源）JNDI 使用JNDI实现的数据源 1相应地，MyBatis 内部分别定义了实现了 java.sql.DataSource 接口的 UnpooledDataSource，PooledDataSource 类来表示 UNPOOLED、POOLED 类型的数据源。 6.2Mybatis中数据源的配置123456789101112数据源配置就是在 SqlMapConfig.xml 文件中，具体配置如下：&lt;!-- 配置数据源（连接池）信息 --&gt;&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/dataSource&gt;MyBatis 在初始化时，根据&lt;dataSource&gt;的 type 属性来创建相应类型的的数据源 DataSource，即：type=”POOLED”：MyBatis 会创建 PooledDataSource 实例type=”UNPOOLED” ： MyBatis 会创建 UnpooledDataSource 实例type=”JNDI”：MyBatis 会从 JNDI 服务上查找 DataSource 实例，然后返回使用 7.Mybatis中事务控制7.3Mybatis中事务提交方式1Mybatis中事务的提交方式，本质上就是调用JDBC的setAutoComment（）来实现事务控制，默认情况下setAutoComment（）的参数为false，所以我们要手动使用SqlSession.commit（）来提交事务 7.4Mybatis自动提交事务的设置12在创建SqlSession工厂对象时，传入trueSqlSession session = factory.openSession（true）; 8.Mybatis中的动态SQL语句1234主要就是使用Mybatis中提供的动态SQL语句标签&lt;if&gt;&lt;where&gt;&lt;foreach&gt; 9.Mybatis延迟加载策略9.1何为延迟加载123延迟加载：就是需要用到数据是才进行加载，不需要用到数据时就不加载数据。也称为懒加载 好处：先从单表查询，需要时再关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快 坏处：因为只有当需要用到数据时，才会进行数据库查询，这样大批量数据查询时，因为查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体检下降。 9.2开启Mybatis的延迟加载策略1234567891011121314151617181920212223242526271.需要再Mybatis的配置文件SqlMapConfig.xml文件中添加延迟加载的配置&lt;settings&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt;&lt;/settings&gt;2.使用Collection实现延迟加载&lt;!-- collection 是用于建立一对多中集合属性的对应关系 ofType 用于指定集合元素的数据类型 select 是用于指定查询账户的唯一标识（账户的 dao 全限定类名加上方法名称） column 是用于指定使用哪个字段的值作为条件查询--&gt;&lt;collection property="accounts" ofType="account" select="" column=""&gt;&lt;/collection&gt;&lt;collection&gt;标签：主要用于加载关联的集合对象select 属性：用于指定查询 account 列表的 sql 语句，所以填写的是该 sql 映射的 idcolumn 属性：用于指定 select 属性的 sql 语句的参数来源，上面的参数来自于 user 的 id 列，所以就写成 id 这一个字段名了 10.Mybatis缓存Mybatis通过缓存策略来减少数据库的查询次数，从而提高性能 10.1Mybatis一级缓存12一级缓存是 SqlSession 级别的缓存，只要 SqlSession 没有 flush 或 close，它就存在。一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()等方法时，就会清空一级缓存。 10.2Mybatis二级缓存1二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。 10.2.1二级缓存的开启与关闭12345678910111213141516171819202122232425第一步：在SqlMapConfig.xml文件开启二级缓存&lt;settings&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;因为 cacheEnabled 的取值默认就为 true，所以这一步可以省略不配置。为 true 代表开启二级缓存；为false 代表不开启二级缓存。第二步：配置相关的Mapper映射文件&lt;cache&gt;标签表示当前这个 mapper 映射将使用二级缓存，区分的标准就看 mapper 的 namespace 值。&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.holicCode.dao.IUserDao&quot;&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;cache&gt;&lt;/cache&gt;&lt;/mapper&gt;第三部：配置statement上面的useCache属性&lt;!-- 根据 id 查询 --&gt;&lt;select id=&quot;findById&quot; resultType=&quot;user&quot; parameterType=&quot;int&quot; useCache=&quot;true&quot;&gt; select * from user where id = #&#123;uid&#125;&lt;/select&gt; 将 UserDao.xml 映射文件中的&lt;select&gt;标签中设置 useCache=”true”代表当前这个 statement 要使用二级缓存，如果不使用二级缓存可以设置为 false。注意：针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存 10.2.2基于注解的二级缓存123456789101.在SqlMapConfig中开启二级缓存支持&lt;!-- 配置二级缓存 --&gt;&lt;settings&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;setting name="cacheEnabled" value="true"/&gt;&lt;/settings&gt;2.在持久层接口中使用注解配置二级缓存@CacheNamespace(blocking=true)//mybatis 基于注解方式实现配置二级缓存public interface IUserDao &#123;&#125; 10.2.3二级缓存的注意事项1当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable 接口，这种就可以使用序列化方式来保存对象。 11.Mybatis的注解开发11.1Mybatis常用注解说明1234567891011@Insert:实现新增@Update:实现更新@Delete:实现删除@Select:实现查询@Result:实现结果集封装@Results:可以与@Result 一起使用，封装多个结果集@ResultMap:实现引用@Results 定义的封装@One:实现一对一结果集封装@Many:实现一对多结果集封装@SelectProvider: 实现动态 SQL 映射@CacheNamespace:实现注解二级缓存的使用]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL初级]]></title>
    <url>%2F2019%2F07%2F24%2FMySQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[MySQL基础知识汇总数据库的基本概念1. 数据库的英文单词： DataBase 简称 ： DB 2. 什么数据库？ * 用于存储和管理数据的仓库。 3. 数据库的特点： 1. 持久化存储数据的。其实数据库就是一个文件系统 2. 方便存储和管理数据 3. 使用了统一的方式操作数据库 -- SQLMySQL数据库软件1. 安装 2. 卸载 1. 去mysql的安装目录找到my.ini文件 * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot; 2. 卸载MySQL 3. 删除C:/ProgramData目录下的MySQL文件夹。 3. 配置 * MySQL服务启动 1. 手动。 2. cmd--&gt; services.msc 打开服务的窗口 3. 使用管理员打开cmd * net start mysql : 启动mysql的服务 * net stop mysql:关闭mysql服务 * MySQL登录 1. mysql -uroot -p密码 2. mysql -hip -uroot -p连接目标的密码 3. mysql --host=ip --user=root --password=连接目标的密码 * MySQL退出 1. exit 2. quit * MySQL目录结构 1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot; * 配置文件 my.ini 2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot; * 几个概念 * 数据库：文件夹 * 表：文件 * 数据：数据SQL1.什么是SQL？ Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 2.SQL通用语法 1. SQL 语句可以单行或多行书写，以分号结尾。 2. 可使用空格和缩进来增强语句的可读性。 3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 4. 3 种注释 * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) * 多行注释: /* 注释 */ 3. SQL分类 1) DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 2) DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 3) DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 4) DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL:操作数据库、表1. 操作数据库：CRUD 1. C(Create):创建 * 创建数据库： * create database 数据库名称; * 创建数据库，判断不存在，再创建： * create database if not exists 数据库名称; * 创建数据库，并指定字符集 * create database 数据库名称 character set 字符集名; * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk * create database if not exists db4 character set gbk; 2. R(Retrieve)：查询 * 查询所有数据库的名称: * show databases; * 查询某个数据库的字符集:查询某个数据库的创建语句 * show create database 数据库名称; 3. U(Update):修改 * 修改数据库的字符集 * alter database 数据库名称 character set 字符集名称; 4. D(Delete):删除 * 删除数据库 * drop database 数据库名称; * 判断数据库存在，存在再删除 * drop database if exists 数据库名称; 5. 使用数据库 * 查询当前正在使用的数据库名称 * select database(); * 使用数据库 * use 数据库名称; 2. 操作表 1. C(Create):创建 1. 语法： create table 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n ); * 注意：最后一列，不需要加逗号（,） * 数据库类型： 1. int：整数类型 * age int, 2. double:小数类型 * score double(5,2) 3. date:日期，只包含年月日，yyyy-MM-dd 4. datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 5. timestamp:时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 6. varchar：字符串 * name varchar(20):姓名最大20个字符 * zhangsan 8个字符 张三 2个字符12345678910111213141516171819202122232425262728293031 * 创建表 create table student( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp ); * 复制表： * create table 表名 like 被复制的表名; 2. R(Retrieve)：查询 * 查询某个数据库中所有的表名称 * show tables; * 查询表结构 * desc 表名;3. U(Update):修改 1. 修改表名 alter table 表名 rename to 新的表名; 2. 修改表的字符集 alter table 表名 character set 字符集名称; 3. 添加一列 alter table 表名 add 列名 数据类型; 4. 修改列名称 类型 alter table 表名 change 列名 新列别 新数据类型; alter table 表名 modify 列名 新数据类型; 5. 删除列 alter table 表名 drop 列名;4. D(Delete):删除 * drop table 表名; * drop table if exists 表名 ; DML：增删改表中数据1. 添加数据： * 语法： * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n); * 注意： 1. 列名和值要一一对应。 2. 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,...值n); 3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来 2. 删除数据： * 语法： * delete from 表名 [where 条件] * 注意： 1. 如果不加条件，则删除表中所有记录。 2. 如果要删除所有记录 1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作 2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 3. 修改数据： * 语法： * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件]; * 注意： 1. 如果不加任何条件，则会将表中所有记录全部修改。DQL：查询表中的记录1234567891011121314151617* select * from 表名;1. 语法： select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定 2. 基础查询 1. 多个字段的查询 select 字段名1，字段名2... from 表名； * 注意： * 如果查询所有字段，则可以使用*来替代字段列表。 2. 去除重复： * distinct 3. 计算列 * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null * 表达式1：哪个字段需要判断是否为null * 如果该字段为null后的替换值。 4. 起别名： * as：as也可以省略1234567891011121314151617181920212223242526272829303132333435363738394041424344453. 条件查询 1. where子句后跟条件 2. 运算符 * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt; * BETWEEN...AND * IN( 集合) * LIKE：模糊查询 * 占位符： * _:单个任意字符 * %：多个任意字符 * IS NULL * and 或 &amp;&amp; * or 或 || * not 或 ! -- 查询年龄大于20岁 SELECT * FROM student WHERE age &gt; 20; SELECT * FROM student WHERE age &gt;= 20; -- 查询年龄等于20岁 SELECT * FROM student WHERE age = 20; -- 查询年龄不等于20岁 SELECT * FROM student WHERE age != 20; SELECT * FROM student WHERE age &lt;&gt; 20; -- 查询年龄大于等于20 小于等于30 SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30; SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30; SELECT * FROM student WHERE age BETWEEN 20 AND 30; -- 查询年龄22岁，18岁，25岁的信息 SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25 SELECT * FROM student WHERE age IN (22,18,25); -- 查询英语成绩为null SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断 SELECT * FROM student WHERE english IS NULL; -- 查询英语成绩不为null SELECT * FROM student WHERE english IS NOT NULL; 1234567891011-- 查询姓马的有哪些？ likeSELECT * FROM student WHERE NAME LIKE '马%';-- 查询姓名第二个字是化的人SELECT * FROM student WHERE NAME LIKE "_化%";-- 查询姓名是3个字的人SELECT * FROM student WHERE NAME LIKE '___';-- 查询姓名中包含德的人SELECT * FROM student WHERE NAME LIKE '%德%'; 123456789104. 排序查询 * 语法：order by 子句 * order by 排序字段1 排序方式1 ， 排序字段2 排序方式2... * 排序方式： * ASC：升序，默认的。 * DESC：降序。 * 注意： * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。 1234567891011122. 聚合函数：将一列数据作为一个整体，进行纵向的计算。 1. count：计算个数 1. 一般选择非空的列：主键 2. count(*) 2. max：计算最大值 3. min：计算最小值 4. sum：计算和 5. avg：计算平均值 * 注意：聚合函数的计算，排除null值。 解决方案： 1. 选择不包含非空的列进行计算 2. IFNULL函数 12345678910111213141516171819202122233. 分组查询: 1. 语法：group by 分组字段； 2. 注意： 1. 分组之后查询的字段：分组字段、聚合函数 2. where 和 having 的区别？ 1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来 2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。 -- 按照性别分组。分别查询男、女同学的平均分 SELECT sex , AVG(math) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2; SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2; 1234567891011124. 分页查询 1. 语法：limit 开始的索引,每页查询的条数; 2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数 -- 每页显示3条记录 SELECT * FROM student LIMIT 0,3; -- 第1页 SELECT * FROM student LIMIT 3,3; -- 第2页 SELECT * FROM student LIMIT 6,3; -- 第3页 3. limit 是一个MySQL"方言" 约束123456789101112131415161718* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。 * 分类： 1. 主键约束：primary key 2. 非空约束：not null 3. 唯一约束：unique 4. 外键约束：foreign key* 非空约束：not null，值不能为null 1. 创建表时添加约束 CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL -- name为非空 ); 2. 创建表完后，添加非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; 3. 删除name的非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546* 唯一约束：unique，值不能重复 1. 创建表时，添加唯一约束 CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束 ); * 注意mysql中，唯一约束限定的列的值可以有多个null 2. 删除唯一约束 ALTER TABLE stu DROP INDEX phone_number; 3. 在创建表后，添加唯一约束 ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;* 主键约束：primary key。 1. 注意： 1. 含义：非空且唯一 2. 一张表只能有一个字段为主键 3. 主键就是表中记录的唯一标识 2. 在创建表时，添加主键约束 create table stu( id int primary key,-- 给id添加主键约束 name varchar(20) ); 3. 删除主键 -- 错误 alter table stu modify id int ; ALTER TABLE stu DROP PRIMARY KEY; 4. 创建完表后，添加主键 ALTER TABLE stu MODIFY id INT PRIMARY KEY; 5. 自动增长： 1. 概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长 2. 在创建表时，添加主键约束，并且完成主键自增长 create table stu( id int primary key auto_increment,-- 给id添加主键约束 name varchar(20) ); 3. 删除自动增长 ALTER TABLE stu MODIFY id INT; 4. 添加自动增长 ALTER TABLE stu MODIFY id INT AUTO_INCREMENT; 12345678910111213141516171819202122* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。 1. 在创建表时，可以添加外键 * 语法： create table 表名( .... 外键列 constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) ); 2. 删除外键 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 3. 创建表之后，添加外键 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); 4. 级联操作 1. 添加级联操作 语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE ; 2. 分类： 1. 级联更新：ON UPDATE CASCADE 2. 级联删除：ON DELETE CASCADE 数据库的设计123456789101112131415161718192021222324252627282930313233343536373839404142431. 多表之间的关系 1. 分类： 1. 一对一(了解)： * 如：人和身份证 * 分析：一个人只有一个身份证，一个身份证只能对应一个人 2. 一对多(多对一)： * 如：部门和员工 * 分析：一个部门有多个员工，一个员工只能对应一个部门 3. 多对多： * 如：学生和课程 * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择 2. 实现关系： 1. 一对多(多对一)： * 如：部门和员工 * 实现方式：在多的一方建立外键，指向一的一方的主键。 2. 多对多： * 如：学生和课程 * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 3. 一对一(了解)： * 如：人和身份证 * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。 3. 案例 /*创建用户表 tab_user uid 用户主键，自增长 username 用户名长度 100，唯一，非空 password 密码长度 30，非空 name 真实姓名长度 100 birthday 生日 sex 性别，定长字符串 1 telephone 手机号，字符串 11 email 邮箱，字符串长度 100 */ CREATE TABLE tab_user ( uid INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) UNIQUE NOT NULL, PASSWORD VARCHAR(30) NOT NULL, NAME VARCHAR(100), birthday DATE, sex CHAR(1) DEFAULT '男', telephone VARCHAR(11), email VARCHAR(100) ); 数据库设计的范式123456789101112131415161. 第一范式（1NF）：每一列都是不可分割的原子数据项2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） * 几个概念： 1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A 例如：学号--&gt;姓名。 （学号，课程名称） --&gt; 分数 2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。 例如：（学号，课程名称） --&gt; 分数 3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。 例如：（学号，课程名称） -- &gt; 姓名 4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A 例如：学号--&gt;系名，系名--&gt;系主任 5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码 例如：该表中码为：（学号，课程名称） * 主属性：码属性组中的所有属性 * 非主属性：除过码属性组的属性3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 数据库的备份和还原123456789101. 命令行： * 语法： * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 * 还原： 1. 登录数据库 2. 创建数据库 3. 使用数据库 4. 执行文件。source 文件路径2. 也可以使用图形化工具, 更加方便 推荐 Navicat for MySQL, 个人觉得比较好用 MySQL的多表查询&amp;事务多表查询123456* 查询语法： select 列名列表 from 表名列表 where.... 123* 笛卡尔积： * 有两个集合A,B .取这两个集合的所有组成情况。 * 要完成多表查询，需要消除无用的数据 1234567* 多表查询的分类： 1. 内连接查询： 1. 隐式内连接：使用where条件消除无用数据 * 语法： SELECT * FROM 表1,表2 WHERE 表名1.`表1的外键` = 表2的主键; 其中表1的外键是表二的主键 2. 显式内连接： * 语法： select 字段列表 from 表1 [inner] join 表2 on 条件 事务1234567891011121314151617181920212223242526272829301. 事务的基本介绍 1. 概念: 如果一个包含多个步骤的业务操作, 被事务管理, 那么这些操作要么都成功, 要们都失败 2.操作: 1.开启事务: start transaction; 2.回滚: rollback; 3.提交: commit;2. 事务的四大特征(ACID): 1. 原子性(Atomicity): 是不可分割的最小操作单位, 要么都成功, 要么都失败 2. 一致性(Consistency): 事务操作前后, 数据总量不变 3. 隔离性(Isolation): 多个事务之间, 相互独立 4. 持久性(Durability): 当事务提交或回滚后, 数据库会持久化的保存数据3. 事务的隔离级别 1. 概念: 多个事务之间是隔离的,相互独立的, 但是如果多个事务操作同一批数据, 则会引发一些问题,设置不同的隔离级别就可以解决这些问题 2. 存在的问题: 1.脏读: 一个事务,读取到另一个事务中没有提交的数据 2.不可重复读(虚读): 在同一个事务中,两次读取到的数据不一样 2.幻读: 一个事务操作(DML)数据表中的所有记录, 另一个事务添加了一条数据,则第一个事务查询不到自己的修改 3. 隔离级别: 1.read uncommitted: 读未提交 产生的问题: 脏读, 不可重复读, 幻读 2. read committed: 读已提交(Oracle) 产生的问题: 不可重复读, 幻读 3. repeatable read: 可重复读(MySQL默认) 产生的问题: 幻读 4. serializable: 串行化 可以解决所有问题 注意: 隔离级别从小到大安全性越来越高, 但是效率越来越低 数据库查询隔离级别: select @@tx_isolation; 数据库设置隔离级别: set global transaction isolation level 级别字符串; DCL1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950DCL：管理用户，授权 1. 管理用户 1. 添加用户： * 语法：CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 2. 删除用户： * 语法：DROP USER '用户名'@'主机名'; 3. 修改用户密码： UPDATE USER SET PASSWORD = PASSWORD('新密码') WHERE USER = '用户名'; UPDATE USER SET PASSWORD = PASSWORD('abc') WHERE USER = 'lisi'; SET PASSWORD FOR '用户名'@'主机名' = PASSWORD('新密码'); SET PASSWORD FOR 'root'@'localhost' = PASSWORD('123'); * mysql中忘记了root用户的密码？ 1. cmd -- &gt; net stop mysql 停止mysql服务 * 需要管理员运行该cmd 2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables 3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功 4. use mysql; 5. update user set password = password('你的新密码') where user = 'root'; 6. 关闭两个窗口 7. 打开任务管理器，手动结束mysqld.exe 的进程 8. 启动mysql服务 9. 使用新密码登录。 4. 查询用户： -- 1. 切换到mysql数据库 USE myql; -- 2. 查询user表 SELECT * FROM USER; * 通配符： % 表示可以在任意主机使用用户登录数据库 2. 权限管理： 1. 查询权限： -- 查询权限 SHOW GRANTS FOR '用户名'@'主机名'; SHOW GRANTS FOR 'lisi'@'%'; 2. 授予权限： -- 授予权限 grant 权限列表 on 数据库名.表名 to '用户名'@'主机名'; -- 给张三用户授予所有权限，在任意数据库任意表上 GRANT ALL ON *.* TO 'zhangsan'@'localhost'; 3. 撤销权限： -- 撤销权限： revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名'; REVOKE UPDATE ON db3.`account` FROM 'lisi'@'%';]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>MySQL, sql语句, MySQL概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题库以及详解]]></title>
    <url>%2F2019%2F07%2F24%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[剑指offer第一题题目:在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路:因为这个二维数组是有序的, 可以先定位到左下角, 判断要找的数, 如果target &gt; 左下角 就往右找, 然后target &lt; 左下角 就往上找 1234567891011121314151617181920public class Solution &#123; public boolean Find(int target, int [][] array) &#123; //得到二维数组的行和列 int rows = array.length; int cols = array[0].length; //定位到左下角 int i = rows - 1; int j = 0; //循环查找, 不知道循环次数, 用while while(i &gt;= 0 &amp;&amp; j &lt; cols)&#123; if(target &gt; array[i][j]) j++; else if(target &lt; array[i][j]) i--; else return true; &#125; return false; &#125;&#125; 第二题题目: 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路:首先不能使用String提供的replace()方法 ①从前往后替换, 每替换一次后面的字符就要移动一次, 效率低下 ②从后往前替换, 每个字符只需要移动一次, 所以选择这个思路 1234567891011121314151617181920212223242526public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; //计算空格数 int spacenum = 0; for(int i = 0; i &lt; str.length(); i++)&#123; if(str.charAt(i) == ' ') spacenum++; &#125; //扩容 int indexOld = str.length() - 1; int newLength = str.length() + spacenum * 2; int indexNew = newLength - 1; str.setLength(indexNew); //替换 for(;indexOld &gt;= 0 &amp;&amp; newLength &gt; indexOld; --indexOld)&#123; if(str.charAt(indexOld) == ' ')&#123; str.setCharAt(indexNew--, '0'); str.setCharAt(indexNew--, '2'); str.setCharAt(indexNew--, '%'); &#125; else &#123; str.setCharAt(indexNew--, str.charAt(indexOld)); &#125; &#125; return str.toString(); &#125;&#125; 第三题题目: 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125; 代码实现: 解法一: 递归 123456789101112131415import java.util.ArrayList;public class Solution &#123; //先创建一个 ArrayList 集合 ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; //判断传入的链表是否不为空 if(listNode != null)&#123; //递归调用 printListFromTailToHead()方法, 传入链表的元素 this.printListFromTailToHead(listNode.next); //将遍历出来的链表的元素的值添加入 arrayList 中 arrayList.add(listNode.val); &#125; return arrayList; &#125;&#125; 解法二: 利用栈(先进后出) 1234567891011121314151617import java.util.ArrayList;import java.util.Stack;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack&lt;Integer&gt; temp = new Stack&lt;&gt;(); ArrayList&lt;Integer&gt; newList = new ArrayList&lt;&gt;(); ListNode t = listNode; while( t != null )&#123; temp.push(t.val); t = t.next; &#125; while( !temp.empty() )&#123; newList.add(temp.pop()); &#125; return newList; &#125;&#125; 第四题题目: 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 1234567Definition for binary tree public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x;&#125; &#125; 代码实现: 12345678910111213141516171819202122public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; TreeNode root=reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1); return root; &#125; //前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125; private TreeNode reConstructBinaryTree(int [] pre,int startPre,int endPre,int [] in,int startIn,int endIn) &#123; if(startPre&gt;endPre||startIn&gt;endIn) return null; TreeNode root= new TreeNode(pre[startPre]); //前序遍历结果的 第一个元素就是根节点 for(int i=startIn;i&lt;=endIn;i++) if(in[i]==pre[startPre])&#123; root.left=reConstructBinaryTree(pre,startPre+1,startPre+i-startIn,in,startIn,i-1); root.right=reConstructBinaryTree(pre,i-startIn+startPre+1,endPre,in,i+1,endIn); break; &#125; return root; &#125;&#125; 第五题题目: 用两个栈来实现一个队列,完成队列的Push和Pop操作, 队列中的元素为 int 类型 思路: 首先栈是先进后出, 队列是先进先出 12345678910111213141516171819202122232425import java.util.Stack; public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); //队列的 push 操作和 栈的 push 是相同的 public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; //判断 stack1 和 stack2 是否为空 if(stack1.empty()&amp;&amp;stack2.empty())&#123; throw new RuntimeException("Queue is empty!"); &#125; if(stack2.empty())&#123; while(!stack1.empty())&#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.pop(); &#125;&#125; 第六题题目:把一个数组最开始的若干元素搬到数组的末尾, 我们称之为数组的旋转. 输入一个非减排序的数组的一个旋转, 输出旋转数组的最小元素.例如数组{3,4,5,1,2} 为 {1,2,3,4,5}, 该数组的最小值为1, NOTE: 给出的所有元素都大于0, 若数组大小为0 ,请返回0 思路:(1)array[mid] &gt; array[high]: 出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。 low = mid + 1 (2)array[mid] == array[high]: 出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边 还是右边,这时只好一个一个试 ， high = high - 1 (3)array[mid] &lt; array[high]: 出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左 边。因为右边必然都是递增的。 high = mid 12345678910111213141516171819202122import java.util.ArrayList;public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; int low = 0; int hight = array.length - 1; while(low &lt; hight)&#123; //中间的位置 int mid = low + (hight - low)/2; //若中间的数 &gt; 最后一个数, 最小的数就是中间数的下一个 if(array[mid] &gt; array[hight])&#123; low = mid + 1; //若中间的数 = 最后一个数, 最小的数左右都有可能, 所有要缩小,继续找 &#125;else if(array[mid] == array[hight])&#123; hight -= 1; //若中间的数 &lt; 最后一个数, 最小的数只能是中间的数,或,中间数的左边的数中的某一个 &#125;else&#123; hight = mid; &#125; &#125; return array[low]; &#125;&#125; 第七题题目: 输入一个整数n, 请你输出斐波那契列的第n项(从0开始,第0项为0) 思路一: 采用递归, 这种解法效率低, 每次都要调自己 123456789public class Solution &#123; public int Fibonacci(int n) &#123; if(n &lt; 2)&#123; return n; &#125;else&#123; return Fibonacci(n - 1) + Fibonacci(n - 2); &#125; &#125;&#125; 思路二: 1234567891011121314public class Solution &#123; public int Fibonacci(int n) &#123; if(n &lt; 0) throw new IllegalArgumentException("输入的数不能小于0"); if(n == 0 || n == 1) return n; int a = 1, b = 0, sum = 0; for(int i = 2;i &lt;= n;i++)&#123; sum = a + b; b = a; a = sum; &#125; return sum; &#125;&#125; 第八题题目: 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 思路: 这还是一个斐波那契列, 唯一不同的是从1开始 1234567891011121314public class Solution &#123; public int JumpFloor(int target) &#123; if(target &lt; 1) throw new IllegalArgumentException("台阶数不能小于1");; if(target &lt; 3) return target; int a = 1, b = 2, sum = 0; for(int i = 3;i &lt;= target;i++)&#123; sum = a + b; a = b; b = sum; &#125; return sum; &#125;&#125; 第九题题目: 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。 求该青蛙跳上一个n级的台阶总共有多少种跳法。分析: f(1) = 1 f(2) = f(2-1) + f(2-2) //f(2-2) 表示2阶一次跳2阶的次数。 f(3) = f(3-1) + f(3-2) + f(3-3) … f(n) = f(n-1) + f(n-2) + f(n-3) + … + f(n-(n-1)) + f(n-n) 说明： 1）这里的f(n) 代表的是n个台阶有一次1,2,...n阶的 跳法数。 2）n = 1时，只有1种跳法，f(1) = 1 3) n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ，f(2) = f(2-1) + f(2-2) 4) n = 3时，会有三种跳得方式，1阶、2阶、3阶，那么就是第一次跳出1阶后面剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3) 因此结论是f(3) = f(3-1)+f(3-2)+f(3-3) 5) n = n时，会有n中跳的方式，1阶、2阶...n阶，得出结论： f(n) = f(n-1)+f(n-2)+...+f(n-(n-1)) + f(n-n) =&gt; f(0) + f(1) + f(2) + f(3) + ... + f(n-1) 6) 由以上已经是一种结论，但是为了简单，我们可以继续简化： f(n-1) = f(0) + f(1)+f(2)+f(3) + ... + f((n-1)-1) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2) f(n) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2) + f(n-1) = f(n-1) + f(n-1) 可以得出：f(n) = 2*f(n-1) 7) 得出最终结论,在n阶台阶，一次有1、2、...n阶的跳的方式时，总得跳法为： | 1 ,(n=0 ) f(n) = | 1 ,(n=1 ) | 2*f(n-1),(n&gt;=2)代码实现: 12345678910public class Solution &#123; public int JumpFloorII(int target) &#123; if(target &lt; 0) throw new IllegalArgumentException("台阶数不能小于0"); if(target == 1)&#123; return 1; &#125;else&#123; return 2 * JumpFloorII(target - 1); &#125; &#125;&#125; 第十题题目: 我们可以用2×1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2×n的大矩形，总共有多少种方法？ 分析: 还是一个斐波那契 采用递归: 12345678910public class Solution &#123; public int RectCover(int target) &#123; if(target &lt; 0) throw new IllegalArgumentException("输入的n不能小于0的整数"); if(target == 0 || target == 1 || target == 2)&#123; return target; &#125; else&#123; return RectCover(target - 1) + RectCover(target - 2); &#125; &#125;&#125; 不用递归, 效率比较高的解法: 1234567891011121314public class Solution &#123; public int RectCover(int target) &#123; if(target &lt; 0) throw new IllegalArgumentException("输入的数不能小于0"); if(target == 0 || target == 1) return target; int a = 1, b = 1, sum = 0; for(int i = 2;i &lt;= target;i++)&#123; sum = a + b; b = a; a = sum; &#125; return sum; &#125;&#125; 第十一题题目: 输入一个整数, 输出该数二进制表示中1的个数, 其中负数用补码表示 思路:如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。 举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。 12345678public int NumberOf1(int n)&#123; int count = 0; while(n != 0)&#123; count++; n = n &amp; (n - 1); &#125; return count;&#125; 第十二题题目: 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 解法一: 常规解法, 时间复杂度为O(n) 12345678910111213public class Solution &#123; public double Power(double base, int exponent) &#123; double result = 1; //abs() : 返回这个数的绝对值 for(int i = 0;i &lt; Math.abs(exponent);i++)&#123; result *= base; &#125; if(exponent &lt; 0)&#123; result = 1/result; &#125; return result; &#125;&#125; 解法二: 递归: ​ n为偶数时, a^n = a^(n/2) * a^(n/2) ​ n为奇数时, a^n=（a^（n-1）/2）×（a^（n-1/2））×a 时间复杂度为 O(logn) 12345678910111213public class Solution()&#123; public double Power(double base, int exponent)&#123; int n = Math.abs(exponent); if(n == 0) return 1; if(n == 1) return base; double result = Power(base, n&gt;&gt;1); result *= result; if((n&amp;1) == 1) result *= base; if(exponent &lt; 0) result = 1/result; return result; &#125;&#125; 第十三题题目: 输入一个整数数组,实现一个函数来调整该数组中的数字的顺序,使得所有的奇数位于数组的前半部分,所有的偶数位于数组的后半部分,并保证奇数和奇数,偶数和偶数之间的相对位置不变. 思路: 123首先统计奇数的个数然后新建一个等长数组，设置两个指针，奇数指针从0开始，偶数指针从奇数个数的末尾开始 遍历，填数此方法的时间复杂度为O(n) 123456789101112131415161718192021222324252627public class Solution&#123; public void reOrderArray(int [] array)&#123; if(array.length == 0 ||array.length == 1) return; int oddCount = 0,oddBegin = 0; //创建一个和原数组等长的新数组 int[] newArray = new int[array.length]; //遍历数组 for(int i = 0;i &lt; array.length;i++)&#123; //判断数组元素为奇数时,将oddCount向后移一位, //最终oddCount的位置就是第一个偶数的位置 if((array[i]&amp;1) == 1) oddCount++; &#125; for(int i = 0;i &lt; array.length;i++)&#123; //判断元素为奇数就从新数组的开头位置开始放 if((array[i]&amp;1) == 1)&#123; newArray[oddBegin++] = array[i]; &#125; else&#123; //如果元素为偶数就从新数组的偶数第一个位置开始放 newArray[oddCount++] = array[i]; &#125; &#125; //最后用新数组排好序的元素替换原数组的元素 for(int i = 0;i &lt; array.length;i++)&#123; array[i] = newArray[i]; &#125; &#125;&#125; 第十四题题目: 输入一个链表,输出该链表中倒数第K个节点 123456789/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/ 思路: 定义两个指针, 先让着两个指针都指向链表的头结点, 然后让其中一个指针往后移(k - 1)位, 再让另一个指针开始跑(此时两个指针在相对静止的跑), 当先跑的那个指针到达链表末尾时, 后跑的那个指针到达的位置就是倒数第k的位置 12345678910111213141516171819public class Solution&#123; public ListNode FindKthToTail(ListNode head,int k)&#123; //定义两个指针都指向头结点 ListNode p, q; p = q = head; //记录k值 int a = k; //记录节点个数 int count = 0; while(p != null)&#123; p = p.next; count++; if(k &lt; 1) q = q.next; k--; &#125; if(count &lt; a) return null; return q; &#125;&#125; 12345678910111213精简写法public class Solution&#123; public ListNode FindKthToTail(ListNode head,int k)&#123; ListNode p, q; p = q = head; int i = 0; for( ; p != null; i++)&#123; if(i &gt;= k) q = q.next; p = p.next; &#125; return i &lt; k ? null : q; &#125;&#125; 第十五题题目: 输入一个人链表, 反转链表后, 输出新链表的表头. 123456789/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/ 题解 12345678910111213141516171819202122232425262728293031public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; if(head==null) return null; //head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null； ListNode pre = null; ListNode next = null; //当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点 //需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre&lt;-head next1-&gt;next2 //即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了 //所以需要用到pre和next两个节点 //1-&gt;2-&gt;3-&gt;4-&gt;5 //1&lt;-2&lt;-3 4-&gt;5 while(head!=null)&#123; //做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre //如此就可以做到反转链表的效果 //先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂 next = head.next; //保存完next，就可以让head从指向next变成指向pre了，代码如下 head.next = pre; //head指向pre后，就继续依次反转下一个节点 //让pre，head，next依次向后移动一个节点，继续下一次的指针反转 pre = head; head = next; &#125; //如果head为null的时候，pre就为最后一个节点了，但是链表已经反转完毕，pre就是反转后链表的第一个节点 //直接输出pre就是我们想要得到的反转后的链表 return pre; &#125;&#125; 未完,待续……….]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>剑指offer, 算法, 详解</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>holicCode&#39;s blog</title>
  
  <subtitle>Engineer in training</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-27T12:15:28.216Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>holicCode</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis的相关知识</title>
    <link href="http://yoursite.com/2019/07/27/Redis%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/07/27/Redis的相关知识/</id>
    <published>2019-07-27T12:15:27.889Z</published>
    <updated>2019-07-27T12:15:28.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1-概念：redis是一款高性能的NoSQL系列的非关系型数据库"><a href="#1-概念：redis是一款高性能的NoSQL系列的非关系型数据库" class="headerlink" title="1.概念：redis是一款高性能的NoSQL系列的非关系型数据库"></a>1.概念：redis是一款高性能的NoSQL系列的非关系型数据库</h2><h3 id="1-1什么是NoSQL"><a href="#1-1什么是NoSQL" class="headerlink" title="1.1什么是NoSQL"></a>1.1什么是NoSQL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1.1.什么是NoSQL</span><br><span class="line">NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。</span><br><span class="line">随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。</span><br><span class="line"></span><br><span class="line">1.1.1.NOSQL和关系型数据库比较</span><br><span class="line">优点：</span><br><span class="line">1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。</span><br><span class="line">2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。</span><br><span class="line">3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。</span><br><span class="line">4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。</span><br><span class="line">2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。</span><br><span class="line">3）不提供关系型数据库对事务的处理。</span><br><span class="line"></span><br><span class="line">1.1.2.非关系型数据库的优势：</span><br><span class="line">1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</span><br><span class="line">2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</span><br><span class="line"></span><br><span class="line">1.1.3.关系型数据库的优势：</span><br><span class="line">1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</span><br><span class="line">2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</span><br><span class="line"></span><br><span class="line">1.1.4.总结</span><br><span class="line">关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，</span><br><span class="line">让NoSQL数据库对关系型数据库的不足进行弥补。</span><br><span class="line">一般会将数据存储在关系型数据库中，在Nosql数据库中备份存储关系型数据库的数据</span><br></pre></td></tr></table></figure><h3 id="1-2主流的NoSQL产品"><a href="#1-2主流的NoSQL产品" class="headerlink" title="1.2主流的NoSQL产品"></a>1.2主流的NoSQL产品</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.2.主流的NOSQL产品</span><br><span class="line">•键值(Key-Value)存储数据库</span><br><span class="line">    相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB</span><br><span class="line">    典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 </span><br><span class="line">    数据模型： 一系列键值对</span><br><span class="line">    优势： 快速查询</span><br><span class="line">    劣势： 存储的数据缺少结构化</span><br><span class="line">•列存储数据库</span><br><span class="line">    相关产品：Cassandra, HBase, Riak</span><br><span class="line">    典型应用：分布式的文件系统</span><br><span class="line">    数据模型：以列簇式存储，将同一列数据存在一起</span><br><span class="line">    优势：查找速度快，可扩展性强，更容易进行分布式扩展</span><br><span class="line">    劣势：功能相对局限</span><br><span class="line">•文档型数据库</span><br><span class="line">    相关产品：CouchDB、MongoDB</span><br><span class="line">    典型应用：Web应用（与Key-Value类似，Value是结构化的）</span><br><span class="line">    数据模型： 一系列键值对</span><br><span class="line">    优势：数据结构要求不严格</span><br><span class="line">    劣势： 查询性能不高，而且缺乏统一的查询语法</span><br><span class="line">•图形(Graph)数据库</span><br><span class="line">    相关数据库：Neo4J、InfoGrid、Infinite Graph</span><br><span class="line">    典型应用：社交网络</span><br><span class="line">    数据模型：图结构</span><br><span class="line">    优势：利用图结构相关算法。</span><br><span class="line">    劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</span><br></pre></td></tr></table></figure><h3 id="1-3什么是Redis"><a href="#1-3什么是Redis" class="headerlink" title="1.3什么是Redis"></a>1.3什么是Redis</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.3 什么是Redis</span><br><span class="line">    Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：</span><br><span class="line">    1) 字符串类型 string</span><br><span class="line">    2) 哈希类型 hash</span><br><span class="line">    3) 列表类型 list</span><br><span class="line">    4) 集合类型 set</span><br><span class="line">    5) 有序集合类型 sortedset</span><br><span class="line">1.3.1 redis的应用场景</span><br><span class="line">    •缓存（数据查询、短连接、新闻内容、商品内容等等）</span><br><span class="line">    •聊天室的在线好友列表</span><br><span class="line">    •任务队列。（秒杀、抢购、12306等等）</span><br><span class="line">    •应用排行榜</span><br><span class="line">    •网站访问统计</span><br><span class="line">    •数据过期处理（可以精确到毫秒）</span><br><span class="line">    •分布式集群架构中的session分离</span><br></pre></td></tr></table></figure><h2 id="2-关于Redis中的一些操作"><a href="#2-关于Redis中的一些操作" class="headerlink" title="2.关于Redis中的一些操作"></a>2.关于Redis中的一些操作</h2><h3 id="2-1下载安装"><a href="#2-1下载安装" class="headerlink" title="2.1下载安装"></a>2.1下载安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 官网：https://redis.io</span><br><span class="line">2. 中文网：http://www.redis.net.cn/</span><br><span class="line">3. 解压直接可以使用：</span><br><span class="line">    * redis.windows.conf：配置文件</span><br><span class="line">    * redis-cli.exe：redis的客户端</span><br><span class="line">    * redis-server.exe：redis服务器端</span><br></pre></td></tr></table></figure><h3 id="2-2命令操作"><a href="#2-2命令操作" class="headerlink" title="2.2命令操作"></a>2.2命令操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">1. redis的数据结构：</span><br><span class="line">* redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构</span><br><span class="line">    * value的数据结构：</span><br><span class="line">        1) 字符串类型 string</span><br><span class="line">        2) 哈希类型 hash ： map格式  </span><br><span class="line">        3) 列表类型 list ： linkedlist格式。支持重复元素</span><br><span class="line">        4) 集合类型 set  ： 不允许重复元素</span><br><span class="line">        5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序</span><br><span class="line"></span><br><span class="line">2. 字符串类型 string</span><br><span class="line">    1. 存储： set key value</span><br><span class="line">    2. 获取： get key</span><br><span class="line">    3. 删除： del key</span><br><span class="line">3. 哈希类型 hash</span><br><span class="line">    1. 存储： hset key field value</span><br><span class="line">        127.0.0.1:6379&gt; hset myhash username lisi</span><br><span class="line">        (integer) 1</span><br><span class="line">        127.0.0.1:6379&gt; hset myhash password 123</span><br><span class="line">        (integer) 1</span><br><span class="line">    2. 获取： </span><br><span class="line">        * hget key field: 获取指定的field对应的值</span><br><span class="line">        127.0.0.1:6379&gt; hget myhash username</span><br><span class="line">        &quot;lisi&quot;</span><br><span class="line">        * hgetall key：获取所有的field和value</span><br><span class="line">        127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">        1) &quot;username&quot;</span><br><span class="line">        2) &quot;lisi&quot;</span><br><span class="line">        3) &quot;password&quot;</span><br><span class="line">        4) &quot;123&quot;</span><br><span class="line"></span><br><span class="line">    3. 删除： hdel key field</span><br><span class="line">        127.0.0.1:6379&gt; hdel myhash username</span><br><span class="line">        (integer) 1</span><br><span class="line"></span><br><span class="line">4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边）</span><br><span class="line">    1. 添加：</span><br><span class="line">        1. lpush key value: 将元素加入列表左表</span><br><span class="line"></span><br><span class="line">        2. rpush key value：将元素加入列表右边</span><br><span class="line"></span><br><span class="line">        127.0.0.1:6379&gt; lpush myList a</span><br><span class="line">        (integer) 1</span><br><span class="line">        127.0.0.1:6379&gt; lpush myList b</span><br><span class="line">        (integer) 2</span><br><span class="line">        127.0.0.1:6379&gt; rpush myList c</span><br><span class="line">        (integer) 3</span><br><span class="line">    2. 获取：</span><br><span class="line">        * lrange key start end ：范围获取</span><br><span class="line">        127.0.0.1:6379&gt; lrange myList 0 -1</span><br><span class="line">        1) &quot;b&quot;</span><br><span class="line">        2) &quot;a&quot;</span><br><span class="line">        3) &quot;c&quot;</span><br><span class="line">    3. 删除：</span><br><span class="line">        * lpop key： 删除列表最左边的元素，并将元素返回</span><br><span class="line">        * rpop key： 删除列表最右边的元素，并将元素返回</span><br><span class="line">5. 集合类型 set ： 不允许重复元素</span><br><span class="line">    1. 存储：sadd key value</span><br><span class="line">        127.0.0.1:6379&gt; sadd myset a</span><br><span class="line">        (integer) 1</span><br><span class="line">        127.0.0.1:6379&gt; sadd myset a</span><br><span class="line">        (integer) 0</span><br><span class="line">    2. 获取：smembers key:获取set集合中所有元素</span><br><span class="line">        127.0.0.1:6379&gt; smembers myset</span><br><span class="line">        1) &quot;a&quot;</span><br><span class="line">3. 删除：srem key value:删除set集合中的某个元素</span><br><span class="line">        127.0.0.1:6379&gt; srem myset a</span><br><span class="line">        (integer) 1</span><br><span class="line">6. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</span><br><span class="line"></span><br><span class="line">1. 存储：zadd key score value</span><br><span class="line">        127.0.0.1:6379&gt; zadd mysort 60 zhangsan</span><br><span class="line">        (integer) 1</span><br><span class="line">        127.0.0.1:6379&gt; zadd mysort 50 lisi</span><br><span class="line">        (integer) 1</span><br><span class="line">        127.0.0.1:6379&gt; zadd mysort 80 wangwu</span><br><span class="line">        (integer) 1</span><br><span class="line">2. 获取：zrange key start end [withscores]</span><br><span class="line">        127.0.0.1:6379&gt; zrange mysort 0 -1</span><br><span class="line">        1) &quot;lisi&quot;</span><br><span class="line">        2) &quot;zhangsan&quot;</span><br><span class="line">        3) &quot;wangwu&quot;</span><br><span class="line"></span><br><span class="line">    127.0.0.1:6379&gt; zrange mysort 0 -1 withscores</span><br><span class="line">        1) &quot;zhangsan&quot;</span><br><span class="line">        2) &quot;60&quot;</span><br><span class="line">        3) &quot;wangwu&quot;</span><br><span class="line">        4) &quot;80&quot;</span><br><span class="line">        5) &quot;lisi&quot;</span><br><span class="line">        6) &quot;500&quot;</span><br><span class="line">    3. 删除：zrem key value</span><br><span class="line">        127.0.0.1:6379&gt; zrem mysort lisi</span><br><span class="line">        (integer) 1</span><br><span class="line"></span><br><span class="line">7. 通用命令</span><br><span class="line">    1. keys * : 查询所有的键</span><br><span class="line">    2. type key ： 获取键对应的value的类型</span><br><span class="line">    3. del key：删除指定的key value</span><br></pre></td></tr></table></figure><h2 id="3-Redis的持久化"><a href="#3-Redis的持久化" class="headerlink" title="3.Redis的持久化"></a>3.Redis的持久化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。</span><br><span class="line">2. redis持久化机制：</span><br><span class="line">1. RDB：默认方式，不需要进行配置，默认就使用这种机制</span><br><span class="line">    * 在一定的间隔时间中，检测key的变化情况，然后持久化数据</span><br><span class="line">        1. 编辑redis.windwos.conf文件</span><br><span class="line">        #   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">        save 900 1</span><br><span class="line">        #   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">        save 300 10</span><br><span class="line">        #   after 60 sec if at least 10000 keys changed</span><br><span class="line">        save 60 10000</span><br><span class="line"></span><br><span class="line">     2. 重新启动redis服务器，并指定配置文件名称</span><br><span class="line">        redis-2.8.9&gt;redis-server.exe redis.windows.conf2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据</span><br><span class="line">         1. 编辑redis.windwos.conf文件</span><br><span class="line">            appendonly no（关闭aof） --&gt; appendonly yes （开启aof）</span><br><span class="line"></span><br><span class="line">        # appendfsync always ： 每一次操作都进行持久化</span><br><span class="line">        appendfsync everysec ： 每隔一秒进行一次持久化</span><br><span class="line">        # appendfsync no ： 不进行持久化</span><br><span class="line"></span><br><span class="line">5. Java客户端 Jedis</span><br><span class="line">* Jedis: 一款java操作redis数据库的工具.</span><br><span class="line">* 使用步骤：</span><br><span class="line">1. 下载jedis的jar包，并导入工程中</span><br><span class="line">2. 使用</span><br><span class="line">//1. 获取连接</span><br><span class="line">    Jedis jedis = new Jedis(&quot;localhost&quot;,6379);</span><br><span class="line">   //2. 操作</span><br><span class="line">   jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);</span><br><span class="line">    //3. 关闭连接</span><br><span class="line">    jedis.close();</span><br></pre></td></tr></table></figure><h2 id="4-jedis中连接池：jedisPool的使用"><a href="#4-jedis中连接池：jedisPool的使用" class="headerlink" title="4.jedis中连接池：jedisPool的使用"></a>4.jedis中连接池：jedisPool的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 创建JedisPool连接池对象</span><br><span class="line">    2. 调用方法 getResource()方法获取Jedis连接</span><br><span class="line">    //0.创建一个配置对象</span><br><span class="line">    JedisPoolConfig config = new JedisPoolConfig();</span><br><span class="line">    config.setMaxTotal(50);</span><br><span class="line">    config.setMaxIdle(10);</span><br><span class="line"></span><br><span class="line">    //1.创建Jedis连接池对象</span><br><span class="line">    JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379);</span><br><span class="line"></span><br><span class="line">    //2.获取连接</span><br><span class="line">    Jedis jedis = jedisPool.getResource();</span><br><span class="line">    //3. 使用</span><br><span class="line">    jedis.set(&quot;hehe&quot;,&quot;heihei&quot;);</span><br><span class="line">    //4. 关闭 归还到连接池中</span><br><span class="line">    jedis.close();</span><br></pre></td></tr></table></figure><h2 id="5-注意"><a href="#5-注意" class="headerlink" title="5.注意"></a>5.注意</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 注意：使用redis，缓存一些不经常发生变化的数据。</span><br><span class="line">* 数据库的数据一旦发生改变，则需要更新缓存。</span><br><span class="line">* 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入</span><br><span class="line">* 在service对应的增删改方法中，将redis数据删除。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h1&gt;&lt;h2 id=&quot;1-概念：redis是一款高性能的NoSQL系列的非关系型数据库&quot;&gt;&lt;a href=&quot;#1-概念：redi
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis, jedis" scheme="http://yoursite.com/tags/redis-jedis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis的相关知识</title>
    <link href="http://yoursite.com/2019/07/26/Mybatis/"/>
    <id>http://yoursite.com/2019/07/26/Mybatis/</id>
    <published>2019-07-26T15:29:35.797Z</published>
    <updated>2019-07-26T15:37:04.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="1-Mybatis概述"><a href="#1-Mybatis概述" class="headerlink" title="1.Mybatis概述"></a>1.Mybatis概述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花精力去处理加载驱动，创建连接，创建statement等繁杂的过程</span><br><span class="line">Mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由Mybatis框架执行sql并将结果映射为java对象并返回。</span><br><span class="line">采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽jdbc api 底层访问细节，使我们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。</span><br></pre></td></tr></table></figure><h2 id="2-搭建Mybatis开发环境"><a href="#2-搭建Mybatis开发环境" class="headerlink" title="2.搭建Mybatis开发环境"></a>2.搭建Mybatis开发环境</h2><h3 id="2-1创建Maven工程"><a href="#2-1创建Maven工程" class="headerlink" title="2.1创建Maven工程"></a>2.1创建Maven工程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建 mybatis01 的工程，工程信息如下：</span><br><span class="line">Groupid:com.holicCode</span><br><span class="line">ArtifactId:mybatis01</span><br><span class="line">Packing:jar</span><br></pre></td></tr></table></figure><h3 id="2-2添加Mybatis3-4-5的坐标"><a href="#2-2添加Mybatis3-4-5的坐标" class="headerlink" title="2.2添加Mybatis3.4.5的坐标"></a>2.2添加Mybatis3.4.5的坐标</h3><p>在pom.xml文件中添加Mybatis3.4.5的坐标，如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.4.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.10&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;5.1.6&lt;/version&gt;</span><br><span class="line"> &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="2-3编写必要代码-实体类和持久层接口"><a href="#2-3编写必要代码-实体类和持久层接口" class="headerlink" title="2.3编写必要代码(实体类和持久层接口)"></a>2.3编写必要代码(实体类和持久层接口)</h3><h3 id="2-4编写SqlMapConfig-xml配置文件"><a href="#2-4编写SqlMapConfig-xml配置文件" class="headerlink" title="2.4编写SqlMapConfig.xml配置文件"></a>2.4编写SqlMapConfig.xml配置文件</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line"> PUBLIC <span class="string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"> <span class="string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!-- 配置 mybatis 的环境 --&gt;</span><br><span class="line">&lt;environments <span class="keyword">default</span>=<span class="string">"mysql"</span>&gt;</span><br><span class="line">&lt;!-- 配置 mysql 的环境 --&gt;</span><br><span class="line">&lt;environment id=<span class="string">"mysql"</span>&gt;</span><br><span class="line">&lt;!-- 配置事务的类型 --&gt;</span><br><span class="line">&lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt;</span><br><span class="line">&lt;!-- 配置连接数据库的信息：用的是数据源(连接池) --&gt;</span><br><span class="line">&lt;dataSource type=<span class="string">"POOLED"</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">"driver"</span> value=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span><br><span class="line">&lt;property name=<span class="string">"url"</span> value=<span class="string">"jdbc:mysql://localhost:3306/student"</span>/&gt;</span><br><span class="line">&lt;property name=<span class="string">"username"</span> value=<span class="string">"root"</span>/&gt;</span><br><span class="line">&lt;property name=<span class="string">"password"</span> value=<span class="string">"root"</span>/&gt;</span><br><span class="line">&lt;/dataSource&gt;</span><br><span class="line">&lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br><span class="line">&lt;!-- 告知 mybatis 映射配置的位置 --&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">&lt;mapper resource=<span class="string">"com/holicCode/dao/IUserDao.xml"</span>/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h3 id="2-5编写映射配置文件"><a href="#2-5编写映射配置文件" class="headerlink" title="2.5编写映射配置文件"></a>2.5编写映射配置文件</h3><h3 id="2-6编写测试类"><a href="#2-6编写测试类" class="headerlink" title="2.6编写测试类"></a>2.6编写测试类</h3><h2 id="3-Mybatis中用到的设计模式"><a href="#3-Mybatis中用到的设计模式" class="headerlink" title="3.Mybatis中用到的设计模式"></a>3.Mybatis中用到的设计模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">工厂模式（SqlSessionFactory）</span><br><span class="line">代理模式(MapperProxyFactory)</span><br><span class="line">构建者模式(SqlSessionFactoryBuilder)</span><br></pre></td></tr></table></figure><h2 id="4-Mybatis与JDBC编程的比较"><a href="#4-Mybatis与JDBC编程的比较" class="headerlink" title="4.Mybatis与JDBC编程的比较"></a>4.Mybatis与JDBC编程的比较</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。</span><br><span class="line">解决：</span><br><span class="line">在 SqlMapConfig.xml 中配置数据链接池，使用连接池管理数据库链接。</span><br><span class="line">2.Sql 语句写在代码中造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java 代码。</span><br><span class="line">解决：</span><br><span class="line">将 Sql 语句配置在 XXXXmapper.xml 文件中与 java 代码分离。</span><br><span class="line">3.向 sql 语句传参数麻烦，因为 sql 语句的 where 条件不一定，可能多也可能少，占位符需要和参数对应。</span><br><span class="line">解决：</span><br><span class="line">Mybatis 自动将 java 对象映射至 sql 语句，通过 statement 中的 parameterType 定义输入参数的类型。</span><br><span class="line">4.对结果集解析麻烦，sql 变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成 pojo 对象解析比较方便。</span><br><span class="line">解决：</span><br><span class="line">Mybatis 自动将 sql 执行结果映射至 java 对象，通过 statement 中的resultType 定义输出结果的类型。</span><br></pre></td></tr></table></figure><h2 id="5-当编写的实体类属性名和数据库表的列名不一致时"><a href="#5-当编写的实体类属性名和数据库表的列名不一致时" class="headerlink" title="5.当编写的实体类属性名和数据库表的列名不一致时"></a>5.当编写的实体类属性名和数据库表的列名不一致时</h2><h3 id="5-1出现的问题"><a href="#5-1出现的问题" class="headerlink" title="5.1出现的问题"></a>5.1出现的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查询出来的结果会都为null</span><br><span class="line">有时有可能会出现某一列有值的情况,这是因为MySQL在Windows系统中不区分大小写!</span><br></pre></td></tr></table></figure><h3 id="5-2解决方案一"><a href="#5-2解决方案一" class="headerlink" title="5.2解决方案一"></a>5.2解决方案一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修改映射配置文件</span><br><span class="line">给映射配置文件的SQL语句中的列名起别名(该方法当我们查询很多事,都使用的话写起来很麻烦)</span><br></pre></td></tr></table></figure><h3 id="5-3解决方案二"><a href="#5-3解决方案二" class="headerlink" title="5.3解决方案二"></a>5.3解决方案二</h3><p>​    resultMap结果类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resultMap 标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。</span><br><span class="line">在 select 标签中使用 resultMap 属性指定引用即可。同时 resultMap 可以实现将查询结果映射为复杂类型的 pojo，比如在查询结果映射对象中包括 pojo 和 list 实现一对一查询和一对多查询。</span><br></pre></td></tr></table></figure><h2 id="6-Mybatis连接池"><a href="#6-Mybatis连接池" class="headerlink" title="6.Mybatis连接池"></a>6.Mybatis连接池</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mybatis连接池与web中的连接池不同,Mybatis中的连接池使用的自己的连接池技术,在Mybatis的SqlMapConfig.xml配置文件中,通过&lt;dataSource type=&quot;pooled&quot;&gt;来实现Mybatis中连接池的配置。</span><br></pre></td></tr></table></figure><h3 id="6-1Mybatis连接池的分类"><a href="#6-1Mybatis连接池的分类" class="headerlink" title="6.1Mybatis连接池的分类"></a>6.1Mybatis连接池的分类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UNPOOLED不使用连接池的数据源</span><br><span class="line">POOLED使用连接池的数据源（我们一般使用的数据源）</span><br><span class="line">JNDI使用JNDI实现的数据源</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相应地，MyBatis 内部分别定义了实现了 java.sql.DataSource 接口的 UnpooledDataSource，PooledDataSource 类来表示 UNPOOLED、POOLED 类型的数据源。</span><br></pre></td></tr></table></figure><h3 id="6-2Mybatis中数据源的配置"><a href="#6-2Mybatis中数据源的配置" class="headerlink" title="6.2Mybatis中数据源的配置"></a>6.2Mybatis中数据源的配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">数据源配置就是在 SqlMapConfig.xml 文件中，具体配置如下：</span><br><span class="line">&lt;!-- 配置数据源（连接池）信息 --&gt;</span><br><span class="line">&lt;dataSource type=<span class="string">"POOLED"</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">"driver"</span> value=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span><br><span class="line">&lt;property name=<span class="string">"url"</span> value=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span><br><span class="line">&lt;property name=<span class="string">"username"</span> value=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span><br><span class="line">&lt;property name=<span class="string">"password"</span> value=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span><br><span class="line">&lt;/dataSource&gt;</span><br><span class="line">MyBatis 在初始化时，根据&lt;dataSource&gt;的 type 属性来创建相应类型的的数据源 DataSource，即：</span><br><span class="line">type=”POOLED”：MyBatis 会创建 PooledDataSource 实例</span><br><span class="line">type=”UNPOOLED” ： MyBatis 会创建 UnpooledDataSource 实例</span><br><span class="line">type=”JNDI”：MyBatis 会从 JNDI 服务上查找 DataSource 实例，然后返回使用</span><br></pre></td></tr></table></figure><h2 id="7-Mybatis中事务控制"><a href="#7-Mybatis中事务控制" class="headerlink" title="7.Mybatis中事务控制"></a>7.Mybatis中事务控制</h2><h3 id="7-3Mybatis中事务提交方式"><a href="#7-3Mybatis中事务提交方式" class="headerlink" title="7.3Mybatis中事务提交方式"></a>7.3Mybatis中事务提交方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mybatis中事务的提交方式，本质上就是调用JDBC的setAutoComment（）来实现事务控制，默认情况下setAutoComment（）的参数为false，所以我们要手动使用SqlSession.commit（）来提交事务</span><br></pre></td></tr></table></figure><h3 id="7-4Mybatis自动提交事务的设置"><a href="#7-4Mybatis自动提交事务的设置" class="headerlink" title="7.4Mybatis自动提交事务的设置"></a>7.4Mybatis自动提交事务的设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在创建SqlSession工厂对象时，传入true</span><br><span class="line">SqlSession session = factory.openSession（true）;</span><br></pre></td></tr></table></figure><h2 id="8-Mybatis中的动态SQL语句"><a href="#8-Mybatis中的动态SQL语句" class="headerlink" title="8.Mybatis中的动态SQL语句"></a>8.Mybatis中的动态SQL语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主要就是使用Mybatis中提供的动态SQL语句标签</span><br><span class="line">&lt;if&gt;</span><br><span class="line">&lt;where&gt;</span><br><span class="line">&lt;foreach&gt;</span><br></pre></td></tr></table></figure><h2 id="9-Mybatis延迟加载策略"><a href="#9-Mybatis延迟加载策略" class="headerlink" title="9.Mybatis延迟加载策略"></a>9.Mybatis延迟加载策略</h2><h3 id="9-1何为延迟加载"><a href="#9-1何为延迟加载" class="headerlink" title="9.1何为延迟加载"></a>9.1何为延迟加载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">延迟加载：就是需要用到数据是才进行加载，不需要用到数据时就不加载数据。也称为懒加载</span><br><span class="line">好处：先从单表查询，需要时再关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快</span><br><span class="line">坏处：因为只有当需要用到数据时，才会进行数据库查询，这样大批量数据查询时，因为查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体检下降。</span><br></pre></td></tr></table></figure><h3 id="9-2开启Mybatis的延迟加载策略"><a href="#9-2开启Mybatis的延迟加载策略" class="headerlink" title="9.2开启Mybatis的延迟加载策略"></a>9.2开启Mybatis的延迟加载策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.需要再Mybatis的配置文件SqlMapConfig.xml文件中添加延迟加载的配置</span><br><span class="line"></span><br><span class="line">&lt;settings&gt;</span><br><span class="line">&lt;setting name=<span class="string">"lazyLoadingEnabled"</span> value=<span class="string">"true"</span>/&gt;</span><br><span class="line">&lt;setting name=<span class="string">"aggressiveLazyLoading"</span> value=<span class="string">"false"</span>/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.使用Collection实现延迟加载</span><br><span class="line"></span><br><span class="line">&lt;!-- collection 是用于建立一对多中集合属性的对应关系</span><br><span class="line">ofType 用于指定集合元素的数据类型</span><br><span class="line">select 是用于指定查询账户的唯一标识（账户的 dao 全限定类名加上方法名称）</span><br><span class="line">column 是用于指定使用哪个字段的值作为条件查询</span><br><span class="line">--&gt;</span><br><span class="line">&lt;collection property=<span class="string">"accounts"</span> </span><br><span class="line">    ofType=<span class="string">"account"</span></span><br><span class="line">select=<span class="string">""</span></span><br><span class="line">column=<span class="string">""</span>&gt;</span><br><span class="line">&lt;/collection&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;collection&gt;标签：</span><br><span class="line">主要用于加载关联的集合对象</span><br><span class="line">select 属性：</span><br><span class="line">用于指定查询 account 列表的 sql 语句，所以填写的是该 sql 映射的 id</span><br><span class="line">column 属性：</span><br><span class="line">用于指定 select 属性的 sql 语句的参数来源，上面的参数来自于 user 的 id 列，所以就写成 id 这一个字段名了</span><br></pre></td></tr></table></figure><h2 id="10-Mybatis缓存"><a href="#10-Mybatis缓存" class="headerlink" title="10.Mybatis缓存"></a>10.Mybatis缓存</h2><p>Mybatis通过缓存策略来减少数据库的查询次数，从而提高性能</p><h3 id="10-1Mybatis一级缓存"><a href="#10-1Mybatis一级缓存" class="headerlink" title="10.1Mybatis一级缓存"></a>10.1Mybatis一级缓存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一级缓存是 SqlSession 级别的缓存，只要 SqlSession 没有 flush 或 close，它就存在。</span><br><span class="line">一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()等方法时，就会清空一级缓存。</span><br></pre></td></tr></table></figure><h3 id="10-2Mybatis二级缓存"><a href="#10-2Mybatis二级缓存" class="headerlink" title="10.2Mybatis二级缓存"></a>10.2Mybatis二级缓存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。</span><br></pre></td></tr></table></figure><h4 id="10-2-1二级缓存的开启与关闭"><a href="#10-2-1二级缓存的开启与关闭" class="headerlink" title="10.2.1二级缓存的开启与关闭"></a>10.2.1二级缓存的开启与关闭</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">第一步：在SqlMapConfig.xml文件开启二级缓存</span><br><span class="line">&lt;settings&gt;</span><br><span class="line">&lt;!-- 开启二级缓存的支持 --&gt;</span><br><span class="line">&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br><span class="line">因为 cacheEnabled 的取值默认就为 true，所以这一步可以省略不配置。为 true 代表开启二级缓存；为false 代表不开启二级缓存。</span><br><span class="line"></span><br><span class="line">第二步：配置相关的Mapper映射文件</span><br><span class="line">&lt;cache&gt;标签表示当前这个 mapper 映射将使用二级缓存，区分的标准就看 mapper 的 namespace 值。</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line"> PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line"> &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.holicCode.dao.IUserDao&quot;&gt;</span><br><span class="line">&lt;!-- 开启二级缓存的支持 --&gt;</span><br><span class="line">&lt;cache&gt;&lt;/cache&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br><span class="line"></span><br><span class="line">第三部：配置statement上面的useCache属性</span><br><span class="line">&lt;!-- 根据 id 查询 --&gt;</span><br><span class="line">&lt;select id=&quot;findById&quot; resultType=&quot;user&quot; parameterType=&quot;int&quot; useCache=&quot;true&quot;&gt;</span><br><span class="line">select * from user where id = #&#123;uid&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">将 UserDao.xml 映射文件中的&lt;select&gt;标签中设置 useCache=”true”代表当前这个 statement 要使用二级缓存，如果不使用二级缓存可以设置为 false。</span><br><span class="line">注意：针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存</span><br></pre></td></tr></table></figure><h4 id="10-2-2基于注解的二级缓存"><a href="#10-2-2基于注解的二级缓存" class="headerlink" title="10.2.2基于注解的二级缓存"></a>10.2.2基于注解的二级缓存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.在SqlMapConfig中开启二级缓存支持</span><br><span class="line">&lt;!-- 配置二级缓存 --&gt;</span><br><span class="line">&lt;settings&gt;</span><br><span class="line">&lt;!-- 开启二级缓存的支持 --&gt;</span><br><span class="line">&lt;setting name=<span class="string">"cacheEnabled"</span> value=<span class="string">"true"</span>/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.在持久层接口中使用注解配置二级缓存</span><br><span class="line"><span class="meta">@CacheNamespace</span>(blocking=<span class="keyword">true</span>)<span class="comment">//mybatis 基于注解方式实现配置二级缓存</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-3二级缓存的注意事项"><a href="#10-2-3二级缓存的注意事项" class="headerlink" title="10.2.3二级缓存的注意事项"></a>10.2.3二级缓存的注意事项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable 接口，这种就可以使用序列化方式来保存对象。</span><br></pre></td></tr></table></figure><h2 id="11-Mybatis的注解开发"><a href="#11-Mybatis的注解开发" class="headerlink" title="11.Mybatis的注解开发"></a>11.Mybatis的注解开发</h2><h3 id="11-1Mybatis常用注解说明"><a href="#11-1Mybatis常用注解说明" class="headerlink" title="11.1Mybatis常用注解说明"></a>11.1Mybatis常用注解说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Insert:实现新增</span><br><span class="line">@Update:实现更新</span><br><span class="line">@Delete:实现删除</span><br><span class="line">@Select:实现查询</span><br><span class="line">@Result:实现结果集封装</span><br><span class="line">@Results:可以与@Result 一起使用，封装多个结果集</span><br><span class="line">@ResultMap:实现引用@Results 定义的封装</span><br><span class="line">@One:实现一对一结果集封装</span><br><span class="line">@Many:实现一对多结果集封装</span><br><span class="line">@SelectProvider: 实现动态 SQL 映射</span><br><span class="line">@CacheNamespace:实现注解二级缓存的使用</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mybatis&quot;&gt;&lt;a href=&quot;#Mybatis&quot; class=&quot;headerlink&quot; title=&quot;Mybatis&quot;&gt;&lt;/a&gt;Mybatis&lt;/h1&gt;&lt;h2 id=&quot;1-Mybatis概述&quot;&gt;&lt;a href=&quot;#1-Mybatis概述&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Mybatis" scheme="http://yoursite.com/categories/Mybatis/"/>
    
    
      <category term="Mybatis" scheme="http://yoursite.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL初级</title>
    <link href="http://yoursite.com/2019/07/24/MySQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/07/24/MySQL基础知识/</id>
    <published>2019-07-24T11:09:20.220Z</published>
    <updated>2019-07-26T15:48:42.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL基础知识汇总"><a href="#MySQL基础知识汇总" class="headerlink" title="MySQL基础知识汇总"></a>MySQL基础知识汇总</h1><h2 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h2><pre><code>1. 数据库的英文单词： DataBase 简称 ： DB2. 什么数据库？    * 用于存储和管理数据的仓库。3. 数据库的特点：    1. 持久化存储数据的。其实数据库就是一个文件系统    2. 方便存储和管理数据    3. 使用了统一的方式操作数据库 -- SQL</code></pre><h2 id="MySQL数据库软件"><a href="#MySQL数据库软件" class="headerlink" title="MySQL数据库软件"></a>MySQL数据库软件</h2><pre><code>1. 安装2. 卸载    1. 去mysql的安装目录找到my.ini文件        * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;    2. 卸载MySQL    3. 删除C:/ProgramData目录下的MySQL文件夹。3. 配置    * MySQL服务启动        1. 手动。        2. cmd--&gt; services.msc 打开服务的窗口        3. 使用管理员打开cmd            * net start mysql : 启动mysql的服务            * net stop mysql:关闭mysql服务    * MySQL登录        1. mysql -uroot -p密码        2. mysql -hip -uroot -p连接目标的密码        3. mysql --host=ip --user=root --password=连接目标的密码    * MySQL退出        1. exit        2. quit    * MySQL目录结构        1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot;            * 配置文件 my.ini        2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;            * 几个概念                * 数据库：文件夹                * 表：文件                * 数据：数据</code></pre><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><pre><code>1.什么是SQL？    Structured Query Language：结构化查询语言    其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。2.SQL通用语法    1. SQL 语句可以单行或多行书写，以分号结尾。    2. 可使用空格和缩进来增强语句的可读性。    3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。    4. 3 种注释        * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有)         * 多行注释: /* 注释 */3. SQL分类    1) DDL(Data Definition Language)数据定义语言        用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等    2) DML(Data Manipulation Language)数据操作语言        用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等    3) DQL(Data Query Language)数据查询语言        用来查询数据库中表的记录(数据)。关键字：select, where 等    4) DCL(Data Control Language)数据控制语言(了解)        用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</code></pre><p><img src="G:%5C%E9%BB%91%E9%A9%AC%E5%BF%85%E7%9C%8B%E8%A7%86%E9%A2%91%5C%E8%AE%B2%E4%B9%89+%E7%AC%94%E8%AE%B0+%E8%B5%84%E6%96%99%5CJavaWeb%5C12.%E4%BC%9A%E5%91%98%E7%89%88(2.0)-%E5%B0%B1%E4%B8%9A%E8%AF%BE(2.0)-MySQL%5C26.MySQL%E5%9F%BA%E7%A1%80%5Cday22_MySQL%E5%9F%BA%E7%A1%80%5C01_%E8%AE%B2%E4%B9%89%5CSQL%E5%88%86%E7%B1%BB.bmp" alt="SQL分类"></p><h2 id="DDL-操作数据库、表"><a href="#DDL-操作数据库、表" class="headerlink" title="DDL:操作数据库、表"></a>DDL:操作数据库、表</h2><pre><code>1. 操作数据库：CRUD    1. C(Create):创建        * 创建数据库：            * create database 数据库名称;        * 创建数据库，判断不存在，再创建：            * create database if not exists 数据库名称;        * 创建数据库，并指定字符集            * create database 数据库名称 character set 字符集名;        * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk            * create database if not exists db4 character set gbk;    2. R(Retrieve)：查询        * 查询所有数据库的名称:            * show databases;        * 查询某个数据库的字符集:查询某个数据库的创建语句            * show create database 数据库名称;    3. U(Update):修改        * 修改数据库的字符集            * alter database 数据库名称 character set 字符集名称;    4. D(Delete):删除        * 删除数据库            * drop database 数据库名称;        * 判断数据库存在，存在再删除            * drop database if exists 数据库名称;    5. 使用数据库        * 查询当前正在使用的数据库名称            * select database();        * 使用数据库            * use 数据库名称;2. 操作表    1. C(Create):创建        1. 语法：            create table 表名(                列名1 数据类型1,                列名2 数据类型2,                ....                列名n 数据类型n            );            * 注意：最后一列，不需要加逗号（,）            * 数据库类型：                1. int：整数类型                    * age int,                2. double:小数类型                    * score double(5,2)                3. date:日期，只包含年月日，yyyy-MM-dd                4. datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss                5. timestamp:时间错类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss                        * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值                6. varchar：字符串                    * name varchar(20):姓名最大20个字符                    * zhangsan 8个字符  张三 2个字符</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">* 创建表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>),</span><br><span class="line">age <span class="built_in">int</span> ,</span><br><span class="line">score <span class="keyword">double</span>(<span class="number">4</span>,<span class="number">1</span>),</span><br><span class="line">birthday <span class="built_in">date</span>,</span><br><span class="line">insert_time <span class="built_in">timestamp</span></span><br><span class="line">);</span><br><span class="line">* 复制表：</span><br><span class="line">* create table 表名 like 被复制的表名;  </span><br><span class="line">2. R(Retrieve)：查询</span><br><span class="line">* 查询某个数据库中所有的表名称</span><br><span class="line">* show tables;</span><br><span class="line">* 查询表结构</span><br><span class="line">* desc 表名;</span><br><span class="line">3. U(<span class="keyword">Update</span>):修改</span><br><span class="line"><span class="number">1.</span> 修改表名</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">rename</span> <span class="keyword">to</span> 新的表名;</span><br><span class="line">2. 修改表的字符集</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="built_in">character</span> <span class="keyword">set</span> 字符集名称;</span><br><span class="line">3. 添加一列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 数据类型;</span><br><span class="line">4. 修改列名称 类型</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">change</span> 列名 新列别 新数据类型;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">modify</span> 列名 新数据类型;</span><br><span class="line">5. 删除列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 列名;</span><br><span class="line">4. D(<span class="keyword">Delete</span>):删除</span><br><span class="line">* <span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br><span class="line">* drop table  if exists 表名 ;</span><br></pre></td></tr></table></figure><h2 id="DML：增删改表中数据"><a href="#DML：增删改表中数据" class="headerlink" title="DML：增删改表中数据"></a>DML：增删改表中数据</h2><pre><code>1. 添加数据：    * 语法：        * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);    * 注意：        1. 列名和值要一一对应。        2. 如果表名后，不定义列名，则默认给所有列添加值            insert into 表名 values(值1,值2,...值n);        3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来2. 删除数据：    * 语法：        * delete from 表名 [where 条件]    * 注意：        1. 如果不加条件，则删除表中所有记录。        2. 如果要删除所有记录            1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作            2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。3. 修改数据：    * 语法：        * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];    * 注意：        1. 如果不加任何条件，则会将表中所有记录全部修改。</code></pre><h2 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">* select * from 表名;</span><br><span class="line"></span><br><span class="line">1. 语法：</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">字段列表</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">表名列表</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">条件列表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">分组字段</span><br><span class="line"><span class="keyword">having</span></span><br><span class="line">分组之后的条件</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">排序</span><br><span class="line"><span class="keyword">limit</span></span><br><span class="line">分页限定</span><br></pre></td></tr></table></figure><pre><code>2. 基础查询    1. 多个字段的查询        select 字段名1，字段名2... from 表名；        * 注意：            * 如果查询所有字段，则可以使用*来替代字段列表。    2. 去除重复：        * distinct    3. 计算列        * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）        * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null            * 表达式1：哪个字段需要判断是否为null            * 如果该字段为null后的替换值。    4. 起别名：        * as：as也可以省略</code></pre><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">3. 条件查询</span><br><span class="line">1. where子句后跟条件</span><br><span class="line">2. 运算符</span><br><span class="line">* &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;</span><br><span class="line">* BETWEEN...AND  </span><br><span class="line">* IN( 集合) </span><br><span class="line">* LIKE：模糊查询</span><br><span class="line">* 占位符：</span><br><span class="line">* _:单个任意字符</span><br><span class="line">* %：多个任意字符</span><br><span class="line">* IS NULL  </span><br><span class="line">* and  或 &amp;&amp;</span><br><span class="line">* or  或 || </span><br><span class="line">* not  或 !</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄大于20岁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age &gt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age &gt;= <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄等于20岁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄不等于20岁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age != <span class="number">20</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age &lt;&gt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄大于等于20 小于等于30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age &gt;= <span class="number">20</span> &amp;&amp;  age &lt;=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age &gt;= <span class="number">20</span> <span class="keyword">AND</span>  age &lt;=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄22岁，18岁，25岁的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age = <span class="number">22</span> <span class="keyword">OR</span> age = <span class="number">18</span> <span class="keyword">OR</span> age = <span class="number">25</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IN</span> (<span class="number">22</span>,<span class="number">18</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询英语成绩为null</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> english = <span class="literal">NULL</span>; <span class="comment">-- 不对的。null值不能使用 = （!=） 判断</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> english <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询英语成绩不为null</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> english  <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询姓马的有哪些？ like</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">'马%'</span>;</span><br><span class="line"><span class="comment">-- 查询姓名第二个字是化的人</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">"_化%"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询姓名是3个字的人</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">'___'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询姓名中包含德的人</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">'%德%'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4. 排序查询</span><br><span class="line">* 语法：order by 子句</span><br><span class="line">* order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...</span><br><span class="line"></span><br><span class="line">* 排序方式：</span><br><span class="line">* ASC：升序，默认的。</span><br><span class="line">* DESC：降序。</span><br><span class="line"></span><br><span class="line">* 注意：</span><br><span class="line">* 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2. 聚合函数：将一列数据作为一个整体，进行纵向的计算。</span><br><span class="line">1. count：计算个数</span><br><span class="line">1. 一般选择非空的列：主键</span><br><span class="line">2. count(*)</span><br><span class="line">2. max：计算最大值</span><br><span class="line">3. min：计算最小值</span><br><span class="line">4. sum：计算和</span><br><span class="line">5. avg：计算平均值</span><br><span class="line">* 注意：聚合函数的计算，排除null值。</span><br><span class="line">解决方案：</span><br><span class="line">1. 选择不包含非空的列进行计算</span><br><span class="line">2. IFNULL函数</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">3. 分组查询:</span><br><span class="line">1. 语法：group by 分组字段；</span><br><span class="line">2. 注意：</span><br><span class="line">1. 分组之后查询的字段：分组字段、聚合函数</span><br><span class="line">2. where 和 having 的区别？</span><br><span class="line">1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来</span><br><span class="line">2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按照性别分组。分别查询男、女同学的平均分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> sex , <span class="keyword">AVG</span>(math) <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按照性别分组。分别查询男、女同学的平均分,人数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> sex , <span class="keyword">AVG</span>(math),<span class="keyword">COUNT</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex;</span><br><span class="line"></span><br><span class="line"><span class="comment">--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组</span></span><br><span class="line"><span class="keyword">SELECT</span> sex , <span class="keyword">AVG</span>(math),<span class="keyword">COUNT</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> math &gt; <span class="number">70</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex;</span><br><span class="line"></span><br><span class="line"><span class="comment">--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人</span></span><br><span class="line"><span class="keyword">SELECT</span> sex , <span class="keyword">AVG</span>(math),<span class="keyword">COUNT</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> math &gt; <span class="number">70</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(<span class="keyword">id</span>) &gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> sex , <span class="keyword">AVG</span>(math),<span class="keyword">COUNT</span>(<span class="keyword">id</span>) 人数 <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> math &gt; <span class="number">70</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex <span class="keyword">HAVING</span> 人数 &gt; <span class="number">2</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4. 分页查询</span><br><span class="line">1. 语法：limit 开始的索引,每页查询的条数;</span><br><span class="line">2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数</span><br><span class="line"><span class="comment">-- 每页显示3条记录 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">3</span>; <span class="comment">-- 第1页</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">LIMIT</span> <span class="number">3</span>,<span class="number">3</span>; <span class="comment">-- 第2页</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">LIMIT</span> <span class="number">6</span>,<span class="number">3</span>; <span class="comment">-- 第3页</span></span><br><span class="line"></span><br><span class="line">3. limit 是一个MySQL"方言"</span><br></pre></td></tr></table></figure><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。</span><br><span class="line">* 分类：</span><br><span class="line">1. 主键约束：primary key</span><br><span class="line">2. 非空约束：not null</span><br><span class="line">3. 唯一约束：unique</span><br><span class="line">4. 外键约束：foreign key</span><br><span class="line"></span><br><span class="line">* 非空约束：not null，值不能为null</span><br><span class="line">1. 创建表时添加约束</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line"><span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="comment">-- name为非空</span></span><br><span class="line">);</span><br><span class="line">2. 创建表完后，添加非空约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">MODIFY</span> <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">3. 删除name的非空约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">MODIFY</span> <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">* 唯一约束：unique，值不能重复</span><br><span class="line">1. 创建表时，添加唯一约束</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">phone_number <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span> <span class="comment">-- 添加了唯一约束</span></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">* 注意mysql中，唯一约束限定的列的值可以有多个null</span><br><span class="line">2. 删除唯一约束</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">DROP</span> <span class="keyword">INDEX</span> phone_number;</span><br><span class="line"></span><br><span class="line">3. 在创建表后，添加唯一约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">MODIFY</span> phone_number <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>;</span><br><span class="line"></span><br><span class="line">* 主键约束：primary key。</span><br><span class="line">1. 注意：</span><br><span class="line">1. 含义：非空且唯一</span><br><span class="line">2. 一张表只能有一个字段为主键</span><br><span class="line">3. 主键就是表中记录的唯一标识</span><br><span class="line"></span><br><span class="line">2. 在创建表时，添加主键约束</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,<span class="comment">-- 给id添加主键约束</span></span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">3. 删除主键</span><br><span class="line"><span class="comment">-- 错误 alter table stu modify id int ;</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span>;</span><br><span class="line"></span><br><span class="line">4. 创建完表后，添加主键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>;</span><br><span class="line"></span><br><span class="line">5. 自动增长：</span><br><span class="line">1.  概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长</span><br><span class="line"></span><br><span class="line">2. 在创建表时，添加主键约束，并且完成主键自增长</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,<span class="comment">-- 给id添加主键约束</span></span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line">3. 删除自动增长</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">INT</span>;</span><br><span class="line">4. 添加自动增长</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。</span><br><span class="line">1. 在创建表时，可以添加外键</span><br><span class="line">* 语法：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">....</span><br><span class="line">外键列</span><br><span class="line"><span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> <span class="keyword">key</span> (外键列名称) <span class="keyword">references</span> 主表名称(主表列名称)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">2. 删除外键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> 外键名称;</span><br><span class="line"></span><br><span class="line">3. 创建表之后，添加外键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (外键字段名称) <span class="keyword">REFERENCES</span> 主表名称(主表列名称);</span><br><span class="line"></span><br><span class="line">4. 级联操作</span><br><span class="line">1. 添加级联操作</span><br><span class="line">语法：<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 </span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (外键字段名称) <span class="keyword">REFERENCES</span> 主表名称(主表列名称) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span>  ;</span><br><span class="line">2. 分类：</span><br><span class="line">1. 级联更新：ON <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> </span><br><span class="line"><span class="number">2.</span> 级联删除：<span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br></pre></td></tr></table></figure><h1 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">1. 多表之间的关系</span><br><span class="line">1. 分类：</span><br><span class="line">1. 一对一(了解)：</span><br><span class="line">* 如：人和身份证</span><br><span class="line">* 分析：一个人只有一个身份证，一个身份证只能对应一个人</span><br><span class="line">2. 一对多(多对一)：</span><br><span class="line">* 如：部门和员工</span><br><span class="line">* 分析：一个部门有多个员工，一个员工只能对应一个部门</span><br><span class="line">3. 多对多：</span><br><span class="line">* 如：学生和课程</span><br><span class="line">* 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择</span><br><span class="line">2. 实现关系：</span><br><span class="line">1. 一对多(多对一)：</span><br><span class="line">* 如：部门和员工</span><br><span class="line">* 实现方式：在多的一方建立外键，指向一的一方的主键。</span><br><span class="line">2. 多对多：</span><br><span class="line">* 如：学生和课程</span><br><span class="line">* 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键</span><br><span class="line">3. 一对一(了解)：</span><br><span class="line">* 如：人和身份证</span><br><span class="line">* 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。</span><br><span class="line"></span><br><span class="line">3. 案例</span><br><span class="line"><span class="comment">/*创建用户表 tab_user</span></span><br><span class="line"><span class="comment">uid 用户主键，自增长</span></span><br><span class="line"><span class="comment">username 用户名长度 100，唯一，非空</span></span><br><span class="line"><span class="comment">password 密码长度 30，非空</span></span><br><span class="line"><span class="comment">name 真实姓名长度 100</span></span><br><span class="line"><span class="comment">birthday 生日</span></span><br><span class="line"><span class="comment">sex 性别，定长字符串 1</span></span><br><span class="line"><span class="comment">telephone 手机号，字符串 11</span></span><br><span class="line"><span class="comment">email 邮箱，字符串长度 100</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_user (</span><br><span class="line">uid <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">username <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">PASSWORD</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">birthday <span class="built_in">DATE</span>,</span><br><span class="line">sex <span class="built_in">CHAR</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">'男'</span>,</span><br><span class="line">telephone <span class="built_in">VARCHAR</span>(<span class="number">11</span>),</span><br><span class="line">email <span class="built_in">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="数据库设计的范式"><a href="#数据库设计的范式" class="headerlink" title="数据库设计的范式"></a>数据库设计的范式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 第一范式（1NF）：每一列都是不可分割的原子数据项</span><br><span class="line">2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）</span><br><span class="line">* 几个概念：</span><br><span class="line">1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A</span><br><span class="line">例如：学号--&gt;姓名。  （学号，课程名称） --&gt; 分数</span><br><span class="line">2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。</span><br><span class="line">例如：（学号，课程名称） --&gt; 分数</span><br><span class="line">3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。</span><br><span class="line">例如：（学号，课程名称） -- &gt; 姓名</span><br><span class="line">4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A</span><br><span class="line">例如：学号--&gt;系名，系名--&gt;系主任</span><br><span class="line">5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码</span><br><span class="line">例如：该表中码为：（学号，课程名称）</span><br><span class="line">* 主属性：码属性组中的所有属性</span><br><span class="line">* 非主属性：除过码属性组的属性</span><br><span class="line">3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</span><br></pre></td></tr></table></figure><h2 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 命令行：</span><br><span class="line">* 语法：</span><br><span class="line">* 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径</span><br><span class="line">* 还原：</span><br><span class="line">1. 登录数据库</span><br><span class="line">2. 创建数据库</span><br><span class="line">3. 使用数据库</span><br><span class="line">4. 执行文件。source 文件路径</span><br><span class="line">2. 也可以使用图形化工具, 更加方便</span><br><span class="line">推荐 Navicat for MySQL, 个人觉得比较好用</span><br></pre></td></tr></table></figure><h1 id="MySQL的多表查询-amp-事务"><a href="#MySQL的多表查询-amp-事务" class="headerlink" title="MySQL的多表查询&amp;事务"></a>MySQL的多表查询&amp;事务</h1><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 查询语法：</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">列名列表</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">表名列表</span><br><span class="line">where....</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 笛卡尔积：</span><br><span class="line">* 有两个集合A,B .取这两个集合的所有组成情况。</span><br><span class="line">* 要完成多表查询，需要消除无用的数据</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 多表查询的分类：</span><br><span class="line">1. 内连接查询：</span><br><span class="line">1. 隐式内连接：使用where条件消除无用数据</span><br><span class="line">* 语法： SELECT * FROM 表1,表2 WHERE 表名1.`表1的外键` = 表2的主键;</span><br><span class="line">其中表1的外键是表二的主键</span><br><span class="line">2. 显式内连接：</span><br><span class="line">* 语法： select 字段列表 from 表1 [inner] join 表2 on 条件</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1. 事务的基本介绍</span><br><span class="line">1. 概念:</span><br><span class="line">如果一个包含多个步骤的业务操作, 被事务管理, 那么这些操作要么都成功, 要们都失败</span><br><span class="line">2.操作:</span><br><span class="line">1.开启事务: <span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line">2.回滚: <span class="keyword">rollback</span>;</span><br><span class="line">3.提交: <span class="keyword">commit</span>;</span><br><span class="line">2. 事务的四大特征(ACID):</span><br><span class="line">1. 原子性(Atomicity): 是不可分割的最小操作单位, 要么都成功, 要么都失败</span><br><span class="line">2. 一致性(Consistency): 事务操作前后, 数据总量不变</span><br><span class="line">3. 隔离性(Isolation): 多个事务之间, 相互独立</span><br><span class="line">4. 持久性(Durability): 当事务提交或回滚后, 数据库会持久化的保存数据</span><br><span class="line">3. 事务的隔离级别</span><br><span class="line">1. 概念: 多个事务之间是隔离的,相互独立的, 但是如果多个事务操作同一批数据, 则会引发一些问题,设置不同的隔离级别就可以解决这些问题</span><br><span class="line">2. 存在的问题:</span><br><span class="line">1.脏读: 一个事务,读取到另一个事务中没有提交的数据</span><br><span class="line">2.不可重复读(虚读): 在同一个事务中,两次读取到的数据不一样</span><br><span class="line">2.幻读: 一个事务操作(DML)数据表中的所有记录, 另一个事务添加了一条数据,则第一个事务查询不到自己的修改</span><br><span class="line">3. 隔离级别:</span><br><span class="line">1.read uncommitted: 读未提交</span><br><span class="line">产生的问题: 脏读, 不可重复读, 幻读</span><br><span class="line">2. read committed: 读已提交(Oracle)</span><br><span class="line">        产生的问题: 不可重复读, 幻读</span><br><span class="line">        3. repeatable read: 可重复读(MySQL默认)</span><br><span class="line">        产生的问题: 幻读</span><br><span class="line">        4. serializable: 串行化</span><br><span class="line">        可以解决所有问题</span><br><span class="line">注意: 隔离级别从小到大安全性越来越高, 但是效率越来越低</span><br><span class="line"> 数据库查询隔离级别: <span class="keyword">select</span> @@tx_isolation;</span><br><span class="line"> 数据库设置隔离级别: <span class="keyword">set</span> <span class="keyword">global</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> 级别字符串;</span><br></pre></td></tr></table></figure><h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">DCL：管理用户，授权</span><br><span class="line">1. 管理用户</span><br><span class="line">1. 添加用户：</span><br><span class="line">* 语法：CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';</span><br><span class="line">2. 删除用户：</span><br><span class="line">* 语法：DROP USER '用户名'@'主机名';</span><br><span class="line">3. 修改用户密码：</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">USER</span> <span class="keyword">SET</span> <span class="keyword">PASSWORD</span> = <span class="keyword">PASSWORD</span>(<span class="string">'新密码'</span>) <span class="keyword">WHERE</span> <span class="keyword">USER</span> = <span class="string">'用户名'</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">USER</span> <span class="keyword">SET</span> <span class="keyword">PASSWORD</span> = <span class="keyword">PASSWORD</span>(<span class="string">'abc'</span>) <span class="keyword">WHERE</span> <span class="keyword">USER</span> = <span class="string">'lisi'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> <span class="keyword">FOR</span> <span class="string">'用户名'</span>@<span class="string">'主机名'</span> = <span class="keyword">PASSWORD</span>(<span class="string">'新密码'</span>);</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> <span class="keyword">FOR</span> <span class="string">'root'</span>@<span class="string">'localhost'</span> = <span class="keyword">PASSWORD</span>(<span class="string">'123'</span>);</span><br><span class="line"></span><br><span class="line">* mysql中忘记了root用户的密码？</span><br><span class="line">1. cmd <span class="comment">-- &gt; net stop mysql 停止mysql服务</span></span><br><span class="line">* 需要管理员运行该cmd</span><br><span class="line"></span><br><span class="line">2. 使用无验证方式启动mysql服务： mysqld <span class="comment">--skip-grant-tables</span></span><br><span class="line">3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功</span><br><span class="line">4. <span class="keyword">use</span> mysql;</span><br><span class="line">5. <span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> <span class="keyword">password</span> = <span class="keyword">password</span>(<span class="string">'你的新密码'</span>) <span class="keyword">where</span> <span class="keyword">user</span> = <span class="string">'root'</span>;</span><br><span class="line">6. 关闭两个窗口</span><br><span class="line">7. 打开任务管理器，手动结束mysqld.exe 的进程</span><br><span class="line">8. 启动mysql服务</span><br><span class="line">9. 使用新密码登录。</span><br><span class="line">4. 查询用户：</span><br><span class="line"><span class="comment">-- 1. 切换到mysql数据库</span></span><br><span class="line"><span class="keyword">USE</span> myql;</span><br><span class="line"><span class="comment">-- 2. 查询user表</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">USER</span>;</span><br><span class="line"></span><br><span class="line">* 通配符： % 表示可以在任意主机使用用户登录数据库</span><br><span class="line"></span><br><span class="line">2. 权限管理：</span><br><span class="line">1. 查询权限：</span><br><span class="line"><span class="comment">-- 查询权限</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> <span class="string">'用户名'</span>@<span class="string">'主机名'</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> <span class="string">'lisi'</span>@<span class="string">'%'</span>;</span><br><span class="line"></span><br><span class="line">2. 授予权限：</span><br><span class="line"><span class="comment">-- 授予权限</span></span><br><span class="line"><span class="keyword">grant</span> 权限列表 <span class="keyword">on</span> 数据库名.表名 <span class="keyword">to</span> <span class="string">'用户名'</span>@<span class="string">'主机名'</span>;</span><br><span class="line"><span class="comment">-- 给张三用户授予所有权限，在任意数据库任意表上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'zhangsan'</span>@<span class="string">'localhost'</span>;</span><br><span class="line">3. 撤销权限：</span><br><span class="line"><span class="comment">-- 撤销权限：</span></span><br><span class="line"><span class="keyword">revoke</span> 权限列表 <span class="keyword">on</span> 数据库名.表名 <span class="keyword">from</span> <span class="string">'用户名'</span>@<span class="string">'主机名'</span>;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> db3.<span class="string">`account`</span> <span class="keyword">FROM</span> <span class="string">'lisi'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL基础知识汇总&quot;&gt;&lt;a href=&quot;#MySQL基础知识汇总&quot; class=&quot;headerlink&quot; title=&quot;MySQL基础知识汇总&quot;&gt;&lt;/a&gt;MySQL基础知识汇总&lt;/h1&gt;&lt;h2 id=&quot;数据库的基本概念&quot;&gt;&lt;a href=&quot;#数据库的基本概念&quot;
      
    
    </summary>
    
      <category term="SQL" scheme="http://yoursite.com/categories/SQL/"/>
    
    
      <category term="MySQL, sql语句, MySQL概念" scheme="http://yoursite.com/tags/MySQL-sql%E8%AF%AD%E5%8F%A5-MySQL%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题库以及详解</title>
    <link href="http://yoursite.com/2019/07/24/%E5%89%91%E6%8C%87offer/"/>
    <id>http://yoursite.com/2019/07/24/剑指offer/</id>
    <published>2019-07-24T03:53:54.081Z</published>
    <updated>2019-07-27T06:47:17.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a><strong>剑指offer</strong></h1><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p><strong>题目</strong>:在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>思路</strong>:因为这个二维数组是有序的, 可以先定位到左下角, 判断要找的数,  如果target &gt; 左下角 就往右找, 然后target &lt; 左下角 就往上找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line"><span class="comment">//得到二维数组的行和列</span></span><br><span class="line"><span class="keyword">int</span> rows = array.length;</span><br><span class="line"><span class="keyword">int</span> cols = array[<span class="number">0</span>].length;</span><br><span class="line"><span class="comment">//定位到左下角</span></span><br><span class="line"><span class="keyword">int</span> i = rows - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//循环查找, 不知道循环次数, 用while</span></span><br><span class="line"><span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &lt; cols)&#123;</span><br><span class="line"><span class="keyword">if</span>(target &gt; array[i][j])</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[i][j])</span><br><span class="line">i--;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p><strong>题目</strong>: 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p><strong>思路</strong>:首先不能使用String提供的replace()方法</p><p>①从前往后替换, 每替换一次后面的字符就要移动一次, 效率低下</p><p>②从后往前替换, 每个字符只需要移动一次, 所以选择这个思路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line"><span class="comment">//计算空格数</span></span><br><span class="line"><span class="keyword">int</span> spacenum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(str.charAt(i) == <span class="string">' '</span>)</span><br><span class="line">spacenum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩容</span></span><br><span class="line"><span class="keyword">int</span> indexOld = str.length() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> newLength = str.length() + spacenum * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> indexNew = newLength - <span class="number">1</span>;</span><br><span class="line">str.setLength(indexNew);</span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line"><span class="keyword">for</span>(;indexOld &gt;= <span class="number">0</span> &amp;&amp; newLength &gt; indexOld; --indexOld)&#123;</span><br><span class="line"><span class="keyword">if</span>(str.charAt(indexOld) == <span class="string">' '</span>)&#123;</span><br><span class="line">str.setCharAt(indexNew--, <span class="string">'0'</span>);</span><br><span class="line">str.setCharAt(indexNew--, <span class="string">'2'</span>);</span><br><span class="line">str.setCharAt(indexNew--, <span class="string">'%'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">str.setCharAt(indexNew--, str.charAt(indexOld));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p><strong>题目</strong>: 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> val;</span><br><span class="line">       ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">           <span class="keyword">this</span>.val = val;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>代码实现:</strong> </p><p>解法一: 递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">//先创建一个 ArrayList 集合</span></span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断传入的链表是否不为空</span></span><br><span class="line"><span class="keyword">if</span>(listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//递归调用 printListFromTailToHead()方法, 传入链表的元素</span></span><br><span class="line"><span class="keyword">this</span>.printListFromTailToHead(listNode.next);</span><br><span class="line"><span class="comment">//将遍历出来的链表的元素的值添加入 arrayList 中</span></span><br><span class="line">arrayList.add(listNode.val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二: 利用栈(先进后出)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; temp = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; newList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ListNode t = listNode;</span><br><span class="line">        <span class="keyword">while</span>( t != <span class="keyword">null</span> )&#123;</span><br><span class="line">temp.push(t.val);</span><br><span class="line">t = t.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>( !temp.empty() )&#123;</span><br><span class="line">newList.add(temp.pop());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><p><strong>题目</strong>: 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Definition <span class="keyword">for</span> binary tree</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> val;</span><br><span class="line">       TreeNode left;</span><br><span class="line">       TreeNode right;</span><br><span class="line">       TreeNode(<span class="keyword">int</span> x) &#123; val = x;&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>代码实现:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        TreeNode root=reConstructBinaryTree(pre,<span class="number">0</span>,pre.length-<span class="number">1</span>,in,<span class="number">0</span>,in.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> startPre,<span class="keyword">int</span> endPre,<span class="keyword">int</span> [] in,<span class="keyword">int</span> startIn,<span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(startPre&gt;endPre||startIn&gt;endIn)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root= <span class="keyword">new</span> TreeNode(pre[startPre]); <span class="comment">//前序遍历结果的 第一个元素就是根节点</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=startIn;i&lt;=endIn;i++)</span><br><span class="line">            <span class="keyword">if</span>(in[i]==pre[startPre])&#123;</span><br><span class="line">                root.left=reConstructBinaryTree(pre,startPre+<span class="number">1</span>,startPre+i-startIn,in,startIn,i-<span class="number">1</span>);</span><br><span class="line">                root.right=reConstructBinaryTree(pre,i-startIn+startPre+<span class="number">1</span>,endPre,in,i+<span class="number">1</span>,endIn);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                 </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h2><p><strong>题目</strong>: 用两个栈来实现一个队列,完成队列的Push和Pop操作, 队列中的元素为 int 类型</p><p><strong>思路</strong>: 首先栈是先进后出, 队列是先进先出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//队列的 push 操作和 栈的 push 是相同的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断 stack1 和 stack2 是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(stack1.empty()&amp;&amp;stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h2><p><strong>题目</strong>:把一个数组最开始的若干元素搬到数组的末尾, 我们称之为数组的旋转. 输入一个非减排序的数组的一个旋转, 输出旋转数组的最小元素.例如数组{3,4,5,1,2} 为 {1,2,3,4,5}, 该数组的最小值为1, NOTE: 给出的所有元素都大于0, 若数组大小为0 ,请返回0</p><p><strong>思路</strong>:(1)array[mid] &gt; array[high]:<br>            出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。<br>            low = mid + 1<br>         (2)array[mid] == array[high]:<br>            出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边<br>            还是右边,这时只好一个一个试 ，<br>            high = high - 1<br>         (3)array[mid] &lt; array[high]:<br>            出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左<br>            边。因为右边必然都是递增的。<br>            high = mid</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> hight = array.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(low &lt; hight)&#123;</span><br><span class="line"><span class="comment">//中间的位置</span></span><br><span class="line"><span class="keyword">int</span> mid = low + (hight - low)/<span class="number">2</span>;</span><br><span class="line"><span class="comment">//若中间的数 &gt; 最后一个数, 最小的数就是中间数的下一个</span></span><br><span class="line"><span class="keyword">if</span>(array[mid] &gt; array[hight])&#123;</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//若中间的数 = 最后一个数, 最小的数左右都有可能, 所有要缩小,继续找</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] == array[hight])&#123;</span><br><span class="line">hight -= <span class="number">1</span>;</span><br><span class="line"><span class="comment">//若中间的数 &lt; 最后一个数, 最小的数只能是中间的数,或,中间数的左边的数中的某一个</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">hight = mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> array[low];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h2><p><strong>题目</strong>: 输入一个整数n, 请你输出斐波那契列的第n项(从0开始,第0项为0)</p><p><strong>思路一:</strong> 采用递归, 这种解法效率低, 每次都要调自己</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路二:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"输入的数不能小于0"</span>);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            sum = a + b;</span><br><span class="line">            b = a;</span><br><span class="line">            a = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h2><p><strong>题目</strong>: 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><p><strong>思路</strong>: 这还是一个斐波那契列, 唯一不同的是从1开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"台阶数不能小于1"</span>);;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">3</span>) <span class="keyword">return</span> target;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= target;i++)&#123;</span><br><span class="line">            sum = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h2><p><strong>题目</strong>: 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。<br>            求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><strong>分析</strong>:    f(1) = 1<br>            f(2) = f(2-1) + f(2-2)         //f(2-2) 表示2阶一次跳2阶的次数。<br>            f(3) = f(3-1) + f(3-2) + f(3-3)<br>            …<br>            f(n) = f(n-1) + f(n-2) + f(n-3) + … + f(n-(n-1)) + f(n-n) </p><pre><code>说明：     1）这里的f(n) 代表的是n个台阶有一次1,2,...n阶的 跳法数。    2）n = 1时，只有1种跳法，f(1) = 1    3) n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ，f(2) = f(2-1) + f(2-2)     4) n = 3时，会有三种跳得方式，1阶、2阶、3阶，那么就是第一次跳出1阶后面剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3)因此结论是f(3) = f(3-1)+f(3-2)+f(3-3)    5) n = n时，会有n中跳的方式，1阶、2阶...n阶，得出结论：f(n) = f(n-1)+f(n-2)+...+f(n-(n-1)) + f(n-n) =&gt; f(0) + f(1) + f(2) + f(3) + ... + f(n-1)    6) 由以上已经是一种结论，但是为了简单，我们可以继续简化：f(n-1) = f(0) + f(1)+f(2)+f(3) + ... + f((n-1)-1) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2)f(n) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2) + f(n-1) = f(n-1) + f(n-1)可以得出：f(n) = 2*f(n-1)    7) 得出最终结论,在n阶台阶，一次有1、2、...n阶的跳的方式时，总得跳法为：               | 1       ,(n=0 )     f(n) =     | 1       ,(n=1 )               | 2*f(n-1),(n&gt;=2)</code></pre><p><strong>代码实现:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"台阶数不能小于0"</span>);</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * JumpFloorII(target - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h2><p><strong>题目</strong>: 我们可以用2×1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2×n的大矩形，总共有多少种方法？</p><p><strong>分析</strong>: 还是一个斐波那契</p><p>采用递归:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"输入的n不能小于0的整数"</span>);</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> || target == <span class="number">1</span> || target == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> RectCover(target - <span class="number">1</span>) + RectCover(target - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不用递归, 效率比较高的解法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"输入的数不能小于0"</span>);</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> || target == <span class="number">1</span>) <span class="keyword">return</span> target;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= target;i++)&#123;</span><br><span class="line">            sum = a + b;</span><br><span class="line">            b = a;</span><br><span class="line">            a = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第十一题"><a href="#第十一题" class="headerlink" title="第十一题"></a>第十一题</h2><p><strong>题目</strong>: 输入一个整数, 输出该数二进制表示中1的个数, 其中负数用补码表示</p><p><strong>思路</strong>:如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</p><p><strong>举个例子</strong>：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">count++;</span><br><span class="line">n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第十二题"><a href="#第十二题" class="headerlink" title="第十二题"></a>第十二题</h2><p>题目: 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>解法一: 常规解法, 时间复杂度为O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//abs() : 返回这个数的绝对值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Math.abs(exponent);i++)&#123;</span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            result = <span class="number">1</span>/result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二: 递归: </p><blockquote><p>​        n为偶数时, a^n = a^(n/2) * a^(n/2)</p><p>​        n为奇数时, a^n=（a^（n-1）/2）×（a^（n-1/2））×a</p><p>时间复杂度为 O(logn)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Solution</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = Math.abs(exponent);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> base;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> result = Power(base, n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        result *= result;</span><br><span class="line">        <span class="keyword">if</span>((n&amp;<span class="number">1</span>) == <span class="number">1</span>) result *= base;</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>) result = <span class="number">1</span>/result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第十三题"><a href="#第十三题" class="headerlink" title="第十三题"></a>第十三题</h2><p>题目: 输入一个整数数组,实现一个函数来调整该数组中的数字的顺序,使得所有的奇数位于数组的前半部分,所有的偶数位于数组的后半部分,并保证奇数和奇数,偶数和偶数之间的相对位置不变.</p><p>思路: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先统计奇数的个数</span><br><span class="line">然后新建一个等长数组，设置两个指针，奇数指针从0开始，偶数指针从奇数个数的末尾开始 遍历，填数</span><br><span class="line">此方法的时间复杂度为O(n)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span> ||array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> oddCount = <span class="number">0</span>,oddBegin = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//创建一个和原数组等长的新数组</span></span><br><span class="line">        <span class="keyword">int</span>[] newArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array.length;i++)&#123;</span><br><span class="line">            <span class="comment">//判断数组元素为奇数时,将oddCount向后移一位,</span></span><br><span class="line">            <span class="comment">//最终oddCount的位置就是第一个偶数的位置</span></span><br><span class="line">            <span class="keyword">if</span>((array[i]&amp;<span class="number">1</span>) == <span class="number">1</span>) oddCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array.length;i++)&#123;</span><br><span class="line">            <span class="comment">//判断元素为奇数就从新数组的开头位置开始放</span></span><br><span class="line">            <span class="keyword">if</span>((array[i]&amp;<span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                newArray[oddBegin++] = array[i];</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果元素为偶数就从新数组的偶数第一个位置开始放</span></span><br><span class="line">                newArray[oddCount++] = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后用新数组排好序的元素替换原数组的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array.length;i++)&#123;</span><br><span class="line">            array[i] = newArray[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第十四题"><a href="#第十四题" class="headerlink" title="第十四题"></a>第十四题</h2><p>题目: 输入一个链表,输出该链表中倒数第K个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure><p>思路: 定义两个指针, 先让着两个指针都指向链表的头结点, 然后让其中一个指针往后移(k - 1)位, 再让另一个指针开始跑(此时两个指针在相对静止的跑), 当先跑的那个指针到达链表末尾时, 后跑的那个指针到达的位置就是倒数第k的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义两个指针都指向头结点</span></span><br><span class="line">        ListNode p, q;</span><br><span class="line">        p = q = head;</span><br><span class="line">        <span class="comment">//记录k值</span></span><br><span class="line">        <span class="keyword">int</span> a = k;</span><br><span class="line">        <span class="comment">//记录节点个数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; <span class="number">1</span>) q = q.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &lt; a) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">精简写法</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    ListNode p, q;</span><br><span class="line">    p = q = head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; p != <span class="keyword">null</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= k) q = q.next;</span><br><span class="line">    p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i &lt; k ? <span class="keyword">null</span> : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第十五题"><a href="#第十五题" class="headerlink" title="第十五题"></a>第十五题</h2><p>题目: 输入一个人链表, 反转链表后, 输出新链表的表头.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure><p>题解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null；</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点</span></span><br><span class="line">        <span class="comment">//需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre&lt;-head next1-&gt;next2</span></span><br><span class="line">        <span class="comment">//即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了</span></span><br><span class="line">        <span class="comment">//所以需要用到pre和next两个节点</span></span><br><span class="line">        <span class="comment">//1-&gt;2-&gt;3-&gt;4-&gt;5</span></span><br><span class="line">        <span class="comment">//1&lt;-2&lt;-3 4-&gt;5</span></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre</span></span><br><span class="line">            <span class="comment">//如此就可以做到反转链表的效果</span></span><br><span class="line">            <span class="comment">//先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂</span></span><br><span class="line">            next = head.next;</span><br><span class="line">            <span class="comment">//保存完next，就可以让head从指向next变成指向pre了，代码如下</span></span><br><span class="line">            head.next = pre;</span><br><span class="line">            <span class="comment">//head指向pre后，就继续依次反转下一个节点</span></span><br><span class="line">            <span class="comment">//让pre，head，next依次向后移动一个节点，继续下一次的指针反转</span></span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果head为null的时候，pre就为最后一个节点了，但是链表已经反转完毕，pre就是反转后链表的第一个节点</span></span><br><span class="line">        <span class="comment">//直接输出pre就是我们想要得到的反转后的链表</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="未完-待续………"><a href="#未完-待续………" class="headerlink" title="未完,待续………."></a>未完,待续……….</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;剑指offer&quot;&gt;&lt;a href=&quot;#剑指offer&quot; class=&quot;headerlink&quot; title=&quot;剑指offer&quot;&gt;&lt;/a&gt;&lt;strong&gt;剑指offer&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;h
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指offer, 算法, 详解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer-%E7%AE%97%E6%B3%95-%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
</feed>
